
<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Simulation - Intelligent Snake Experience</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --accent: #f093fb;
      --success: #4ade80;
      --danger: #ef4444;
      --warning: #fbbf24;
      --dark: #1a1a2e;
      --darker: #0f0f23;
      --light: #eef2ff;
      --text: #e2e8f0;
      --glass: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.2);
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
      min-height: 100vh;
      color: var(--text);
      overflow-x: hidden;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
      opacity: 0.03;
      animation: rotate 60s linear infinite;
      z-index: -1;
    }
    @keyframes rotate {
      to { transform: rotate(360deg); }
    }
    /* Navigation */
    nav {
      background: var(--glass);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--glass-border);
      padding: 1rem 2rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }
    .nav-container {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .logo {
      font-size: 1.8rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .logo::before {
      content: 'üêç';
      font-size: 2rem;
      -webkit-text-fill-color: initial;
    }
    .nav-links {
      display: flex;
      gap: 2rem;
      list-style: none;
    }
    .nav-links a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      transition: all 0.3s;
      position: relative;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
    }
    .nav-links a:hover {
      color: var(--accent);
      background: var(--glass);
    }
    .nav-links a.active {
      color: var(--accent);
      background: var(--glass);
    }
    /* Page transitions */
    .page {
      display: none;
      animation: fadeIn 0.5s ease-in-out;
    }
    .page.active {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* Main container */
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 3rem 2rem;
    }
    /* Hero section */
    .hero {
      text-align: center;
      margin-bottom: 3rem;
    }
    .hero h1 {
      font-size: 3.5rem;
      font-weight: 900;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, var(--light) 0%, var(--accent) 50%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient 3s ease-in-out infinite;
      background-size: 200%;
    }
    @keyframes gradient {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    .hero p {
      font-size: 1.2rem;
      color: var(--text);
      opacity: 0.8;
      max-width: 600px;
      margin: 0 auto;
    }
    /* Game section */
    .game-wrapper {
      display: flex;
      gap: 3rem;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
    }
    .game-container {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 2rem;
      padding: 2rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }
    .game-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, var(--accent), var(--primary), var(--secondary));
      border-radius: 2rem;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .game-container:hover::before {
      opacity: 0.5;
    }
    #game {
      border-radius: 1rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s;
    }
    #game:hover {
      transform: scale(1.02);
    }
    /* Controls panel */
    .controls-panel {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      min-width: 350px;
      max-width: 400px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      max-height: 90vh;
      overflow-y: auto;
    }
    .controls-panel::-webkit-scrollbar {
      width: 8px;
    }
    .controls-panel::-webkit-scrollbar-track {
      background: var(--darker);
      border-radius: 4px;
    }
    .controls-panel::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 4px;
    }
    .controls-section {
      margin-bottom: 2rem;
    }
    .controls-section h3 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .controls-section h3::before {
      content: '‚ö°';
      font-size: 1.5rem;
    }
    /* Modern buttons */
    .button {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      position: relative;
      overflow: hidden;
    }
    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      transition: left 0.5s;
    }
    .button:hover::before {
      left: 100%;
    }
    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    .button:active {
      transform: translateY(0);
    }
    .button.toggle-active {
      background: linear-gradient(135deg, var(--success) 0%, var(--accent) 100%);
      box-shadow: 0 8px 25px rgba(74, 222, 128, 0.45);
    }
    .manual-hint {
      font-size: 0.85rem;
      margin-top: 0.5rem;
      color: var(--light);
      opacity: 0.7;
      text-align: center;
    }
    .button.danger {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
    }
    .button.danger:hover {
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.6);
    }
    /* Speed controls */
    .speed-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      justify-content: center;
      margin: 1rem 0;
    }
    .speed-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.2rem;
      padding: 0.8rem 1.2rem;
      min-width: 100px;
    }
    .speed-btn span {
      display: block;
    }
    .speed-display {
      background: var(--darker);
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      min-width: 140px;
      text-align: center;
      font-weight: 600;
      border: 1px solid var(--primary);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
    }
    /* Size controls */
    .size-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin: 1rem 0;
    }
    .size-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 8px;
      background: var(--darker);
      border-radius: 4px;
      outline: none;
      position: relative;
    }
    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
      transition: all 0.3s;
    }
    .size-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
    }
    .select-control {
      width: 100%;
      padding: 0.6rem 0.8rem;
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 0.75rem;
      color: var(--text);
      font-weight: 500;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .select-control:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(240, 147, 251, 0.25);
    }
    .select-control option {
      background: var(--dark);
      color: var(--text);
    }
    /* Parameter controls */
    .param-control {
      margin-bottom: 1.5rem;
    }
    .param-control label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--text);
    }
    .param-control label span {
      color: var(--accent);
      font-weight: 700;
      min-width: 40px;
      text-align: right;
    }
    .param-control small {
      display: block;
      margin-top: 0.3rem;
      color: var(--text);
      opacity: 0.6;
      font-size: 0.8rem;
    }
    .param-control .size-slider {
      width: 100%;
    }
    /* Status display */
    .status-display {
      background: var(--darker);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-top: 1rem;
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    .status-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--glass-border);
    }
    .status-item:last-child {
      border-bottom: none;
    }
    .status-label {
      color: var(--text);
      opacity: 0.8;
    }
    .status-value {
      font-weight: 600;
      color: var(--accent);
    }
    /* AI Status messages */
    #statusMessages {
      background: var(--darker);
      border-radius: 1rem;
      padding: 1rem;
      margin-top: 1rem;
      min-height: 120px;
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    #statusMessages p {
      margin: 0.3rem 0;
      font-size: 0.9rem;
      opacity: 0.9;
    }
    #strategyStatus {
      color: var(--accent);
      font-weight: 600;
      font-size: 1rem;
    }
    .status-explanation {
      color: var(--text);
      opacity: 0.85;
      line-height: 1.4;
    }
    #hamStatus { color: #4ade80; }
    #loopStatus { color: #fbbf24; }
    #compactStatus { color: #f97316; }
    /* Info page */
    .info-content {
      max-width: 800px;
      margin: 0 auto;
    }
    .info-section {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .info-section h2 {
      color: var(--accent);
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }
    .info-section h3 {
      color: var(--primary);
      margin: 1.5rem 0 1rem;
    }
    .info-section p, .info-section li {
      line-height: 1.8;
      opacity: 0.9;
    }
    .info-section ul {
      list-style: none;
      padding-left: 0;
    }
    .info-section li {
      position: relative;
      padding-left: 2rem;
      margin-bottom: 0.5rem;
    }
    .info-section li::before {
      content: '‚Üí';
      position: absolute;
      left: 0;
      color: var(--accent);
      font-weight: bold;
    }
    /* Contact page */
    .contact-content {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }
    .contact-card {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 3rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .contact-card h2 {
      color: var(--accent);
      margin-bottom: 2rem;
      font-size: 2rem;
    }
    .contact-info {
      font-size: 1.2rem;
      margin: 2rem 0;
    }
    .contact-email {
      display: inline-block;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 1rem 2rem;
      border-radius: 2rem;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      margin-top: 1rem;
    }
    .contact-email:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    /* Combo preset styling */
    .combo-preset {
      background: var(--darker);
      padding: 1.5rem;
      border-radius: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--primary);
    }
    .combo-preset ul {
      margin-bottom: 1rem;
    }
    .combo-preset li {
      padding-left: 1.5rem;
      font-family: monospace;
      font-size: 1.1rem;
      color: var(--accent);
    }
    .load-preset {
      width: 100%;
      background: linear-gradient(135deg, var(--primary), var(--accent));
    }
    /* Responsive */
    @media (max-width: 768px) {
      .nav-container {
        flex-direction: column;
        gap: 1rem;
      }
      .hero h1 {
        font-size: 2.5rem;
      }
      .game-wrapper {
        flex-direction: column;
      }
      .controls-panel {
        width: 100%;
        max-width: none;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav>
    <div class="nav-container">
      <div class="logo">Snake Simulation</div>
      <ul class="nav-links">
        <li><a href="#" class="nav-link active" data-page="game">Game</a></li>
        <li><a href="#" class="nav-link" data-page="guide">Guide</a></li>
        <li><a href="#" class="nav-link" data-page="facit">Presets</a></li>
        <li><a href="#" class="nav-link" data-page="contact">Contact</a></li>
      </ul>
    </div>
  </nav>
  <!-- Game Page -->
  <div id="game-page" class="page active">
    <div class="container">
      <div class="hero">
        <h1>Snake Simulation</h1>
          <p>Your goal is to find the best adjustments to complete the board</p>
          <p>Adjust Grid size for longer simulations</p>
      </div>
      <div class="game-wrapper">
        <div class="game-container">
          <canvas id="game" width="600" height="600"></canvas>
        </div>
        <div class="controls-panel">
          <div class="controls-section">
            <h3>Game Controls</h3>
            <div class="speed-controls">
              <button id="slowerBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">üêå</span>
                <span>Slower</span>
              </button>
              <div id="speedDisplay" class="speed-display">Speed: 100ms</div>
              <button id="fasterBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">‚ö°</span>
                <span>Faster</span>
              </button>
            </div>
            <div style="margin-top: 1rem;">
              <button id="restartBtn" class="button danger" style="width: 100%;">üîÑ Restart</button>
            </div>
            <div style="margin-top: 0.8rem;">
              <button id="manualToggle" class="button" style="width: 100%;">üïπÔ∏è Try Manual Play</button>
              <p id="manualHint" class="manual-hint">Manual mode off ‚Äì AI is playing automatically.</p>
            </div>
          </div>
          <div class="controls-section">
            <h3>Grid Size</h3>
            <div class="param-control">
              <label>Columns (COLS): <span id="colsValue">20</span></label>
              <input type="range" id="colsSlider" class="size-slider" min="10" max="100" value="20" step="5">
            </div>
            <div class="param-control">
              <label>Rows (ROWS): <span id="rowsValue">20</span></label>
              <input type="range" id="rowsSlider" class="size-slider" min="10" max="100" value="20" step="5">
            </div>
            <small style="display: block; margin-top: -0.5rem; color: var(--warning); opacity: 0.8;">
              ‚ö°Changing grid size will restart the game
            </small>
          </div>
          <div class="controls-section">
            <h3>Canvas Size</h3>
            <div class="size-controls">
              <span>Small</span>
              <input type="range" id="sizeSlider" class="size-slider" min="300" max="800" value="400" step="50">
              <span>Large</span>
            </div>
          </div>
          <div class="controls-section">
            <h3>AI Parameters</h3>
            <div class="param-control">
              <label>Endgame Threshold: <span id="endgameValue">20</span></label>
              <input type="range" id="endgameSlider" class="size-slider" min="0" max="100" value="20" step="5">
              <small>Free cells for endgame mode</small>
            </div>
            <div class="param-control">
              <label>Loop Streak Threshold: <span id="loopThreshValue">3</span></label>
              <input type="range" id="loopThreshSlider" class="size-slider" min="1" max="10" value="3" step="1">
              <small>Loops detected before ‚Üí Hamilton mode</small>
            </div>
            <div class="param-control">
              <label>No Progress Threshold: <span id="progThreshValue">70</span></label>
              <input type="range" id="progThreshSlider" class="size-slider" min="10" max="200" value="70" step="5">
              <small>Moves without progress ‚Üí Hamilton mode</small>
            </div>
            <div class="param-control">
              <label for="compactProfile">Compact Mode Stil</label>
              <select id="compactProfile" class="select-control">
                <option value="cautious">Extremt f√∂rsiktig</option>
                <option value="balanced" selected>Balanserad (nuvarande)</option>
                <option value="risky">Extremt v√•ghalsig</option>
              </select>
              <small id="compactProfileHint">Standardbeteende som reagerar p√• fickor eller loopar.</small>
            </div>
            <div class="param-control">
              <label>Compact Mode Steps: <span id="compactValue">200</span></label>
              <input type="range" id="compactSlider" class="size-slider" min="0" max="300" value="200" step="10">
              <small>Max steps in compact mode</small>
            </div>
          </div>
          <div class="controls-section">
            <h3>Game Status</h3>
            <div class="status-display">
              <div class="status-item">
                <span class="status-label">Length:</span>
                <span id="snakeLength" class="status-value">3</span>
              </div>
              <div class="status-item">
                <span class="status-label">Free cells:</span>
                <span id="freeCells" class="status-value">222</span>
              </div>
              <div class="status-item">
                <span class="status-label">Progress:</span>
                <span id="progress" class="status-value">1.3%</span>
              </div>
            </div>
          </div>
          <div class="controls-section">
            <h3>AI Status</h3>
            <div id="statusMessages">
              <p id="strategyStatus">Strategy: Initializing</p>
              <p id="strategyExplanation" class="status-explanation"></p>
              <p id="hamStatus"></p>
              <p id="loopStatus"></p>
              <p id="compactStatus"></p>
              <p id="compactStepStatus"></p>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>
  <!-- Guide Page -->
  <div id="guide-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Parameter Guide</h1>
        <p>Learn to fine-tune the AI for optimal performance</p>
      </div>
      <div class="info-content">
        <div class="info-section">
          <h2>üéØ Quick Guide</h2>
          <p>Each parameter affects how cautious or aggressive the AI is. Start by adjusting <strong>Endgame Threshold</strong>, as it has the biggest impact on whether the snake plays safely or takes risks. Find the balance between speed and safety!</p>
        </div>
        <div class="info-section">
          <h2>üìè Grid Size</h2>
          <h3>Columns &amp; Rows (10-60)</h3>
          <p><strong>What it does:</strong> Determines the game size - number of cells horizontally and vertically.</p>
          <ul>
            <li><strong>Small grids (10x10):</strong> Fast games, AI must be very careful</li>
            <li><strong>Medium (20x20):</strong> Balanced gameplay, standard setting</li>
            <li><strong>Large (30x30):</strong> Long games requiring patience, AI can take more risks</li>
          </ul>
          <p><strong>Tip:</strong> Start with 10x10 to learn the parameters.</p>
        </div>
        <div class="info-section">
          <h2>ü§ñ AI Parameters</h2>
          <!-- Endgame parameter first -->
          <h3>1. Endgame Threshold (5-100+)</h3>
          <p><strong>Why it matters most:</strong> This setting determines when the AI abandons risky fruit-hunting and switches to a safe Hamilton cycle. A lower value means the AI will stay aggressive until there are very few free cells left; a higher value makes it switch earlier.</p>
          <p><strong>What it does:</strong> When the number of free cells remaining drops below this threshold, the AI enters "endgame" mode. In endgame it follows a pre‚Äëbuilt Hamilton cycle to avoid trapping itself and ensure it can eventually fill the board.</p>
          <ul>
            <li><strong>Low value (10-30):</strong> Endgame only at the very end ‚Äì faster but riskier on tight grids</li>
            <li><strong>Medium (40-60):</strong> Safer and suitable for medium grids</li>
            <li><strong>High (70+):</strong> Very cautious ‚Äì ideal for large boards or when you want maximum safety</li>
          </ul>
          <p><strong>When to adjust:</strong> On small grids, keep this low so the AI grabs fruit until the last moments. For bigger boards, increase it so the snake enters endgame earlier and follows a safe route.</p>
          
          <h3>2. Loop Streak Threshold (1-10)</h3>
          <p><strong>What it does:</strong> Number of times the AI can detect a looping pattern before forcing a switch to the safe Hamilton mode. A loop happens when the snake keeps revisiting the same area.</p>
          <ul>
            <li><strong>Low value (1-3):</strong> Quickly switches to safe mode, good for small grids or when loops are deadly</li>
            <li><strong>Medium (4-6):</strong> Balanced, allows some loops</li>
            <li><strong>High (7-10):</strong> Allows many loops, risky but faster on open boards</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase if the snake gets stuck in Hamilton too often. Decrease if it dies while looping.</p>
          
          <h3>3. No Progress Threshold (10-200+)</h3>
          <p><strong>What it does:</strong> Number of moves without getting closer to the fruit before the AI gives up and goes safe. This helps avoid wasting time when fruit is inaccessible.</p>
          <ul>
            <li><strong>Low value (10-50):</strong> Gives up quickly, very safe but slower on large boards</li>
            <li><strong>Medium (50-100):</strong> Standard patience</li>
            <li><strong>High (100+):</strong> Persistent, keeps trying for a long time</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase for larger grids where navigation takes time. Decrease if the snake "wanders" too much without making progress.</p>
          
          <h3>4. Compact Mode Steps (50-300+)</h3>
          <p><strong>What it does:</strong> Maximum number of steps the AI can spend in compact zig‚Äëzag mode when the fruit is trapped in a small pocket. This helps it navigate tight spaces without colliding.</p>
          <ul>
            <li><strong>Low value (50-100):</strong> Short zig‚Äëzag, switches quickly back to other strategies</li>
            <li><strong>Medium (100-200):</strong> Standard length</li>
            <li><strong>High (200+):</strong> Long zig‚Äëzag sequences ‚Äì useful on large boards</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase for larger grids. Decrease if the snake seems to "vibrate" too much in one area.</p>
          <h3>Compact Mode Stil</h3>
          <ul>
            <li><strong>Extremt f√∂rsiktig:</strong> Kr√§ver tr√•nga fickor och upprepade loopar innan zig-zag anv√§nds.</li>
            <li><strong>Balanserad:</strong> Originalbeteendet ‚Äì reagerar p√• fickor eller tydliga loopar.</li>
            <li><strong>Extremt v√•ghalsig:</strong> Hoppar in tidigt f√∂r att reda ut loopar eller sv√•rtillg√§nglig frukt.</li>
          </ul>
          <p><strong>Tips:</strong> V√§lj en f√∂rsiktig stil p√• sm√• br√§den d√§r varje cell r√§knas, och en v√•ghalsig stil p√• stora br√§den f√∂r snabbare √•terh√§mtning.</p>
        </div>
        <div class="info-section">
          <h2>‚ö° Optimization Strategy</h2>
          <h3>For fastest possible game:</h3>
          <ul>
            <li>Loop Threshold: 5-7</li>
            <li>No Progress: 80-120</li>
            <li>Endgame: 5-30</li>
            <li>Compact Steps: 150-200</li>
          </ul>
          <h3>For safest possible game:</h3>
          <ul>
            <li>Loop Threshold: 1-2</li>
            <li>No Progress: 30-50</li>
            <li>Endgame: 60-80</li>
            <li>Compact Steps: 50-100</li>
          </ul>
          <h3>Balanced (recommended):</h3>
          <ul>
            <li>Loop Threshold: 3-4</li>
            <li>No Progress: 50-80</li>
            <li>Endgame: 40-50</li>
            <li>Compact Steps: 100-150</li>
          </ul>
        </div>
        <!-- Detailed algorithm explanations moved from About -->
        <div class="info-section">
          <h2>üîç Algorithm Overview</h2>
          <h3>Hamilton Cycle</h3>
          <p>The Hamilton cycle is a pre‚Äëcomputed path that visits every cell on the board exactly once. Following this path guarantees that the snake never crosses its own body. This path acts as a safety net when other strategies fail or when the board is nearly full. In endgame mode the AI follows the Hamilton cycle to fill the remaining cells without dying.</p>
          <h3>Greedy Pathfinding</h3>
          <p>When there is plenty of open space, the AI uses a greedy approach: it picks moves that reduce the Manhattan distance to the fruit. This allows quick fruit collection. However, greedy movement is only used if it keeps the snake‚Äôs tail reachable. Before each greedy move, the AI checks that it can still eventually reach the tail so it doesn‚Äôt trap itself.</p>
          <h3>Loop Detection</h3>
          <p>If the snake moves in circles without making progress, the AI identifies this as a loop. After a certain number of loops (controlled by the Loop Streak Threshold) it forces a switch to the Hamilton cycle. Breaking loops prevents the snake from wasting time or creating dead ends.</p>
          <h3>Compact Mode</h3>
          <p>When the fruit appears in a confined area or is surrounded by the snake‚Äôs body, the AI enters compact mode. In this mode the snake performs a zig‚Äëzag pattern to efficiently fill small pockets of space and avoid cutting itself off. The maximum steps spent in this mode are controlled by the Compact Mode Steps parameter.</p>
          <h3>Endgame Strategy</h3>
          <p>As the board fills up, the risk of collision increases. Once the number of free cells falls below the endgame threshold, the AI commits to the Hamilton cycle. This ensures the snake can reach every remaining cell and eventually achieve a perfect game.</p>
        </div>
      </div>
    </div>
  </div>
  <!-- Facit Page (Presets) -->
  <div id="facit-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Presets - Proven Combinations</h1>
        <p>Test these optimized settings for different game types</p>
      </div>
     <div class="info-section">
          <h2>üêú Small Grid (10x10)</h2>
          <p><strong>Goal:</strong> Optimized for small, tight spaces</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 10x10</li>
              <li>Loop Threshold: 1</li>
              <li>No Progress: 30</li>
              <li>Endgame: 5</li>
              <li>Compact Steps: 50</li>
              <li>Speed: 120ms</li>
            </ul>
            <button class="button load-preset" data-preset="small">Load this</button>
          </div>
        </div>
        <div class="info-section">
          <h2>‚öñÔ∏è Balanced (20x20)</h2>
          <p><strong>Goal:</strong> Good balance between speed and safety</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 20x20</li>
              <li>Loop Threshold: 3</li>
              <li>No Progress: 70</li>
              <li>Endgame: 40</li>
              <li>Compact Steps: 200</li>
              <li>Speed: 80ms</li>
            </ul>
            <button class="button load-preset" data-preset="balanced">Load this</button>
          </div>
        </div>
        <div class="info-section">
          <h2>üéØ Ultra Challenge (30x30)</h2>
          <p><strong>Goal:</strong> For experts ‚Äì maximum grid with aggressive settings</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 30x30</li>
              <li>Loop Threshold: 5</li>
              <li>No Progress: 150</li>
              <li>Endgame: 80</li>
              <li>Compact Steps: 450</li>
              <li>Speed: 40ms</li>
            </ul>
            <button class="button load-preset" data-preset="ultra">Load this</button>
          </div>
        </div>
        <div class="info-section" style="background: var(--glass); border: 2px solid var(--accent);">
          <h2>üí° Tips for Custom Combinations</h2>
          <ul>
            <li><strong>Start conservatively:</strong> Set low thresholds and increase gradually</li>
            <li><strong>Test in stages:</strong> Run 5-10 games before adjusting</li>
            <li><strong>Document:</strong> Write down what works for different grid sizes</li>
            <li><strong>Experiment:</strong> Try extreme values to understand the effect</li>
            <li><strong>Share:</strong> Send us your best combinations!</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  <!-- Contact Page -->
  <div id="contact-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Contact Me</h1>
        <p>Have questions or feedback?</p>
      </div>
      <div class="contact-content">
        <div class="contact-card">
          <h2>üì¨ Get in Touch</h2>
          <p class="contact-info"></p>
          <a href="mailto:nomarcus@hotmail.com" class="contact-email">‚úâÔ∏è nomarcus@hotmail.com</a>
          <p style="margin-top:2rem;font-size:.9rem;opacity:.7;text-align:center;">
            Last change by <strong>Marcus Petersson</strong> ¬∑ 2025-09-08
          </p>
        </div>
      </div>
    </div>
  </div>
  <!-- Embedded updated JS logic -->
  <script>
    /* ===== KONFIGURATION ===== */
    let COLS = 20, ROWS = 20;
    let CELL = 30;
    let SPEED = 100;
    const DIRS = [ {dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0} ];
    const MAX_SPEED = 500, MIN_SPEED = 1, SPEED_STEP = 10;
    let manualMode = false;
    let manualDirection = {dx: 1, dy: 0};
    let pendingManualDirection = null;
    let eatParticles = [];
    /* ===== DYNAMISKA TR√ñSKLAR ===== */
    // Initialize endgame threshold; dynamic updates will override when grid changes
    let ENDGAME_THRESHOLD = 20;
    let MAX_LOOP_DETECTION = Math.max(8,(COLS+ROWS)/2|0);
    let WINDOW_SIZE = Math.max(10, COLS + ROWS);
    let FILL_POCKET_LIMIT = COLS * 4;
    /* ===== CANVAS ===== */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let lastRender = performance.now();
    /* ===== AI-PARAMETRAR ===== */
    let LOOP_STREAK_THRESHOLD = 1;
    let NO_PROGRESS_THRESHOLD = 70;
    let COMPACT_MODE_MAX_STEPS = 200;
    let COMPACT_MODE_PROFILE = 'balanced';
    const COMPACT_MODE_PROFILES = {
      cautious: {
        label: 'Extremt f√∂rsiktig',
        hint: 'Aktiveras f√∂rst n√§r frukten sitter tr√•ngt och loopen bekr√§ftas.',
        minFreeCells: 8,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: true,
        minLoopStreak: 2,
        allowCrowding: false
      },
      balanced: {
        label: 'Balanserad (nuvarande)',
        hint: 'Originalbeteende ‚Äì reagerar p√• fickor eller detekterade loopar.',
        minFreeCells: 15,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: false,
        minLoopStreak: 1,
        allowCrowding: false
      },
      risky: {
        label: 'Extremt v√•ghalsig',
        hint: 'Hoppar in tidigt √§ven vid antydan till tr√§ngsel eller sv√•r frukt.',
        minFreeCells: 0,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: false,
        minLoopStreak: 0,
        allowCrowding: true
      }
    };
    let loopCountAdjust = 0;
    /* ===== SPELSTATE ===== */
    let snake=[], snakeSet=new Set();
    let fruit, prevFruitDist=Infinity, noProgressMoves=0;
    let lastMoves=[], windowMoves=[], loopDetected=false, loopStreak=0,
        hamMode=false, compactMode=false, compactModeSteps=0,
        loopHandle=null, currentStrategy="Initializing";
    let gameRunning = false;
    const STRATEGY_DESCRIPTIONS = {
      "Initializing": "Setting up a safe opening path before committing to a plan.",
      "Forcing Hamilton (Stagnation)": "Switching to the safety cycle because movement became repetitive.",
      "Forcing Hamilton (No progress)": "Entering the Hamilton cycle after too many moves without reaching fruit.",
      "Forcing Hamilton (Immediate Loop)": "Breaking a dangerous loop by following the Hamilton safety route.",
      "Final Hamilton": "Finishing the board by following the final Hamilton path.",
      "Returning to Hamilton": "Navigating back to the Hamilton cycle to stay safe.",
      "Endgame Hamilton": "Sticking to the Hamilton cycle while space is limited.",
      "Hamilton cycle": "Calmly marching along the Hamilton cycle for guaranteed coverage.",
      "Filling smallest pocket": "Closing a small empty pocket before it becomes a trap.",
      "Loop break (Longest)": "Taking the longest safe option to break a repeating loop.",
      "Greedy to fruit": "Charging directly for the fruit while it looks safe.",
      "Compact zig-zag": "Compressing the body with tight zig-zags to clear space.",
      "BFS to fruit": "Calculating the safest shortest path to the fruit.",
      "BFS to tail": "Using breadth-first search to reconnect with the tail safely.",
      "Heuristic": "Balancing fruit hunting with safety heuristics.",
      "No safe move!": "No safe moves remain ‚Äì preparing for impact."
    };
    function getStrategyExplanation(strategy) {
      return STRATEGY_DESCRIPTIONS[strategy] || "Assessing the board and adapting to the current situation.";
    }
    /* ===== PAGE NAVIGATION ===== */
    const navLinks = document.querySelectorAll('.nav-link');
    const pages = document.querySelectorAll('.page');
    navLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetPage = link.dataset.page;
        navLinks.forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        pages.forEach(p => p.classList.remove('active'));
        document.getElementById(`${targetPage}-page`).classList.add('active');
      });
    });
    const manualToggleBtn = document.getElementById('manualToggle');
    const manualHint = document.getElementById('manualHint');
    const KEY_TO_DIR = {
      'arrowup': {dx: 0, dy: -1},
      'w': {dx: 0, dy: -1},
      'arrowdown': {dx: 0, dy: 1},
      's': {dx: 0, dy: 1},
      'arrowleft': {dx: -1, dy: 0},
      'a': {dx: -1, dy: 0},
      'arrowright': {dx: 1, dy: 0},
      'd': {dx: 1, dy: 0}
    };
    function updateManualUI(){
      if(!manualToggleBtn || !manualHint) return;
      if(manualMode){
        manualToggleBtn.classList.add('toggle-active');
        manualToggleBtn.textContent = 'üß† Return to AI';
        manualHint.textContent = 'Manual mode active! Use arrow keys or WASD to steer the snake.';
      } else {
        manualToggleBtn.classList.remove('toggle-active');
        manualToggleBtn.textContent = 'üïπÔ∏è Try Manual Play';
        manualHint.textContent = 'Manual mode off ‚Äì AI is playing automatically.';
      }
    }
    function setInitialManualDirection(){
      if(snake.length > 1){
        manualDirection = {
          dx: snake[0].x - snake[1].x,
          dy: snake[0].y - snake[1].y
        };
      } else {
        manualDirection = {dx: 1, dy: 0};
      }
      pendingManualDirection = null;
    }
    function setManualDirection(dx, dy){
      const current = pendingManualDirection || manualDirection;
      if(current.dx === -dx && current.dy === -dy) return;
      pendingManualDirection = {dx, dy};
    }
    function toggleManualMode(){
      manualMode = !manualMode;
      if(manualMode){
        setInitialManualDirection();
        currentStrategy = 'Manual control';
      } else {
        pendingManualDirection = null;
      }
      updateManualUI();
    }
    function getManualNext(){
      const direction = pendingManualDirection || manualDirection;
      manualDirection = direction;
      pendingManualDirection = null;
      const head = snake[0];
      const next = {x: head.x + direction.dx, y: head.y + direction.dy};
      currentStrategy = 'Manual control';
      hamMode = false;
      loopDetected = false;
      compactMode = false;
      compactModeSteps = 0;
      return next;
    }
    function spawnEatEffect(cellX, cellY){
      const originX = cellX * CELL + CELL / 2;
      const originY = cellY * CELL + CELL / 2;
      const count = Math.max(14, Math.floor(CELL / 2));
      for(let i = 0; i < count; i++){
        const angle = Math.random() * Math.PI * 2;
        const speed = (Math.random() * 0.6 + 0.2) * CELL / 8;
        const lifetime = 1.2 + Math.random() * 0.6;
        eatParticles.push({
          x: originX,
          y: originY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: lifetime,
          maxLife: lifetime,
          size: CELL * (0.15 + Math.random() * 0.15),
          hue: 200 + Math.random() * 40
        });
      }
    }
    function updateParticles(delta){
      const decay = delta / 1000;
      eatParticles = eatParticles.filter(p => {
        p.life -= decay;
        if(p.life <= 0) return false;
        p.x += p.vx * (delta / (1000 / 60));
        p.y += p.vy * (delta / (1000 / 60));
        p.vx *= 0.98;
        p.vy *= 0.98;
        return true;
      });
    }
    manualToggleBtn?.addEventListener('click', toggleManualMode);
    document.addEventListener('keydown', (event) => {
      if(!manualMode) return;
      const dir = KEY_TO_DIR[event.key.toLowerCase()];
      if(!dir) return;
      setManualDirection(dir.dx, dir.dy);
      event.preventDefault();
    });
    updateManualUI();
    /* ===== SIZE CONTROL ===== */
    const sizeSlider = document.getElementById('sizeSlider');
    sizeSlider.addEventListener('input', (e) => {
      const size = parseInt(e.target.value);
      canvas.width = size;
      canvas.height = size;
      CELL = size / COLS;
      if (gameRunning) draw();
    });
    /* ===== GRID CONTROLS ===== */
    const colsSlider = document.getElementById('colsSlider');
    const rowsSlider = document.getElementById('rowsSlider');
    function updateGridSize(newSize) {
      const targetSize = typeof newSize === 'number' ? newSize : parseInt(colsSlider.value);
      if (Number.isNaN(targetSize)) return;
      const targetValue = String(targetSize);
      if (colsSlider.value !== targetValue) colsSlider.value = targetValue;
      if (rowsSlider.value !== targetValue) rowsSlider.value = targetValue;
      if (targetSize !== COLS || targetSize !== ROWS) {
        COLS = targetSize;
        ROWS = targetSize;
        document.getElementById('colsValue').textContent = COLS;
        document.getElementById('rowsValue').textContent = ROWS;
        CELL = canvas.width / COLS;
        // When not loading a preset, update dynamic thresholds based on grid size
        if (!window.loadingPreset) {
          ENDGAME_THRESHOLD = Math.min(40, Math.floor((COLS * ROWS) * 0.2));
          MAX_LOOP_DETECTION = Math.max(8, (COLS + ROWS) / 2 | 0);
          FILL_POCKET_LIMIT = COLS * 4;
          WINDOW_SIZE = Math.max(10, COLS + ROWS);
          NO_PROGRESS_THRESHOLD = Math.max(30, (COLS * ROWS) / 6);
          COMPACT_MODE_MAX_STEPS = Math.floor((COLS * ROWS) / 2);
          document.getElementById('progThreshValue').textContent = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
          document.getElementById('progThreshSlider').max = Math.max(200, COLS * ROWS);
          document.getElementById('progThreshSlider').value = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactSlider').max = Math.max(300, COLS * ROWS);
          document.getElementById('compactSlider').value = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameSlider').max = Math.max(100, Math.floor((COLS * ROWS) * 0.4));
        }
        restartGame();
      }
    }
    function handleGridInput(event) {
      const value = parseInt(event.target.value);
      if (Number.isNaN(value)) return;
      updateGridSize(value);
    }
    colsSlider.addEventListener('input', handleGridInput);
    rowsSlider.addEventListener('input', handleGridInput);
    /* ===== AI PARAMETER CONTROLS ===== */
    const loopThreshSlider = document.getElementById('loopThreshSlider');
    loopThreshSlider.addEventListener('input', (e) => {
      LOOP_STREAK_THRESHOLD = parseInt(e.target.value);
      document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    });
    const progThreshSlider = document.getElementById('progThreshSlider');
    progThreshSlider.addEventListener('input', (e) => {
      NO_PROGRESS_THRESHOLD = parseInt(e.target.value);
      document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    });
    const endgameSlider = document.getElementById('endgameSlider');
    endgameSlider.addEventListener('input', (e) => {
      ENDGAME_THRESHOLD = parseInt(e.target.value);
      document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    });
    const compactSlider = document.getElementById('compactSlider');
    compactSlider.addEventListener('input', (e) => {
      COMPACT_MODE_MAX_STEPS = parseInt(e.target.value);
      document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
    });
    const compactProfileSelect = document.getElementById('compactProfile');
    const compactProfileHint = document.getElementById('compactProfileHint');
    function updateCompactProfile(profileKey){
      if(!COMPACT_MODE_PROFILES[profileKey]) profileKey = 'balanced';
      COMPACT_MODE_PROFILE = profileKey;
      if(compactProfileSelect && compactProfileSelect.value !== profileKey){
        compactProfileSelect.value = profileKey;
      }
      if(compactProfileHint){
        compactProfileHint.textContent = COMPACT_MODE_PROFILES[profileKey].hint;
      }
    }
    compactProfileSelect?.addEventListener('change', (e) => {
      updateCompactProfile(e.target.value);
    });
    /* ===== RESTART FUNCTION ===== */
    function spawnFruitForState(state){
      const free=[];
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if(!state.snakeSet.has(`${x},${y}`)) free.push({x,y});
        }
      }
      return free.length ? free[(Math.random()*free.length)|0] : {x:-1,y:-1};
    }
    function createFreshState(){
      const state = {
        snake: [],
        snakeSet: new Set(),
        fruit: {x:-1,y:-1},
        prevFruitDist: Infinity,
        noProgressMoves: 0,
        lastMoves: [],
        windowMoves: [],
        loopDetected: false,
        loopStreak: 0,
        hamMode: false,
        compactMode: false,
        compactModeSteps: 0,
        loopCountAdjust: 0,
        currentStrategy: "Initializing"
      };
      const sx = Math.floor(COLS/2), sy = Math.floor(ROWS/2);
      if (COLS >= 5) {
        state.snake.push({x:sx-2,y:sy},{x:sx-1,y:sy},{x:sx,y:sy});
      } else if (COLS >= 3) {
        state.snake.push({x:sx-1,y:sy},{x:sx,y:sy});
      } else {
        state.snake.push({x:sx,y:sy});
      }
      state.snake.reverse();
      state.snakeSet = new Set(state.snake.map(p => `${p.x},${p.y}`));
      state.fruit = spawnFruitForState(state);
      if(state.fruit && state.fruit.x >= 0){
        state.prevFruitDist = Math.abs(state.snake[0].x - state.fruit.x) + Math.abs(state.snake[0].y - state.fruit.y);
      }
      return state;
    }
    function restartGame() {
      const fresh = createFreshState();
      snake = fresh.snake;
      snakeSet = fresh.snakeSet;
      fruit = fresh.fruit;
      prevFruitDist = fresh.prevFruitDist;
      noProgressMoves = fresh.noProgressMoves;
      lastMoves = fresh.lastMoves;
      windowMoves = fresh.windowMoves;
      loopDetected = fresh.loopDetected;
      loopStreak = fresh.loopStreak;
      hamMode = fresh.hamMode;
      compactMode = fresh.compactMode;
      compactModeSteps = fresh.compactModeSteps;
      loopCountAdjust = fresh.loopCountAdjust;
      currentStrategy = fresh.currentStrategy;
      if(manualMode){
        setInitialManualDirection();
        currentStrategy = 'Manual control';
      }
      eatParticles = [];
      lastRender = performance.now();
      HAM = buildHamilton();
      if (loopHandle) clearInterval(loopHandle);
      gameRunning = true;
      draw();
      loopHandle = setInterval(update, SPEED);
    }
    document.getElementById('restartBtn').addEventListener('click', restartGame);
    /* ===== HAMILTON-SLINGA ===== */
    function buildHamilton(){
      const path=[]; let dir=1;
      for(let y=0; y<ROWS; y++){
        if(dir>0){
          for(let x=0; x<COLS; x++) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        } else {
          for(let x=COLS-1; x>=0; x--) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        }
        dir = -dir;
      }
      return path;
    }
    let HAM = buildHamilton();
    const idxOf = p => HAM.findIndex(q=>q.x===p.x&&q.y===p.y);
    const hamNext = p => {const i=idxOf(p); return i<0?null:HAM[(i+1)%HAM.length];};
    /* ===== HJ√ÑLPFUNKTIONER ===== */
    function spawnFruit(){
      const free=[]; for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)
        if(!snakeSet.has(`${x},${y}`)) free.push({x,y});
      return free.length ? free[(Math.random()*free.length)|0] : {x:-1,y:-1};
    }
    function isFruitAccessible(head){
      if(!fruit || fruit.x<0) return false;
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTail=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTail) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    function bfsWithAlternatives(sx,sy,gx,gy,allowTail,preferRandom=false){
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const prev=Array.from({length:ROWS},()=>Array(COLS).fill(null));
      let Q=[{x:sx,y:sy}]; vis[sy][sx]=true;
      while(Q.length){
        if(preferRandom) Q.sort(()=>Math.random()-0.5);
        const {x,y}=Q.shift();
        if(x===gx&&y===gy) break;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=allowTail&&snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; prev[ny][nx]={x,y}; Q.push({x:nx,y:ny});
        }
      }
      if(!vis[gy][gx]) return null;
      const path=[]; for(let cx=gx,cy=gy;!(cx===sx&&cy===sy);){
        path.unshift({x:cx,y:cy}); const p=prev[cy][cx]; if(!p) return null; cx=p.x; cy=p.y;
      }
      return path;
    }
    function canReachTailFrom(head,body){
      if(!body || body.length<2) return true;
      const tail=body[body.length-1];
      if(head.x===tail.x&&head.y===tail.y) return true;
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===tail.x&&y===tail.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          const key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          if(blocked.has(key)&&!(nx===tail.x&&ny===tail.y)) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    const floodSize=(sx,sy,body)=>{
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const startKey=`${sx},${sy}`;
      if(sx<0||sx>=COLS||sy<0||sy>=ROWS||blocked.has(startKey)) return 0;
      const vis=new Set([startKey]); const Q=[{x:sx,y:sy}]; let cnt=1;
      while(Q.length){
        const {x,y}=Q.shift();
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy, key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis.has(key)||blocked.has(key)) continue;
          vis.add(key); cnt++; Q.push({x:nx,y:ny});
        }
      }
      return cnt;
    };
    function getDistancesFromTail(){
      const dmap=Array.from({length:ROWS},()=>Array(COLS).fill(-1));
      if(snake.length<2) return dmap;
      const tail=snake[snake.length-1];
      const Q=[{x:tail.x,y:tail.y,dist:0}]; dmap[tail.y][tail.x]=0;
      const blocked=new Set(snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
      let idx=0; while(idx<Q.length){
        const {x,y,dist}=Q[idx++];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          if(dmap[ny][nx]>=0) continue;
          if(blocked.has(`${nx},${ny}`)) continue;
          dmap[ny][nx]=dist+1; Q.push({x:nx,y:ny,dist:dist+1});
        }
      }
      return dmap;
    };
    function detectLoop(){
      if(lastMoves.length<MAX_LOOP_DETECTION) return false;
      const recent=lastMoves.slice(-MAX_LOOP_DETECTION);
      const unique=new Set(recent.map(p=>`${p.x},${p.y}`)).size;
      return unique<=MAX_LOOP_DETECTION/2;
    }
    function calculateZigZagPath(){
      const head=snake[0];
      let lastDx=0,lastDy=0;
      if(lastMoves.length){
        const ph=lastMoves[lastMoves.length-1]; lastDx=head.x-ph.x; lastDy=head.y-ph.y;
      }
      const moves=[];
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`, isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const ate=fruit&&fruit.x>=0&&nx===fruit.x&&ny===fruit.y;
        const sim=ate?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        let prio=0;
        if((d.dx&&lastDy)||(d.dy&&lastDx)) prio=1;
        else if(d.dx===lastDx&&d.dy===lastDy) prio=2;
        else if(d.dx===-lastDx&&d.dy===-lastDy) prio=-1;
        moves.push({x:nx,y:ny,priority:prio});
      }
      if(!moves.length) return null;
      moves.sort((a,b)=>b.priority-a.priority);
      return {x:moves[0].x,y:moves[0].y};
    }
    function getBackToHamilton(head){
      const currentIdx=idxOf(head);
      if(currentIdx!==-1) return null;
      let best=null, minDist=Infinity;
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`;
        const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        const idx=idxOf({x:nx,y:ny});
        if(idx!==-1){
          const dist=Math.min(Math.abs(idx-currentIdx),HAM.length-Math.abs(idx-currentIdx));
          if(dist<minDist){minDist=dist; best={x:nx,y:ny};}
        }
      }
      return best;
    }
    function isFruitInPocket(){
      if(!fruit||fruit.x<0) return false;
      let blocked=0;
      for(const d of DIRS){
        const nx=fruit.x+d.dx, ny=fruit.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) blocked++;
        else if(snakeSet.has(`${nx},${ny}`)) blocked++;
      }
      const steps=getMinStepsToFruit();
      return blocked>=3 || (blocked>=2 && steps>(COLS+ROWS)/2);
    }
    function shouldEnterCompactMode(context){
      const profile = COMPACT_MODE_PROFILES[COMPACT_MODE_PROFILE] || COMPACT_MODE_PROFILES.balanced;
      if(context.freeCells <= profile.minFreeCells) return false;
      const loopReady = profile.allowLoop && context.loopDetected && context.loopStreak >= profile.minLoopStreak;
      if(profile.allowPocket && context.inPocket){
        if(profile.requirePocketWithLoop && !loopReady) return false;
        return true;
      }
      if(loopReady && !profile.requirePocketWithLoop){
        return true;
      }
      if(profile.allowCrowding && !context.fruitAcc){
        return true;
      }
      return false;
    }
    function fillSmallestPocket(){
      const head=snake[0];
      const freeCells=[], vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const blocked=new Set(snake.map(p=>`${p.x},${p.y}`));
      for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
        if(vis[y][x]||blocked.has(`${x},${y}`)) continue;
        const pocket=[], Q=[{x,y}]; vis[y][x]=true;
        while(Q.length){
          const {x:cx,y:cy}=Q.shift(); pocket.push({x:cx,y:cy});
          for(const d of DIRS){
            const nx=cx+d.dx, ny=cy+d.dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]||blocked.has(`${nx},${ny}`)) continue;
            vis[ny][nx]=true; Q.push({x:nx,y:ny});
          }
        }
        freeCells.push(pocket);
      }
      freeCells.sort((a,b)=>a.length-b.length);
      for(const pocket of freeCells){
        if(!pocket.length) continue;
        const target=pocket[0];
        const path=bfsWithAlternatives(head.x,head.y,target.x,target.y,true,true);
        if(path&&path.length){
          const nxt=path[0];
          const sim=[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)) return nxt;
        }
      }
      return null;
    }
    function getMinStepsToFruit(){
      if(!fruit||fruit.x<0) return Infinity;
      const head=snake[0];
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const dist=Array.from({length:ROWS},()=>Array(COLS).fill(Infinity));
      const Q=[{x:head.x,y:head.y}];
      vis[head.y][head.x]=true; dist[head.y][head.x]=0;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return dist[y][x];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; dist[ny][nx]=dist[y][x]+1; Q.push({x:nx,y:ny});
        }
      }
      return Infinity;
    }
    /* ===== GET NEXT ===== */
    function getNext(){
      HAM = buildHamilton();
      const head=snake[0];
      windowMoves.push(`${head.x},${head.y}`);
      if(windowMoves.length>WINDOW_SIZE) windowMoves.shift();
      lastMoves.push({x:head.x,y:head.y});
      if(lastMoves.length>MAX_LOOP_DETECTION) lastMoves.shift();
      const freeCells=COLS*ROWS - snake.length;
      const isEndgame = freeCells <= (ENDGAME_THRESHOLD + loopCountAdjust);
      if(!hamMode && freeCells > (ENDGAME_THRESHOLD + loopCountAdjust)){
        const uniq=new Set(windowMoves).size;
        if(uniq < WINDOW_SIZE/2){
          hamMode = true; loopStreak = 0; noProgressMoves = 0;
          currentStrategy = "Forcing Hamilton (Stagnation)";
          loopCountAdjust++;
        }
      }
      if(freeCells <= 1){
        const nxt = hamNext(head);
        if(nxt){
          const isTail=snake.length>1 && nxt.x===snake[snake.length-1].x && nxt.y===snake[snake.length-1].y;
          if(!snakeSet.has(`${nxt.x},${nxt.y}`) || isTail){
            currentStrategy = "Final Hamilton";
            return nxt;
          }
        }
      }
      if(isEndgame){
        const back=getBackToHamilton(head);
        if(back){ currentStrategy="Returning to Hamilton"; return back; }
        const nxt=hamNext(head);
        if(nxt){
          const key=`${nxt.x},${nxt.y}`;
          const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
          const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if((!snakeSet.has(key)||isTailStep) && canReachTailFrom(nxt,sim)){
            currentStrategy="Endgame Hamilton"; return nxt;
          }
        }
      }
      if(fruit && fruit.x >= 0){
        const d = Math.abs(head.x - fruit.x) + Math.abs(head.y - fruit.y);
        if(d < prevFruitDist){ prevFruitDist = d; noProgressMoves = 0; }
        else noProgressMoves++;
      } else {
        prevFruitDist = Infinity; noProgressMoves = 0;
      }
      if(!hamMode && noProgressMoves >= NO_PROGRESS_THRESHOLD){
        hamMode = true; loopStreak = 0; noProgressMoves = 0;
        currentStrategy = "Forcing Hamilton (No progress)";
        loopCountAdjust++;
      }
      if(hamMode){
        const nxt = hamNext(head);
        if(nxt){
          const key=`${nxt.x},${nxt.y}`;
          const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
          const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if((!snakeSet.has(key)||isTailStep) && canReachTailFrom(nxt,sim)){
            currentStrategy = "Hamilton cycle";
            return nxt;
          }
        }
        hamMode = false;
      }
      loopDetected = detectLoop();
      loopStreak = loopDetected ? loopStreak + 1 : 0;
      if(loopDetected && !hamMode){
        hamMode = true;
        loopStreak = 0;
        currentStrategy = "Forcing Hamilton (Immediate Loop)";
        loopCountAdjust++;
      }
      if(loopDetected && snake.length >= 2){
        if(freeCells <= FILL_POCKET_LIMIT){
          const fillMove = fillSmallestPocket();
          if(fillMove){ currentStrategy="Filling smallest pocket"; return fillMove; }
        }
        const dmap = getDistancesFromTail();
        let best=null,bestDist=-1;
        for(const d of DIRS){
          const nx=head.x+d.dx, ny=head.y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
          const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
          if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
          const dist=dmap[ny][nx];
          if(dist>bestDist){bestDist=dist; best={x:nx,y:ny};}
        }
        if(best){ currentStrategy="Loop break (Longest)"; return best; }
      }
      const fruitAcc = isFruitAccessible(head);
      if(fruitAcc && freeCells>15){
        let choices=[],minD=Infinity;
        for(const d of DIRS){
          const nx=head.x+d.dx, ny=head.y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
          const nd=Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y);
          if(nd>minD) continue;
          const sim=(nx===fruit.x&&ny===fruit.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
          if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
          if(nd<minD){minD=nd; choices=[{x:nx,y:ny}];}
          else if(nd===minD){choices.push({x:nx,y:ny});}
        }
        if(choices.length){ currentStrategy="Greedy to fruit"; return choices[(Math.random()*choices.length)|0]; }
      }
      const inPocket = isFruitInPocket();
      if(!compactMode && shouldEnterCompactMode({
        inPocket,
        loopDetected,
        loopStreak,
        fruitAcc,
        freeCells
      })){
        compactMode = true; compactModeSteps = 0;
      }
      if(compactMode){
        if(compactModeSteps >= COMPACT_MODE_MAX_STEPS){
          compactMode = false; compactModeSteps = 0;
        } else {
          const zig = calculateZigZagPath();
          if(zig){ compactModeSteps++; currentStrategy="Compact zig-zag"; return zig; }
          else{ compactMode = false; }
        }
      }
      if(fruitAcc && freeCells>1){
        const path=bfsWithAlternatives(head.x,head.y,fruit.x,fruit.y,false,loopDetected);
        if(path && path.length){
          const nxt=path[0];
          const sim=(nxt.x===fruit.x&&nxt.y===fruit.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)){ currentStrategy="BFS to fruit"; return nxt; }
        }
      }
      let bestScore=-Infinity,bestMoves=[];
      const tailPos=snake.length>1?snake[snake.length-1]:null;
      const randomFactor=loopDetected?Math.random()*5:0;
      const avoidFactor=loopDetected?0.5:1;
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
        const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        const freeAfter=floodSize(nx,ny,sim);
        if(freeAfter<COLS*ROWS-sim.length) continue;
        let score=0;
        if(fruit&&fruit.x>=0&&freeCells>Math.max(6, COLS-2)){
          score+=(COLS+ROWS-(Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y)))*2*avoidFactor;
        }
        if(isEndgame && tailPos && nx===tailPos.x && ny===tailPos.y) score+=10000;
        score+=Math.min(nx,ny,COLS-1-nx,ROWS-1-ny);
        score+=randomFactor;
        score+=freeAfter*2;
        if(score>bestScore){ bestScore=score; bestMoves=[{x:nx,y:ny}]; }
        else if(score===bestScore){ bestMoves.push({x:nx,y:ny}); }
      }
      if(bestMoves.length){ currentStrategy="Heuristic"; return bestMoves[(Math.random()*bestMoves.length)|0]; }
      const tail=snake.length>1?snake[snake.length-1]:head;
      const path=bfsWithAlternatives(head.x,head.y,tail.x,tail.y,true,loopDetected);
      if(path && path.length){
        const nxt=path[0];
        const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
        if(canReachTailFrom(nxt,sim)){ currentStrategy="BFS to tail"; return nxt; }
      }
      currentStrategy="No safe move!";
      return null;
    }
    /* ===== RENDER ===== */
    function draw(){
      const now = performance.now();
      updateParticles(now - lastRender);
      lastRender = now;
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#1a1a2e');
      gradient.addColorStop(1, '#0f0f23');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      for(let i = 0; i <= COLS; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL, 0);
        ctx.lineTo(i * CELL, canvas.height);
        ctx.stroke();
      }
      for(let i = 0; i <= ROWS; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * CELL);
        ctx.lineTo(canvas.width, i * CELL);
        ctx.stroke();
      }
      if(fruit && fruit.x >= 0){
        const centerX = fruit.x * CELL + CELL / 2;
        const centerY = fruit.y * CELL + CELL / 2;
        const appleRadius = CELL / 2.6;
        const glowGradient = ctx.createRadialGradient(
          centerX, centerY, 0,
          centerX, centerY, CELL
        );
        glowGradient.addColorStop(0, 'rgba(220, 38, 38, 0.5)');
        glowGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGradient;
        ctx.fillRect(fruit.x * CELL, fruit.y * CELL, CELL, CELL);
        ctx.beginPath();
        ctx.arc(centerX, centerY, appleRadius, 0, 2 * Math.PI);
        ctx.fillStyle = '#d62828';
        ctx.fill();
        ctx.lineWidth = Math.max(2, CELL / 8);
        ctx.strokeStyle = '#111';
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(centerX - appleRadius / 2.2, centerY - appleRadius / 2.2, appleRadius / 4, 0, 2 * Math.PI);
        ctx.fill();
      }
      eatParticles.forEach(p => {
        const alpha = Math.max(0, p.life / p.maxLife);
        const flare = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
        flare.addColorStop(0, `hsla(${p.hue}, 90%, 80%, ${alpha * 0.85})`);
        flare.addColorStop(0.6, `hsla(${p.hue}, 90%, 65%, ${alpha * 0.45})`);
        flare.addColorStop(1, `hsla(${p.hue}, 90%, 40%, 0)`);
        ctx.fillStyle = flare;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      const headColor = hamMode ? '#4ade80' : compactMode ? '#f97316' : loopDetected ? '#fbbf24' : '#667eea';
      snake.forEach((p, i) => {
        const isHead = i === 0;
        const size = CELL * 0.95;
        const offset = (CELL - size) / 2;
        const x = p.x * CELL + offset;
        const y = p.y * CELL + offset;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(x + 2, y + 2, size, size);
        const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
        if(isHead) {
          gradient.addColorStop(0, headColor);
          gradient.addColorStop(1, isHead && hamMode ? '#22c55e' : isHead && compactMode ? '#ea580c' : isHead && loopDetected ? '#f59e0b' : '#764ba2');
        } else {
          const t = i / (snake.length - 1);
          const r = Math.round(102 + (138 - 102) * t);
          const g = Math.round(126 + (75 - 126) * t);
          const b = Math.round(234 + (162 - 234) * t);
          gradient.addColorStop(0, `rgb(${r}, ${g}, ${b})`);
          gradient.addColorStop(1, `rgb(${r - 30}, ${g - 30}, ${b - 30})`);
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, size, size);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(x, y, size, size/3);
        if(isHead) {
          ctx.fillStyle = '#fff';
          let eyeX1, eyeY1, eyeX2, eyeY2;
          if(snake.length > 1){
            const dx = p.x - snake[1].x;
            const dy = p.y - snake[1].y;
            if(dx === 1) {
              eyeX1 = x + size - size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size - size/4;
            } else if(dx === -1) {
              eyeX1 = x + size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size/4;
              eyeY2 = y + size - size/4;
            } else if(dy === 1) {
              eyeX1 = x + size/4;
              eyeY1 = y + size - size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size - size/4;
            } else {
              eyeX1 = x + size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size/4;
            }
            ctx.beginPath(); ctx.arc(eyeX1, eyeY1, size/10, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX2, eyeY2, size/10, 0, 2*Math.PI); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(eyeX1, eyeY1, size/20, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX2, eyeY2, size/20, 0, 2*Math.PI); ctx.fill();
          }
        }
      });
      document.getElementById('strategyStatus').textContent = `Strategy: ${currentStrategy}`;
      document.getElementById('strategyExplanation').textContent = getStrategyExplanation(currentStrategy);
      document.getElementById('hamStatus').textContent = hamMode ? "Following the Hamilton safety cycle." : "";
      document.getElementById('loopStatus').textContent = loopDetected ? `Detected a loop ‚Äì streak ${loopStreak}.` : "";
      document.getElementById('compactStatus').textContent = compactMode ? "Compressing the body to clear space." : "";
      document.getElementById('compactStepStatus').textContent = compactMode ? `Compact path step ${compactModeSteps} of ${COMPACT_MODE_MAX_STEPS}.` : "";
      const freeCellsCount = COLS * ROWS - snake.length;
      document.getElementById('snakeLength').textContent = snake.length;
      document.getElementById('freeCells').textContent = freeCellsCount;
      document.getElementById('progress').textContent = ((snake.length / (COLS * ROWS)) * 100).toFixed(1) + '%';
    }
    /* ===== UPDATE ===== */
    function update(){
      if(!snake.length){ clearInterval(loopHandle); gameRunning = false; return; }
      const nxt = manualMode ? getManualNext() : getNext();
      if(!nxt){
        clearInterval(loopHandle);
        gameRunning = false;
        draw();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(snake.length === COLS * ROWS ? "PERFECT! üéâ" : "Game Over", canvas.width/2, canvas.height/2);
        ctx.font = '20px Inter, sans-serif';
        ctx.fillText(`Final length: ${snake.length}`, canvas.width/2, canvas.height/2 + 40);
        return;
      }
      if(nxt.x < 0 || nxt.x >= COLS || nxt.y < 0 || nxt.y >= ROWS){
        clearInterval(loopHandle);
        gameRunning = false;
        draw();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText("Crash! üí•", canvas.width/2, canvas.height/2);
        return;
      }
      const ate = fruit && fruit.x >= 0 && nxt.x === fruit.x && nxt.y === fruit.y;
      const nextKey = `${nxt.x},${nxt.y}`;
      const tail = snake[snake.length - 1];
      const isTailStep = snake.length > 1 && nxt.x === tail.x && nxt.y === tail.y;
      if(snakeSet.has(nextKey) && !(isTailStep && !ate)){
        clearInterval(loopHandle);
        gameRunning = false;
        draw();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText("Crash! üí•", canvas.width/2, canvas.height/2);
        return;
      }
      const atePosition = ate ? {x: fruit.x, y: fruit.y} : null;
      if(!ate){
        const removed = snake.pop();
        snakeSet.delete(`${removed.x},${removed.y}`);
      }
      snake.unshift({x: nxt.x, y: nxt.y});
      snakeSet.add(`${nxt.x},${nxt.y}`);
      if(ate){
        loopCountAdjust = 0;
        if(snake.length === COLS * ROWS){
          fruit = {x: -1, y: -1};
          draw();
          clearInterval(loopHandle);
          gameRunning = false;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          gradient.addColorStop(0, '#667eea');
          gradient.addColorStop(0.5, '#f093fb');
          gradient.addColorStop(1, '#764ba2');
          ctx.fillStyle = gradient;
          ctx.font = 'bold 48px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText("PERFECT! üèÜ", canvas.width/2, canvas.height/2);
          ctx.fillStyle = '#fff';
          ctx.font = '24px Inter, sans-serif';
          ctx.fillText("You filled the entire board!", canvas.width/2, canvas.height/2 + 50);
          return;
        } else {
          fruit = spawnFruit();
          prevFruitDist = (fruit.x >= 0) ? Math.abs(snake[0].x - fruit.x) + Math.abs(snake[0].y - fruit.y) : Infinity;
          noProgressMoves = 0;
        }
        if(atePosition){
          spawnEatEffect(atePosition.x, atePosition.y);
        }
      }
      draw();
    }
    /* ===== SPEED CONTROLS & STARTUP ===== */
    document.getElementById('slowerBtn').onclick = () => changeSpeed(SPEED + SPEED_STEP);
    document.getElementById('fasterBtn').onclick = () => changeSpeed(SPEED - SPEED_STEP);
    function changeSpeed(v){
      v = Math.max(MIN_SPEED, Math.min(MAX_SPEED, v));
      if(v !== SPEED){
        SPEED = v;
        document.getElementById('speedDisplay').textContent = `Speed: ${SPEED}ms`;
        if(gameRunning) {
          clearInterval(loopHandle);
          loopHandle = setInterval(update, SPEED);
        }
      }
    }
    /* ===== PRESET LOADING ===== */
    const presetButtons = document.querySelectorAll('.load-preset');
    presetButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        // flag to prevent dynamic recalculation when grid size changes
        window.loadingPreset = true;
        if (preset === 'small') {
          colsSlider.value = 10; rowsSlider.value = 10; updateGridSize();
          LOOP_STREAK_THRESHOLD = 1; loopThreshSlider.value = 1; document.getElementById('loopThreshValue').textContent = 1;
          NO_PROGRESS_THRESHOLD = 30; progThreshSlider.value = 30; document.getElementById('progThreshValue').textContent = 30;
          ENDGAME_THRESHOLD = 5; endgameSlider.value = 5; document.getElementById('endgameValue').textContent = 5;
          COMPACT_MODE_MAX_STEPS = 50; compactSlider.value = 50; document.getElementById('compactValue').textContent = 50;
          updateCompactProfile('cautious');
          changeSpeed(120);
        } else if (preset === 'balanced') {
          colsSlider.value = 20; rowsSlider.value = 20; updateGridSize();
          LOOP_STREAK_THRESHOLD = 3; loopThreshSlider.value = 3; document.getElementById('loopThreshValue').textContent = 3;
          NO_PROGRESS_THRESHOLD = 70; progThreshSlider.value = 70; document.getElementById('progThreshValue').textContent = 70;
          ENDGAME_THRESHOLD = 40; endgameSlider.value = 40; document.getElementById('endgameValue').textContent = 40;
          COMPACT_MODE_MAX_STEPS = 200; compactSlider.value = 200; document.getElementById('compactValue').textContent = 200;
          updateCompactProfile('balanced');
          changeSpeed(80);
        } else if (preset === 'ultra') {
          colsSlider.value = 30; rowsSlider.value = 30; updateGridSize();
          LOOP_STREAK_THRESHOLD = 5; loopThreshSlider.value = 5; document.getElementById('loopThreshValue').textContent = 5;
          NO_PROGRESS_THRESHOLD = 150; progThreshSlider.value = 150; document.getElementById('progThreshValue').textContent = 150;
          ENDGAME_THRESHOLD = 80; endgameSlider.value = 80; document.getElementById('endgameValue').textContent = 80;
          COMPACT_MODE_MAX_STEPS = 450; compactSlider.value = 450; document.getElementById('compactValue').textContent = 450;
          updateCompactProfile('risky');
          changeSpeed(40);
        }
        window.loadingPreset = false;
        restartGame();
      });
    });
    // initial start
    restartGame();
    document.getElementById('colsValue').textContent = COLS;
    document.getElementById('rowsValue').textContent = ROWS;
    document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
    updateCompactProfile(COMPACT_MODE_PROFILE);
  </script>
</body>
</html>
