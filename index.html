
<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Simulation - Intelligent Snake Experience</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --accent: #f093fb;
      --success: #4ade80;
      --danger: #ef4444;
      --warning: #fbbf24;
      --dark: #1a1a2e;
      --darker: #0f0f23;
      --light: #eef2ff;
      --text: #e2e8f0;
      --glass: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.2);
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
      min-height: 100vh;
      color: var(--text);
      overflow-x: hidden;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
      opacity: 0.03;
      animation: rotate 60s linear infinite;
      z-index: -1;
    }
    @keyframes rotate {
      to { transform: rotate(360deg); }
    }
    /* Navigation */
    nav {
      background: var(--glass);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--glass-border);
      padding: 1rem 2rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }
    .nav-container {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .logo {
      font-size: 1.8rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .logo::before {
      content: 'üêç';
      font-size: 2rem;
      -webkit-text-fill-color: initial;
    }
    .nav-links {
      display: flex;
      gap: 2rem;
      list-style: none;
    }
    .nav-links a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      transition: all 0.3s;
      position: relative;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
    }
    .nav-links a:hover {
      color: var(--accent);
      background: var(--glass);
    }
    .nav-links a.active {
      color: var(--accent);
      background: var(--glass);
    }
    /* Page transitions */
    .page {
      display: none;
      animation: fadeIn 0.5s ease-in-out;
    }
    .page.active {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* Main container */
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 3rem 2rem;
    }
    /* Hero section */
    .hero {
      text-align: center;
      margin-bottom: 3rem;
    }
    .hero h1 {
      font-size: 3.5rem;
      font-weight: 900;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, var(--light) 0%, var(--accent) 50%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient 3s ease-in-out infinite;
      background-size: 200%;
    }
    @keyframes gradient {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    .hero p {
      font-size: 1.2rem;
      color: var(--text);
      opacity: 0.8;
      max-width: 600px;
      margin: 0 auto;
    }
    /* Game section */
    .game-wrapper {
      display: flex;
      gap: 3rem;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
    }
    .game-container {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 2rem;
      padding: 2rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }
    .game-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, var(--accent), var(--primary), var(--secondary));
      border-radius: 2rem;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .game-container:hover::before {
      opacity: 0.5;
    }
    #game {
      border-radius: 1rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s;
    }
    #game:hover {
      transform: scale(1.02);
    }
    /* Controls panel */
    .controls-panel {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      min-width: 350px;
      max-width: 400px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      max-height: 90vh;
      overflow-y: auto;
    }
    .controls-panel::-webkit-scrollbar {
      width: 8px;
    }
    .controls-panel::-webkit-scrollbar-track {
      background: var(--darker);
      border-radius: 4px;
    }
    .controls-panel::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 4px;
    }
    .controls-section {
      margin-bottom: 2rem;
    }
    .controls-section h3 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .controls-section h3::before {
      content: '‚ö°';
      font-size: 1.5rem;
    }
    /* Modern buttons */
    .button {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      position: relative;
      overflow: hidden;
    }
    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      transition: left 0.5s;
    }
    .button:hover::before {
      left: 100%;
    }
    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    .button:active {
      transform: translateY(0);
    }
    .button.danger {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
    }
    .button.danger:hover {
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.6);
    }
    /* Speed controls */
    .speed-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      justify-content: center;
      margin: 1rem 0;
    }
    .speed-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.2rem;
      padding: 0.8rem 1.2rem;
      min-width: 100px;
    }
    .speed-btn span {
      display: block;
    }
    .speed-display {
      background: var(--darker);
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      min-width: 140px;
      text-align: center;
      font-weight: 600;
      border: 1px solid var(--primary);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
    }
    /* Size controls */
    .size-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin: 1rem 0;
    }
    .size-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 8px;
      background: var(--darker);
      border-radius: 4px;
      outline: none;
      position: relative;
    }
    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
      transition: all 0.3s;
    }
    .size-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
    }
    /* Parameter controls */
    .param-control {
      margin-bottom: 1.5rem;
    }
    .param-control label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--text);
    }
    .param-control label span {
      color: var(--accent);
      font-weight: 700;
      min-width: 40px;
      text-align: right;
    }
    .param-control small {
      display: block;
      margin-top: 0.3rem;
      color: var(--text);
      opacity: 0.6;
      font-size: 0.8rem;
    }
    .param-control .size-slider {
      width: 100%;
    }
    /* Status display */
    .status-display {
      background: var(--darker);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-top: 1rem;
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    .status-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--glass-border);
    }
    .status-item:last-child {
      border-bottom: none;
    }
    .status-label {
      color: var(--text);
      opacity: 0.8;
    }
    .status-value {
      font-weight: 600;
      color: var(--accent);
    }
    /* AI insights panel */
    .ai-intel-box {
      margin-top: 1rem;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid var(--glass-border);
      border-radius: 1.2rem;
      padding: 1.4rem;
      box-shadow: inset 0 0 18px rgba(99, 102, 241, 0.22);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    #statusMessages {
      min-height: 120px;
    }
    #statusMessages p {
      margin: 0.3rem 0;
      font-size: 0.9rem;
      opacity: 0.9;
    }
    .plan-box {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .plan-box h4 {
      font-size: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin: 0;
    }
    .plan-box h4::before {
      content: 'üß†';
    }
    .plan-box p {
      font-size: 0.9rem;
      line-height: 1.6;
      opacity: 0.9;
    }
    #strategyStatus {
      color: var(--accent);
      font-weight: 600;
      font-size: 1rem;
    }
    #hamStatus { color: #38bdf8; }
    #loopStatus { color: #a855f7; }
    #compactStatus { color: #6366f1; }
    /* Info page */
    .info-content {
      max-width: 800px;
      margin: 0 auto;
    }
    .info-section {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .info-section h2 {
      color: var(--accent);
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }
    .info-section h3 {
      color: var(--primary);
      margin: 1.5rem 0 1rem;
    }
    .info-section p, .info-section li {
      line-height: 1.8;
      opacity: 0.9;
    }
    .info-section ul {
      list-style: none;
      padding-left: 0;
    }
    .info-section li {
      position: relative;
      padding-left: 2rem;
      margin-bottom: 0.5rem;
    }
    .info-section li::before {
      content: '‚Üí';
      position: absolute;
      left: 0;
      color: var(--accent);
      font-weight: bold;
    }
    /* Contact page */
    .contact-content {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }
    .contact-card {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 3rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .contact-card h2 {
      color: var(--accent);
      margin-bottom: 2rem;
      font-size: 2rem;
    }
    .contact-info {
      font-size: 1.2rem;
      margin: 2rem 0;
    }
    .contact-email {
      display: inline-block;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 1rem 2rem;
      border-radius: 2rem;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      margin-top: 1rem;
    }
    .contact-email:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    /* Combo preset styling */
    .combo-preset {
      background: var(--darker);
      padding: 1.5rem;
      border-radius: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--primary);
    }
    .combo-preset ul {
      margin-bottom: 1rem;
    }
    .combo-preset li {
      padding-left: 1.5rem;
      font-family: monospace;
      font-size: 1.1rem;
      color: var(--accent);
    }
    .load-preset {
      width: 100%;
      background: linear-gradient(135deg, var(--primary), var(--accent));
    }
    /* Responsive */
    @media (max-width: 768px) {
      .nav-container {
        flex-direction: column;
        gap: 1rem;
      }
      .hero h1 {
        font-size: 2.5rem;
      }
      .game-wrapper {
        flex-direction: column;
      }
      .controls-panel {
        width: 100%;
        max-width: none;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav>
    <div class="nav-container">
      <div class="logo">Snake Simulation</div>
      <ul class="nav-links">
        <li><a href="#" class="nav-link active" data-page="game">Game</a></li>
        <li><a href="#" class="nav-link" data-page="guide">Guide</a></li>
        <li><a href="#" class="nav-link" data-page="facit">Presets</a></li>
        <li><a href="#" class="nav-link" data-page="contact">Contact</a></li>
      </ul>
    </div>
  </nav>
  <!-- Game Page -->
  <div id="game-page" class="page active">
    <div class="container">
      <div class="hero">
        <h1>Snake Simulation</h1>
          <p>Your goal is to find the best adjustments to complete the board</p>
          <p>Adjust Grid size for longer simulations</p>
        <!-- Added hint for players: follow the guide when the snake struggles -->
        <p style="color: var(--warning); opacity: 0.9;">If the snake have bad luck, restart or follow the guide to adjust the parameters for a winning strategy. Or just use the presets</p>
      </div>
      <div class="game-wrapper">
        <div class="game-container">
          <canvas id="game" width="600" height="600"></canvas>
        </div>
        <div class="controls-panel">
          <div class="controls-section">
            <h3>Game Controls</h3>
            <div class="speed-controls">
              <button id="slowerBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">üêå</span>
                <span>Slower</span>
              </button>
              <div id="speedDisplay" class="speed-display">Speed: 100ms</div>
              <button id="fasterBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">‚ö°</span>
                <span>Faster</span>
              </button>
            </div>
            <div style="margin-top: 1rem;">
              <button id="restartBtn" class="button danger" style="width: 100%;">üîÑ Restart</button>
            </div>
          </div>
          <div class="controls-section">
            <h3>Grid Size</h3>
            <div class="param-control">
              <label>Columns (COLS): <span id="colsValue">20</span></label>
              <input type="range" id="colsSlider" class="size-slider" min="10" max="100" value="20" step="10">
            </div>
            <div class="param-control">
              <label>Rows (ROWS): <span id="rowsValue">20</span></label>
              <input type="range" id="rowsSlider" class="size-slider" min="10" max="100" value="20" step="10">
            </div>
            <small style="display: block; margin-top: -0.5rem; color: var(--warning); opacity: 0.8;">
              ‚ö°Changing grid size will restart the game
            </small>
          </div>
          <div class="controls-section">
            <h3>Canvas Size</h3>
            <div class="size-controls">
              <span>Small</span>
              <input type="range" id="sizeSlider" class="size-slider" min="300" max="800" value="400" step="50">
              <span>Large</span>
            </div>
          </div>
          <div class="controls-section">
            <h3>AI Parameters</h3>
            <div class="param-control">
              <label>Endgame Threshold: <span id="endgameValue">20</span></label>
              <input type="range" id="endgameSlider" class="size-slider" min="0" max="100" value="20" step="5">
              <small>Free cells for endgame mode</small>
            </div>
            <div class="param-control">
              <label>Loop Streak Threshold: <span id="loopThreshValue">3</span></label>
              <input type="range" id="loopThreshSlider" class="size-slider" min="1" max="10" value="3" step="1">
              <small>Loops detected before ‚Üí Hamilton mode</small>
            </div>
            <div class="param-control">
              <label>No Progress Threshold: <span id="progThreshValue">70</span></label>
              <input type="range" id="progThreshSlider" class="size-slider" min="10" max="200" value="70" step="5">
              <small>Moves without progress ‚Üí Hamilton mode</small>
            </div>
            <div class="param-control">
              <label>Compact Mode Steps: <span id="compactValue">200</span></label>
              <input type="range" id="compactSlider" class="size-slider" min="0" max="300" value="200" step="10">
              <small>Max steps in compact mode</small>
            </div>
          </div>
          <div class="controls-section">
            <h3>Game Status</h3>
            <div class="status-display">
              <div class="status-item">
                <span class="status-label">Length:</span>
                <span id="snakeLength" class="status-value">3</span>
              </div>
              <div class="status-item">
                <span class="status-label">Free cells:</span>
                <span id="freeCells" class="status-value">222</span>
              </div>
              <div class="status-item">
                <span class="status-label">Progress:</span>
                <span id="progress" class="status-value">1.3%</span>
              </div>
              <div class="status-item">
                <span class="status-label">Run time:</span>
                <span id="runTime" class="status-value">0:00.0</span>
              </div>
              <div class="status-item">
                <span class="status-label">Best time:</span>
                <span id="bestTime" class="status-value">0:00.0</span>
              </div>
            </div>
          </div>
          <div class="controls-section">
            <h3>AI Insights</h3>
            <div class="ai-intel-box">
              <div id="statusMessages">
                <p id="strategyStatus">Strategy: Initializing</p>
                <p id="hamStatus"></p>
                <p id="loopStatus"></p>
                <p id="compactStatus"></p>
                <p id="compactStepStatus"></p>
              </div>
              <div class="plan-box">
                <h4>Current Plan</h4>
                <p id="planDescription">Analyzing the opening move‚Ä¶</p>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>
  <!-- Guide Page -->
  <div id="guide-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Parameter Guide</h1>
        <p>Learn to fine-tune the AI for optimal performance</p>
      </div>
      <div class="info-content">
        <div class="info-section">
          <h2>üéØ Quick Guide</h2>
          <p>Each parameter affects how cautious or aggressive the AI is. Start by adjusting <strong>Endgame Threshold</strong>, as it has the biggest impact on whether the snake plays safely or takes risks. Find the balance between speed and safety!</p>
        </div>
        <div class="info-section">
          <h2>üìè Grid Size</h2>
          <h3>Columns &amp; Rows (10-60)</h3>
          <p><strong>What it does:</strong> Determines the game size - number of cells horizontally and vertically.</p>
          <ul>
            <li><strong>Small grids (10x10):</strong> Fast games, AI must be very careful</li>
            <li><strong>Medium (20x20):</strong> Balanced gameplay, standard setting</li>
            <li><strong>Large (30x30):</strong> Long games requiring patience, AI can take more risks</li>
          </ul>
          <p><strong>Tip:</strong> Start with 10x10 to learn the parameters.</p>
        </div>
        <div class="info-section">
          <h2>ü§ñ AI Parameters</h2>
          <!-- Endgame parameter first -->
          <h3>1. Endgame Threshold (5-100+)</h3>
          <p><strong>Why it matters most:</strong> This setting determines when the AI abandons risky fruit-hunting and switches to a safe Hamilton cycle. A lower value means the AI will stay aggressive until there are very few free cells left; a higher value makes it switch earlier.</p>
          <p><strong>What it does:</strong> When the number of free cells remaining drops below this threshold, the AI enters "endgame" mode. In endgame it follows a pre‚Äëbuilt Hamilton cycle to avoid trapping itself and ensure it can eventually fill the board.</p>
          <ul>
            <li><strong>Low value (10-30):</strong> Endgame only at the very end ‚Äì faster but riskier on tight grids</li>
            <li><strong>Medium (40-60):</strong> Safer and suitable for medium grids</li>
            <li><strong>High (70+):</strong> Very cautious ‚Äì ideal for large boards or when you want maximum safety</li>
          </ul>
          <p><strong>When to adjust:</strong> On small grids, keep this low so the AI grabs fruit until the last moments. For bigger boards, increase it so the snake enters endgame earlier and follows a safe route.</p>
          
          <h3>2. Loop Streak Threshold (1-10)</h3>
          <p><strong>What it does:</strong> Number of times the AI can detect a looping pattern before forcing a switch to the safe Hamilton mode. A loop happens when the snake keeps revisiting the same area.</p>
          <ul>
            <li><strong>Low value (1-3):</strong> Quickly switches to safe mode, good for small grids or when loops are deadly</li>
            <li><strong>Medium (4-6):</strong> Balanced, allows some loops</li>
            <li><strong>High (7-10):</strong> Allows many loops, risky but faster on open boards</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase if the snake gets stuck in Hamilton too often. Decrease if it dies while looping.</p>
          
          <h3>3. No Progress Threshold (10-200+)</h3>
          <p><strong>What it does:</strong> Number of moves without getting closer to the fruit before the AI gives up and goes safe. This helps avoid wasting time when fruit is inaccessible.</p>
          <ul>
            <li><strong>Low value (10-50):</strong> Gives up quickly, very safe but slower on large boards</li>
            <li><strong>Medium (50-100):</strong> Standard patience</li>
            <li><strong>High (100+):</strong> Persistent, keeps trying for a long time</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase for larger grids where navigation takes time. Decrease if the snake "wanders" too much without making progress.</p>
          
          <h3>4. Compact Mode Steps (50-300+)</h3>
          <p><strong>What it does:</strong> Maximum number of steps the AI can spend in compact zig‚Äëzag mode when the fruit is trapped in a small pocket. This helps it navigate tight spaces without colliding.</p>
          <ul>
            <li><strong>Low value (50-100):</strong> Short zig‚Äëzag, switches quickly back to other strategies</li>
            <li><strong>Medium (100-200):</strong> Standard length</li>
            <li><strong>High (200+):</strong> Long zig‚Äëzag sequences ‚Äì useful on large boards</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase for larger grids. Decrease if the snake seems to "vibrate" too much in one area.</p>
        </div>
        <div class="info-section">
          <h2>‚ö° Optimization Strategy</h2>
          <h3>For fastest possible game:</h3>
          <ul>
            <li>Loop Threshold: 5-7</li>
            <li>No Progress: 80-120</li>
            <li>Endgame: 5-30</li>
            <li>Compact Steps: 150-200</li>
          </ul>
          <h3>For safest possible game:</h3>
          <ul>
            <li>Loop Threshold: 1-2</li>
            <li>No Progress: 30-50</li>
            <li>Endgame: 60-80</li>
            <li>Compact Steps: 50-100</li>
          </ul>
          <h3>Balanced (recommended):</h3>
          <ul>
            <li>Loop Threshold: 3-4</li>
            <li>No Progress: 50-80</li>
            <li>Endgame: 40-50</li>
            <li>Compact Steps: 100-150</li>
          </ul>
        </div>
        <!-- Detailed algorithm explanations moved from About -->
        <div class="info-section">
          <h2>üîç Algorithm Overview</h2>
          <h3>Hamilton Cycle</h3>
          <p>The Hamilton cycle is a pre‚Äëcomputed path that visits every cell on the board exactly once. Following this path guarantees that the snake never crosses its own body. This path acts as a safety net when other strategies fail or when the board is nearly full. In endgame mode the AI follows the Hamilton cycle to fill the remaining cells without dying.</p>
          <h3>Greedy Pathfinding</h3>
          <p>When there is plenty of open space, the AI uses a greedy approach: it picks moves that reduce the Manhattan distance to the fruit. This allows quick fruit collection. However, greedy movement is only used if it keeps the snake‚Äôs tail reachable. Before each greedy move, the AI checks that it can still eventually reach the tail so it doesn‚Äôt trap itself.</p>
          <h3>Loop Detection</h3>
          <p>If the snake moves in circles without making progress, the AI identifies this as a loop. After a certain number of loops (controlled by the Loop Streak Threshold) it forces a switch to the Hamilton cycle. Breaking loops prevents the snake from wasting time or creating dead ends.</p>
          <h3>Compact Mode</h3>
          <p>When the fruit appears in a confined area or is surrounded by the snake‚Äôs body, the AI enters compact mode. In this mode the snake performs a zig‚Äëzag pattern to efficiently fill small pockets of space and avoid cutting itself off. The maximum steps spent in this mode are controlled by the Compact Mode Steps parameter.</p>
          <h3>Endgame Strategy</h3>
          <p>As the board fills up, the risk of collision increases. Once the number of free cells falls below the endgame threshold, the AI commits to the Hamilton cycle. This ensures the snake can reach every remaining cell and eventually achieve a perfect game.</p>
        </div>
      </div>
    </div>
  </div>
  <!-- Facit Page (Presets) -->
  <div id="facit-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Presets - Proven Combinations</h1>
        <p>Test these optimized settings for different game types</p>
      </div>
     <div class="info-section">
          <h2>üêú Small Grid (10x10)</h2>
          <p><strong>Goal:</strong> Optimized for small, tight spaces</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 10x10</li>
              <li>Loop Threshold: 1</li>
              <li>No Progress: 30</li>
              <li>Endgame: 5</li>
              <li>Compact Steps: 50</li>
              <li>Speed: 120ms</li>
            </ul>
            <button class="button load-preset" data-preset="small">Load this</button>
          </div>
        </div>
        <div class="info-section">
          <h2>‚öñÔ∏è Balanced (20x20)</h2>
          <p><strong>Goal:</strong> Good balance between speed and safety</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 20x20</li>
              <li>Loop Threshold: 3</li>
              <li>No Progress: 70</li>
              <li>Endgame: 40</li>
              <li>Compact Steps: 200</li>
              <li>Speed: 80ms</li>
            </ul>
            <button class="button load-preset" data-preset="balanced">Load this</button>
          </div>
        </div>
        <div class="info-section">
          <h2>üéØ Ultra Challenge (30x30)</h2>
          <p><strong>Goal:</strong> For experts ‚Äì maximum grid with aggressive settings</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 30x30</li>
              <li>Loop Threshold: 5</li>
              <li>No Progress: 150</li>
              <li>Endgame: 80</li>
              <li>Compact Steps: 450</li>
              <li>Speed: 40ms</li>
            </ul>
            <button class="button load-preset" data-preset="ultra">Load this</button>
          </div>
        </div>
        <div class="info-section" style="background: var(--glass); border: 2px solid var(--accent);">
          <h2>üí° Tips for Custom Combinations</h2>
          <ul>
            <li><strong>Start conservatively:</strong> Set low thresholds and increase gradually</li>
            <li><strong>Test in stages:</strong> Run 5-10 games before adjusting</li>
            <li><strong>Document:</strong> Write down what works for different grid sizes</li>
            <li><strong>Experiment:</strong> Try extreme values to understand the effect</li>
            <li><strong>Share:</strong> Send us your best combinations!</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  <!-- Contact Page -->
  <div id="contact-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Contact Me</h1>
        <p>Have questions or feedback?</p>
      </div>
      <div class="contact-content">
        <div class="contact-card">
          <h2>üì¨ Get in Touch</h2>
          <p class="contact-info"></p>
          <a href="mailto:nomarcus@hotmail.com" class="contact-email">‚úâÔ∏è nomarcus@hotmail.com</a>
          <p style="margin-top:2rem;font-size:.9rem;opacity:.7;text-align:center;">
            Last change by <strong>Marcus Petersson</strong> ¬∑ 2025-09-08
          </p>
        </div>
      </div>
    </div>
  </div>
  <!-- Embedded updated JS logic -->
  <script>
    /* ===== KONFIGURATION ===== */
    let COLS = 20, ROWS = 20;
    let CELL = 30;
    let SPEED = 100;
    const DIRS = [ {dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0} ];
    const MAX_SPEED = 500, MIN_SPEED = 1, SPEED_STEP = 10;
    /* ===== DYNAMISKA TR√ñSKLAR ===== */
    // Initialize endgame threshold; dynamic updates will override when grid changes
    let ENDGAME_THRESHOLD = 20;
    let MAX_LOOP_DETECTION = Math.max(8,(COLS+ROWS)/2|0);
    let WINDOW_SIZE = Math.max(10, COLS + ROWS);
    let FILL_POCKET_LIMIT = COLS * 4;
    /* ===== CANVAS ===== */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    function hexToRgb(hex) {
      const clean = hex.replace('#', '');
      const bigint = parseInt(clean, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    }
    function clampChannel(value) {
      return Math.min(255, Math.max(0, Math.round(value)));
    }
    function lerpChannel(a, b, t) {
      return a + (b - a) * t;
    }
    function lerpRgb(a, b, t) {
      return {
        r: clampChannel(lerpChannel(a.r, b.r, t)),
        g: clampChannel(lerpChannel(a.g, b.g, t)),
        b: clampChannel(lerpChannel(a.b, b.b, t))
      };
    }
    function adjustRgb(rgb, factor) {
      return {
        r: clampChannel(rgb.r * factor),
        g: clampChannel(rgb.g * factor),
        b: clampChannel(rgb.b * factor)
      };
    }
    function rgbToCss(rgb, alpha = 1) {
      return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
    }
    const bodyPalette = [
      { pos: 0, rgb: hexToRgb('#60a5fa') },
      { pos: 0.5, rgb: hexToRgb('#6366f1') },
      { pos: 1, rgb: hexToRgb('#312e81') }
    ];
    function mixBodyColor(t) {
      if (!bodyPalette.length) return { r: 255, g: 255, b: 255 };
      const clamped = Math.min(Math.max(t, 0), 1);
      for (let i = 0; i < bodyPalette.length - 1; i++) {
        const a = bodyPalette[i];
        const b = bodyPalette[i + 1];
        if (clamped <= b.pos) {
          const span = b.pos - a.pos;
          const localT = span === 0 ? 0 : (clamped - a.pos) / span;
          return lerpRgb(a.rgb, b.rgb, localT);
        }
      }
      return bodyPalette[bodyPalette.length - 1].rgb;
    }
    /* ===== AI-PARAMETRAR ===== */
    let LOOP_STREAK_THRESHOLD = 1;
    let NO_PROGRESS_THRESHOLD = 70;
    let COMPACT_MODE_MAX_STEPS = 200;
    let loopCountAdjust = 0;
    /* ===== SPELSTATE ===== */
    let snake=[], snakeSet=new Set();
    let fruit, prevFruitDist=Infinity, noProgressMoves=0;
    let lastMoves=[], windowMoves=[], loopDetected=false, loopStreak=0,
        hamMode=false, compactMode=false, compactModeSteps=0,
        loopHandle=null, currentStrategy="Initializing";
    let gameRunning = false;
    let runStartTime = null;
    let lastElapsedMs = 0;
    const BEST_TIME_KEY = 'snake_ai_best_time_ms';
    let bestTimeMs = 0;
    const smackBursts = [];
    try {
      const storedBest = localStorage.getItem(BEST_TIME_KEY);
      if (storedBest) {
        const parsed = parseInt(storedBest, 10);
        if (!Number.isNaN(parsed)) bestTimeMs = parsed;
      }
    } catch (error) {
      bestTimeMs = 0;
    }
    /* ===== PAGE NAVIGATION ===== */
    const navLinks = document.querySelectorAll('.nav-link');
    const pages = document.querySelectorAll('.page');
    const runTimeDisplay = document.getElementById('runTime');
    const bestTimeDisplay = document.getElementById('bestTime');
    const planDescriptionEl = document.getElementById('planDescription');
    const planNarratives = {
      'Initializing': 'Calibrating sensors and mapping the board.',
      'Greedy to fruit': 'Sliding toward the fruit along the quickest safe path.',
      'BFS to fruit': 'Plotting a guaranteed BFS path straight to the fruit.',
      'BFS to tail': 'Tracing a BFS route toward the tail to reopen space.',
      'Loop break (Longest)': 'Taking a longer detour to break out of a loop.',
      'Filling smallest pocket': 'Filling a tiny pocket before it becomes a trap.',
      'Compact zig-zag': 'Zig-zagging tightly to drain a cramped corridor.',
      'Heuristic': 'Balancing risk and reward with a heuristic move.',
      'Hamilton cycle': 'Cruising along the Hamilton loop for maximum safety.',
      'Returning to Hamilton': 'Navigating back to the safe Hamilton loop.',
      'Final Hamilton': 'Finishing the run on the Hamilton loop for a perfect sweep.',
      'Endgame Hamilton': 'Locking in the win by following the Hamilton loop precisely.',
      'No safe move!': 'Scanning frantically for any last-second lifeline.'
    };
    function formatDuration(ms){
      if (!ms || ms < 0) return '0:00.0';
      const totalSeconds = ms / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const tenths = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 10);
      return `${minutes}:${seconds.toString().padStart(2, '0')}.${tenths}`;
    }
    function updateTimerDisplays(){
      if(runTimeDisplay) runTimeDisplay.textContent = formatDuration(lastElapsedMs);
      if(bestTimeDisplay) bestTimeDisplay.textContent = formatDuration(bestTimeMs);
    }
    function persistBestTime(){
      try {
        if (typeof localStorage !== 'undefined') {
          localStorage.setItem(BEST_TIME_KEY, String(Math.floor(bestTimeMs)));
        }
      } catch (error) {
        /* ignore storage failures */
      }
    }
    function registerBestTime(){
      if(lastElapsedMs > bestTimeMs){
        bestTimeMs = lastElapsedMs;
        persistBestTime();
      }
      updateTimerDisplays();
    }
    function describeCurrentPlan(){
      if(!snake.length) {
        return 'The snake is waiting for a fresh start.';
      }
      if(!gameRunning) {
        return 'The game is paused‚Äîrestart to see the next move.';
      }
      if(compactMode) {
        return 'Compressing tightly to free the fruit inside a cramped pocket.';
      }
      if(hamMode) {
        if(currentStrategy.includes('Final') || currentStrategy.includes('Endgame')) {
          return 'Following its Hamilton loop all the way to the finish.';
        }
        return 'Staying on the Hamilton loop to keep every move safe.';
      }
      if(currentStrategy.includes('Forcing Hamilton')) {
        return 'Breaking the pattern and jumping onto the Hamilton loop for extra safety.';
      }
      if(loopDetected) {
        return 'Detected a loop and plotting a detour to break free.';
      }
      const narrative = planNarratives[currentStrategy];
      if(narrative) {
        return narrative;
      }
      return 'Assessing the space and choosing the next safe step toward the fruit.';
    }
    function finalizeRunTimer(){
      if(runStartTime){
        lastElapsedMs = performance.now() - runStartTime;
        runStartTime = null;
      }
      registerBestTime();
    }
    updateTimerDisplays();
    function roundedRectPath(context, x, y, width, height, radius){
      const r = Math.min(radius, width / 2, height / 2);
      context.beginPath();
      context.moveTo(x + r, y);
      context.lineTo(x + width - r, y);
      context.quadraticCurveTo(x + width, y, x + width, y + r);
      context.lineTo(x + width, y + height - r);
      context.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
      context.lineTo(x + r, y + height);
      context.quadraticCurveTo(x, y + height, x, y + height - r);
      context.lineTo(x, y + r);
      context.quadraticCurveTo(x, y, x + r, y);
      context.closePath();
    }
    function fillRoundedRect(x, y, width, height, radius, fillStyle, shadowColor, shadowBlur){
      ctx.save();
      ctx.fillStyle = fillStyle;
      ctx.shadowColor = shadowColor;
      ctx.shadowBlur = shadowBlur;
      roundedRectPath(ctx, x, y, width, height, radius);
      ctx.fill();
      ctx.restore();
    }
    navLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetPage = link.dataset.page;
        navLinks.forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        pages.forEach(p => p.classList.remove('active'));
        document.getElementById(`${targetPage}-page`).classList.add('active');
      });
    });
    /* ===== SIZE CONTROL ===== */
    const sizeSlider = document.getElementById('sizeSlider');
    sizeSlider.addEventListener('input', (e) => {
      const size = parseInt(e.target.value);
      canvas.width = size;
      canvas.height = size;
      CELL = size / COLS;
      if (gameRunning) draw();
    });
    /* ===== GRID CONTROLS ===== */
    const colsSlider = document.getElementById('colsSlider');
    const rowsSlider = document.getElementById('rowsSlider');
    function updateGridSize(event) {
      if (event?.target === colsSlider) {
        rowsSlider.value = colsSlider.value;
      } else if (event?.target === rowsSlider) {
        colsSlider.value = rowsSlider.value;
      }
      const newSize = parseInt(colsSlider.value, 10);
      if (Number.isNaN(newSize)) {
        return;
      }
      rowsSlider.value = String(newSize);
      colsSlider.value = String(newSize);
      const newCols = newSize;
      const newRows = newSize;
      if (newCols !== COLS || newRows !== ROWS) {
        COLS = newCols;
        ROWS = newRows;
        document.getElementById('colsValue').textContent = COLS;
        document.getElementById('rowsValue').textContent = ROWS;
        CELL = canvas.width / COLS;
        // When not loading a preset, update dynamic thresholds based on grid size
        if (!window.loadingPreset) {
          ENDGAME_THRESHOLD = Math.min(40, Math.floor((COLS * ROWS) * 0.2));
          MAX_LOOP_DETECTION = Math.max(8, (COLS + ROWS) / 2 | 0);
          FILL_POCKET_LIMIT = COLS * 4;
          WINDOW_SIZE = Math.max(10, COLS + ROWS);
          NO_PROGRESS_THRESHOLD = Math.max(30, (COLS * ROWS) / 6);
          COMPACT_MODE_MAX_STEPS = Math.floor((COLS * ROWS) / 2);
          document.getElementById('progThreshValue').textContent = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
          document.getElementById('progThreshSlider').max = Math.max(200, COLS * ROWS);
          document.getElementById('progThreshSlider').value = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactSlider').max = Math.max(300, COLS * ROWS);
          document.getElementById('compactSlider').value = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameSlider').max = Math.max(100, Math.floor((COLS * ROWS) * 0.4));
        }
        restartGame();
      }
    }
    colsSlider.addEventListener('input', updateGridSize);
    rowsSlider.addEventListener('input', updateGridSize);
    /* ===== AI PARAMETER CONTROLS ===== */
    const loopThreshSlider = document.getElementById('loopThreshSlider');
    loopThreshSlider.addEventListener('input', (e) => {
      LOOP_STREAK_THRESHOLD = parseInt(e.target.value);
      document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    });
    const progThreshSlider = document.getElementById('progThreshSlider');
    progThreshSlider.addEventListener('input', (e) => {
      NO_PROGRESS_THRESHOLD = parseInt(e.target.value);
      document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    });
    const endgameSlider = document.getElementById('endgameSlider');
    endgameSlider.addEventListener('input', (e) => {
      ENDGAME_THRESHOLD = parseInt(e.target.value);
      document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    });
    const compactSlider = document.getElementById('compactSlider');
    compactSlider.addEventListener('input', (e) => {
      COMPACT_MODE_MAX_STEPS = parseInt(e.target.value);
      document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
    });
    /* ===== RESTART FUNCTION ===== */
    function spawnFruitForState(state){
      const free=[];
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if(!state.snakeSet.has(`${x},${y}`)) free.push({x,y});
        }
      }
      return free.length ? free[(Math.random()*free.length)|0] : {x:-1,y:-1};
    }
    function createFreshState(){
      const state = {
        snake: [],
        snakeSet: new Set(),
        fruit: {x:-1,y:-1},
        prevFruitDist: Infinity,
        noProgressMoves: 0,
        lastMoves: [],
        windowMoves: [],
        loopDetected: false,
        loopStreak: 0,
        hamMode: false,
        compactMode: false,
        compactModeSteps: 0,
        loopCountAdjust: 0,
        currentStrategy: "Initializing"
      };
      const sx = Math.floor(COLS/2), sy = Math.floor(ROWS/2);
      if (COLS >= 5) {
        state.snake.push({x:sx-2,y:sy},{x:sx-1,y:sy},{x:sx,y:sy});
      } else if (COLS >= 3) {
        state.snake.push({x:sx-1,y:sy},{x:sx,y:sy});
      } else {
        state.snake.push({x:sx,y:sy});
      }
      state.snake.reverse();
      state.snakeSet = new Set(state.snake.map(p => `${p.x},${p.y}`));
      state.fruit = spawnFruitForState(state);
      if(state.fruit && state.fruit.x >= 0){
        state.prevFruitDist = Math.abs(state.snake[0].x - state.fruit.x) + Math.abs(state.snake[0].y - state.fruit.y);
      }
      return state;
    }
    function restartGame() {
      const fresh = createFreshState();
      smackBursts.length = 0;
      snake = fresh.snake;
      snakeSet = fresh.snakeSet;
      fruit = fresh.fruit;
      prevFruitDist = fresh.prevFruitDist;
      noProgressMoves = fresh.noProgressMoves;
      lastMoves = fresh.lastMoves;
      windowMoves = fresh.windowMoves;
      loopDetected = fresh.loopDetected;
      loopStreak = fresh.loopStreak;
      hamMode = fresh.hamMode;
      compactMode = fresh.compactMode;
      compactModeSteps = fresh.compactModeSteps;
      loopCountAdjust = fresh.loopCountAdjust;
      currentStrategy = fresh.currentStrategy;
      HAM = buildHamilton();
      if (loopHandle) clearInterval(loopHandle);
      gameRunning = true;
      runStartTime = performance.now();
      lastElapsedMs = 0;
      updateTimerDisplays();
      draw();
      loopHandle = setInterval(update, SPEED);
    }
    document.getElementById('restartBtn').addEventListener('click', restartGame);
    /* ===== HAMILTON-SLINGA ===== */
    function buildHamilton(){
      const path=[]; let dir=1;
      for(let y=0; y<ROWS; y++){
        if(dir>0){
          for(let x=0; x<COLS; x++) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        } else {
          for(let x=COLS-1; x>=0; x--) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        }
        dir = -dir;
      }
      return path;
    }
    let HAM = buildHamilton();
    const idxOf = p => HAM.findIndex(q=>q.x===p.x&&q.y===p.y);
    const hamNext = p => {const i=idxOf(p); return i<0?null:HAM[(i+1)%HAM.length];};
    /* ===== HJ√ÑLPFUNKTIONER ===== */
    function spawnFruit(){
      const free=[]; for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)
        if(!snakeSet.has(`${x},${y}`)) free.push({x,y});
      return free.length ? free[(Math.random()*free.length)|0] : {x:-1,y:-1};
    }
    function isFruitAccessible(head){
      if(!fruit || fruit.x<0) return false;
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTail=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTail) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    function bfsWithAlternatives(sx,sy,gx,gy,allowTail,preferRandom=false){
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const prev=Array.from({length:ROWS},()=>Array(COLS).fill(null));
      let Q=[{x:sx,y:sy}]; vis[sy][sx]=true;
      while(Q.length){
        if(preferRandom) Q.sort(()=>Math.random()-0.5);
        const {x,y}=Q.shift();
        if(x===gx&&y===gy) break;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=allowTail&&snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; prev[ny][nx]={x,y}; Q.push({x:nx,y:ny});
        }
      }
      if(!vis[gy][gx]) return null;
      const path=[]; for(let cx=gx,cy=gy;!(cx===sx&&cy===sy);){
        path.unshift({x:cx,y:cy}); const p=prev[cy][cx]; if(!p) return null; cx=p.x; cy=p.y;
      }
      return path;
    }
    function canReachTailFrom(head,body){
      if(!body || body.length<2) return true;
      const tail=body[body.length-1];
      if(head.x===tail.x&&head.y===tail.y) return true;
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===tail.x&&y===tail.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          const key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          if(blocked.has(key)&&!(nx===tail.x&&ny===tail.y)) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    const floodSize=(sx,sy,body)=>{
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const startKey=`${sx},${sy}`;
      if(sx<0||sx>=COLS||sy<0||sy>=ROWS||blocked.has(startKey)) return 0;
      const vis=new Set([startKey]); const Q=[{x:sx,y:sy}]; let cnt=1;
      while(Q.length){
        const {x,y}=Q.shift();
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy, key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis.has(key)||blocked.has(key)) continue;
          vis.add(key); cnt++; Q.push({x:nx,y:ny});
        }
      }
      return cnt;
    };
    function getDistancesFromTail(){
      const dmap=Array.from({length:ROWS},()=>Array(COLS).fill(-1));
      if(snake.length<2) return dmap;
      const tail=snake[snake.length-1];
      const Q=[{x:tail.x,y:tail.y,dist:0}]; dmap[tail.y][tail.x]=0;
      const blocked=new Set(snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
      let idx=0; while(idx<Q.length){
        const {x,y,dist}=Q[idx++];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          if(dmap[ny][nx]>=0) continue;
          if(blocked.has(`${nx},${ny}`)) continue;
          dmap[ny][nx]=dist+1; Q.push({x:nx,y:ny,dist:dist+1});
        }
      }
      return dmap;
    };
    function detectLoop(){
      if(lastMoves.length<MAX_LOOP_DETECTION) return false;
      const recent=lastMoves.slice(-MAX_LOOP_DETECTION);
      const unique=new Set(recent.map(p=>`${p.x},${p.y}`)).size;
      return unique<=MAX_LOOP_DETECTION/2;
    }
    function calculateZigZagPath(){
      const head=snake[0];
      let lastDx=0,lastDy=0;
      if(lastMoves.length){
        const ph=lastMoves[lastMoves.length-1]; lastDx=head.x-ph.x; lastDy=head.y-ph.y;
      }
      const moves=[];
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`, isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const ate=fruit&&fruit.x>=0&&nx===fruit.x&&ny===fruit.y;
        const sim=ate?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        let prio=0;
        if((d.dx&&lastDy)||(d.dy&&lastDx)) prio=1;
        else if(d.dx===lastDx&&d.dy===lastDy) prio=2;
        else if(d.dx===-lastDx&&d.dy===-lastDy) prio=-1;
        moves.push({x:nx,y:ny,priority:prio});
      }
      if(!moves.length) return null;
      moves.sort((a,b)=>b.priority-a.priority);
      return {x:moves[0].x,y:moves[0].y};
    }
    function getBackToHamilton(head){
      const currentIdx=idxOf(head);
      if(currentIdx!==-1) return null;
      let best=null, minDist=Infinity;
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`;
        const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        const idx=idxOf({x:nx,y:ny});
        if(idx!==-1){
          const dist=Math.min(Math.abs(idx-currentIdx),HAM.length-Math.abs(idx-currentIdx));
          if(dist<minDist){minDist=dist; best={x:nx,y:ny};}
        }
      }
      return best;
    }
    function isFruitInPocket(){
      if(!fruit||fruit.x<0) return false;
      let blocked=0;
      for(const d of DIRS){
        const nx=fruit.x+d.dx, ny=fruit.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) blocked++;
        else if(snakeSet.has(`${nx},${ny}`)) blocked++;
      }
      const steps=getMinStepsToFruit();
      return blocked>=3 || (blocked>=2 && steps>(COLS+ROWS)/2);
    }
    function fillSmallestPocket(){
      const head=snake[0];
      const freeCells=[], vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const blocked=new Set(snake.map(p=>`${p.x},${p.y}`));
      for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
        if(vis[y][x]||blocked.has(`${x},${y}`)) continue;
        const pocket=[], Q=[{x,y}]; vis[y][x]=true;
        while(Q.length){
          const {x:cx,y:cy}=Q.shift(); pocket.push({x:cx,y:cy});
          for(const d of DIRS){
            const nx=cx+d.dx, ny=cy+d.dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]||blocked.has(`${nx},${ny}`)) continue;
            vis[ny][nx]=true; Q.push({x:nx,y:ny});
          }
        }
        freeCells.push(pocket);
      }
      freeCells.sort((a,b)=>a.length-b.length);
      for(const pocket of freeCells){
        if(!pocket.length) continue;
        const target=pocket[0];
        const path=bfsWithAlternatives(head.x,head.y,target.x,target.y,true,true);
        if(path&&path.length){
          const nxt=path[0];
          const sim=[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)) return nxt;
        }
      }
      return null;
    }
    function getMinStepsToFruit(){
      if(!fruit||fruit.x<0) return Infinity;
      const head=snake[0];
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const dist=Array.from({length:ROWS},()=>Array(COLS).fill(Infinity));
      const Q=[{x:head.x,y:head.y}];
      vis[head.y][head.x]=true; dist[head.y][head.x]=0;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return dist[y][x];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; dist[ny][nx]=dist[y][x]+1; Q.push({x:nx,y:ny});
        }
      }
      return Infinity;
    }
    /* ===== GET NEXT ===== */
    function getNext(){
      HAM = buildHamilton();
      const head=snake[0];
      windowMoves.push(`${head.x},${head.y}`);
      if(windowMoves.length>WINDOW_SIZE) windowMoves.shift();
      lastMoves.push({x:head.x,y:head.y});
      if(lastMoves.length>MAX_LOOP_DETECTION) lastMoves.shift();
      const freeCells=COLS*ROWS - snake.length;
      const isEndgame = freeCells <= (ENDGAME_THRESHOLD + loopCountAdjust);
      if(!hamMode && freeCells > (ENDGAME_THRESHOLD + loopCountAdjust)){
        const uniq=new Set(windowMoves).size;
        if(uniq < WINDOW_SIZE/2){
          hamMode = true; loopStreak = 0; noProgressMoves = 0;
          currentStrategy = "Forcing Hamilton (Stagnation)";
          loopCountAdjust++;
        }
      }
      if(freeCells <= 1){
        const nxt = hamNext(head);
        if(nxt){
          const isTail=snake.length>1 && nxt.x===snake[snake.length-1].x && nxt.y===snake[snake.length-1].y;
          if(!snakeSet.has(`${nxt.x},${nxt.y}`) || isTail){
            currentStrategy = "Final Hamilton";
            return nxt;
          }
        }
      }
      if(isEndgame){
        const back=getBackToHamilton(head);
        if(back){ currentStrategy="Returning to Hamilton"; return back; }
        const nxt=hamNext(head);
        if(nxt){
          const key=`${nxt.x},${nxt.y}`;
          const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
          const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if((!snakeSet.has(key)||isTailStep) && canReachTailFrom(nxt,sim)){
            currentStrategy="Endgame Hamilton"; return nxt;
          }
        }
      }
      if(fruit && fruit.x >= 0){
        const d = Math.abs(head.x - fruit.x) + Math.abs(head.y - fruit.y);
        if(d < prevFruitDist){ prevFruitDist = d; noProgressMoves = 0; }
        else noProgressMoves++;
      } else {
        prevFruitDist = Infinity; noProgressMoves = 0;
      }
      if(!hamMode && noProgressMoves >= NO_PROGRESS_THRESHOLD){
        hamMode = true; loopStreak = 0; noProgressMoves = 0;
        currentStrategy = "Forcing Hamilton (No progress)";
        loopCountAdjust++;
      }
      if(hamMode){
        const nxt = hamNext(head);
        if(nxt){
          const key=`${nxt.x},${nxt.y}`;
          const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
          const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if((!snakeSet.has(key)||isTailStep) && canReachTailFrom(nxt,sim)){
            currentStrategy = "Hamilton cycle";
            return nxt;
          }
        }
        hamMode = false;
      }
      loopDetected = detectLoop();
      loopStreak = loopDetected ? loopStreak + 1 : 0;
      if(loopDetected && !hamMode){
        hamMode = true;
        loopStreak = 0;
        currentStrategy = "Forcing Hamilton (Immediate Loop)";
        loopCountAdjust++;
      }
      if(loopDetected && snake.length >= 2){
        if(freeCells <= FILL_POCKET_LIMIT){
          const fillMove = fillSmallestPocket();
          if(fillMove){ currentStrategy="Filling smallest pocket"; return fillMove; }
        }
        const dmap = getDistancesFromTail();
        let best=null,bestDist=-1;
        for(const d of DIRS){
          const nx=head.x+d.dx, ny=head.y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
          const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
          if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
          const dist=dmap[ny][nx];
          if(dist>bestDist){bestDist=dist; best={x:nx,y:ny};}
        }
        if(best){ currentStrategy="Loop break (Longest)"; return best; }
      }
      const fruitAcc = isFruitAccessible(head);
      if(fruitAcc && freeCells>15){
        let choices=[],minD=Infinity;
        for(const d of DIRS){
          const nx=head.x+d.dx, ny=head.y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
          const nd=Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y);
          if(nd>minD) continue;
          const sim=(nx===fruit.x&&ny===fruit.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
          if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
          if(nd<minD){minD=nd; choices=[{x:nx,y:ny}];}
          else if(nd===minD){choices.push({x:nx,y:ny});}
        }
        if(choices.length){ currentStrategy="Greedy to fruit"; return choices[(Math.random()*choices.length)|0]; }
      }
      const inPocket = isFruitInPocket();
      if(!compactMode && (inPocket||loopDetected) && freeCells>15){
        compactMode = true; compactModeSteps = 0;
      }
      if(compactMode){
        if(compactModeSteps >= COMPACT_MODE_MAX_STEPS){
          compactMode = false; compactModeSteps = 0;
        } else {
          const zig = calculateZigZagPath();
          if(zig){ compactModeSteps++; currentStrategy="Compact zig-zag"; return zig; }
          else{ compactMode = false; }
        }
      }
      if(fruitAcc && freeCells>1){
        const path=bfsWithAlternatives(head.x,head.y,fruit.x,fruit.y,false,loopDetected);
        if(path && path.length){
          const nxt=path[0];
          const sim=(nxt.x===fruit.x&&nxt.y===fruit.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)){ currentStrategy="BFS to fruit"; return nxt; }
        }
      }
      let bestScore=-Infinity,bestMoves=[];
      const tailPos=snake.length>1?snake[snake.length-1]:null;
      const randomFactor=loopDetected?Math.random()*5:0;
      const avoidFactor=loopDetected?0.5:1;
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
        const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        const freeAfter=floodSize(nx,ny,sim);
        if(freeAfter<COLS*ROWS-sim.length) continue;
        let score=0;
        if(fruit&&fruit.x>=0&&freeCells>Math.max(6, COLS-2)){
          score+=(COLS+ROWS-(Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y)))*2*avoidFactor;
        }
        if(isEndgame && tailPos && nx===tailPos.x && ny===tailPos.y) score+=10000;
        score+=Math.min(nx,ny,COLS-1-nx,ROWS-1-ny);
        score+=randomFactor;
        score+=freeAfter*2;
        if(score>bestScore){ bestScore=score; bestMoves=[{x:nx,y:ny}]; }
        else if(score===bestScore){ bestMoves.push({x:nx,y:ny}); }
      }
      if(bestMoves.length){ currentStrategy="Heuristic"; return bestMoves[(Math.random()*bestMoves.length)|0]; }
      const tail=snake.length>1?snake[snake.length-1]:head;
      const path=bfsWithAlternatives(head.x,head.y,tail.x,tail.y,true,loopDetected);
      if(path && path.length){
        const nxt=path[0];
        const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
        if(canReachTailFrom(nxt,sim)){ currentStrategy="BFS to tail"; return nxt; }
      }
      currentStrategy="No safe move!";
      return null;
    }
    /* ===== RENDER ===== */
    function draw(){
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const now = performance.now();
      const baseGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      baseGradient.addColorStop(0, '#0f172a');
      baseGradient.addColorStop(1, '#111827');
      ctx.fillStyle = baseGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const vignette = ctx.createRadialGradient(
        canvas.width / 2,
        canvas.height / 2,
        Math.min(canvas.width, canvas.height) * 0.2,
        canvas.width / 2,
        canvas.height / 2,
        Math.max(canvas.width, canvas.height)
      );
      vignette.addColorStop(0, 'rgba(102, 126, 234, 0.15)');
      vignette.addColorStop(1, 'rgba(10, 12, 24, 0.95)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if(gameRunning && runStartTime){
        lastElapsedMs = now - runStartTime;
        updateTimerDisplays();
      }
      if(fruit && fruit.x >= 0){
        const centerX = fruit.x * CELL + CELL / 2;
        const centerY = fruit.y * CELL + CELL / 2;
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = Math.max(CELL * 0.14, 4);
        ctx.strokeStyle = '#22c55e';
        ctx.beginPath();
        ctx.arc(centerX, centerY, CELL * 0.32, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.lineWidth = Math.max(CELL * 0.08, 3);
        ctx.strokeStyle = '#ef4444';
        ctx.beginPath();
        ctx.arc(centerX, centerY, CELL * 0.26, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.fillStyle = '#b91c1c';
        ctx.beginPath();
        ctx.arc(centerX, centerY, CELL * 0.18, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
        ctx.beginPath();
        ctx.arc(centerX - CELL * 0.08, centerY - CELL * 0.1, CELL * 0.07, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
      }
      const headColor = hamMode ? '#38bdf8' : compactMode ? '#7c3aed' : loopDetected ? '#818cf8' : '#4f46e5';
      const headAccent = hamMode ? '#1d4ed8' : compactMode ? '#4c1d95' : loopDetected ? '#4338ca' : '#312e81';
      const headGlow = hamMode ? 'rgba(56, 189, 248, 0.55)' : compactMode ? 'rgba(124, 58, 237, 0.55)' : loopDetected ? 'rgba(129, 140, 248, 0.55)' : 'rgba(79, 70, 229, 0.55)';
      snake.forEach((p, i) => {
        const isHead = i === 0;
        const size = CELL * 0.8;
        const offset = (CELL - size) / 2;
        const x = p.x * CELL + offset;
        const y = p.y * CELL + offset;
        const radius = size * 0.45;
        const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
        let shadowColor;
        const shadowBlur = isHead ? 26 : 18;
        if(isHead) {
          gradient.addColorStop(0, headColor);
          gradient.addColorStop(1, headAccent);
          shadowColor = headGlow;
        } else {
          const t = snake.length > 1 ? i / (snake.length - 1) : 0;
          const baseColor = mixBodyColor(t);
          const highlightColor = adjustRgb(baseColor, 1.2);
          const shadowTone = adjustRgb(baseColor, 0.75);
          gradient.addColorStop(0, rgbToCss(highlightColor));
          gradient.addColorStop(1, rgbToCss(shadowTone));
          shadowColor = rgbToCss(adjustRgb(baseColor, 1.05), 0.4);
        }
        fillRoundedRect(x, y, size, size, radius, gradient, shadowColor, shadowBlur);
        ctx.save();
        ctx.globalAlpha = isHead ? 0.24 : 0.18;
        ctx.fillStyle = '#fff';
        roundedRectPath(ctx, x + size * 0.18, y + size * 0.18, size * 0.64, size * 0.28, size * 0.18);
        ctx.fill();
        ctx.restore();
        if(isHead) {
          ctx.save();
          ctx.fillStyle = '#fff';
          let eyeX1, eyeY1, eyeX2, eyeY2;
          if(snake.length > 1){
            const dx = p.x - snake[1].x;
            const dy = p.y - snake[1].y;
            if(dx === 1) {
              eyeX1 = x + size - size/3.2;
              eyeY1 = y + size/3.2;
              eyeX2 = x + size - size/3.2;
              eyeY2 = y + size - size/3.2;
            } else if(dx === -1) {
              eyeX1 = x + size/3.2;
              eyeY1 = y + size/3.2;
              eyeX2 = x + size/3.2;
              eyeY2 = y + size - size/3.2;
            } else if(dy === 1) {
              eyeX1 = x + size/3.2;
              eyeY1 = y + size - size/3.2;
              eyeX2 = x + size - size/3.2;
              eyeY2 = y + size - size/3.2;
            } else {
              eyeX1 = x + size/3.2;
              eyeY1 = y + size/3.2;
              eyeX2 = x + size - size/3.2;
              eyeY2 = y + size/3.2;
            }
          } else {
            eyeX1 = x + size/3.2;
            eyeY1 = y + size/3.2;
            eyeX2 = x + size - size/3.2;
            eyeY2 = y + size/3.2;
          }
          const eyeRadius = size / 6;
          const pupilRadius = size / 12;
          ctx.beginPath(); ctx.arc(eyeX1, eyeY1, eyeRadius, 0, 2*Math.PI); ctx.fill();
          ctx.beginPath(); ctx.arc(eyeX2, eyeY2, eyeRadius, 0, 2*Math.PI); ctx.fill();
          ctx.fillStyle = '#0f172a';
          ctx.beginPath(); ctx.arc(eyeX1, eyeY1, pupilRadius, 0, 2*Math.PI); ctx.fill();
          ctx.beginPath(); ctx.arc(eyeX2, eyeY2, pupilRadius, 0, 2*Math.PI); ctx.fill();
          ctx.restore();
        }
      });
      for (let i = smackBursts.length - 1; i >= 0; i--) {
        const effect = smackBursts[i];
        const progress = (now - effect.start) / effect.duration;
        if (progress >= 1) {
          smackBursts.splice(i, 1);
          continue;
        }
        const eased = progress * progress * (3 - 2 * progress);
        const radius = effect.startRadius + (effect.endRadius - effect.startRadius) * eased;
        const alpha = 1 - eased;
        ctx.save();
        ctx.globalAlpha = Math.max(0, alpha);
        ctx.strokeStyle = `rgba(148, 163, 255, ${0.6 * alpha})`;
        ctx.lineWidth = Math.max(effect.lineWidth * (1 - eased * 0.6), 2);
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, radius, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
        ctx.save();
        ctx.globalAlpha = Math.max(0, 0.8 - eased);
        ctx.fillStyle = '#f8fafc';
        ctx.font = `600 ${Math.max(effect.fontSize * (1 + eased * 0.3), 12)}px Inter, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('SMACK!', effect.x, effect.y - (effect.fontSize * 0.4 * eased));
        ctx.restore();
      }
      document.getElementById('strategyStatus').textContent = `Strategy: ${currentStrategy}`;
      document.getElementById('hamStatus').textContent = hamMode ? "Hamilton active" : "";
      document.getElementById('loopStatus').textContent = loopDetected ? `Loop detected! (${loopStreak})` : "";
      document.getElementById('compactStatus').textContent = compactMode ? "Compact mode active" : "";
      document.getElementById('compactStepStatus').textContent = compactMode ? `Step ${compactModeSteps}/${COMPACT_MODE_MAX_STEPS}` : "";
      if(planDescriptionEl) {
        planDescriptionEl.textContent = describeCurrentPlan();
      }
      const freeCellsCount = COLS * ROWS - snake.length;
      document.getElementById('snakeLength').textContent = snake.length;
      document.getElementById('freeCells').textContent = freeCellsCount;
      document.getElementById('progress').textContent = ((snake.length / (COLS * ROWS)) * 100).toFixed(1) + '%';
    }
    /* ===== UPDATE ===== */
    function update(){
      if(!snake.length){
        clearInterval(loopHandle);
        gameRunning = false;
        finalizeRunTimer();
        return;
      }
      const nxt = getNext();
      if(!nxt){
        clearInterval(loopHandle);
        gameRunning = false;
        finalizeRunTimer();
        draw();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(snake.length === COLS * ROWS ? "PERFECT! üéâ" : "Game Over", canvas.width/2, canvas.height/2);
        ctx.font = '20px Inter, sans-serif';
        ctx.fillText(`Final length: ${snake.length}`, canvas.width/2, canvas.height/2 + 40);
        return;
      }
      if(nxt.x < 0 || nxt.x >= COLS || nxt.y < 0 || nxt.y >= ROWS){
        clearInterval(loopHandle);
        gameRunning = false;
        finalizeRunTimer();
        draw();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText("Crash! üí•", canvas.width/2, canvas.height/2);
        return;
      }
      const ate = fruit && fruit.x >= 0 && nxt.x === fruit.x && nxt.y === fruit.y;
      if(!ate){
        const tail = snake.pop();
        snakeSet.delete(`${tail.x},${tail.y}`);
      }
      snake.unshift({x: nxt.x, y: nxt.y});
      snakeSet.add(`${nxt.x},${nxt.y}`);
      if(ate){
        smackBursts.push({
          x: (fruit.x + 0.5) * CELL,
          y: (fruit.y + 0.5) * CELL,
          start: performance.now(),
          duration: 550,
          startRadius: CELL * 0.2,
          endRadius: CELL * 1.1,
          lineWidth: Math.max(CELL * 0.12, 4),
          fontSize: Math.max(CELL * 0.36, 12)
        });
        loopCountAdjust = 0;
        if(snake.length === COLS * ROWS){
          fruit = {x: -1, y: -1};
          clearInterval(loopHandle);
          gameRunning = false;
          finalizeRunTimer();
          draw();
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          gradient.addColorStop(0, '#667eea');
          gradient.addColorStop(0.5, '#f093fb');
          gradient.addColorStop(1, '#764ba2');
          ctx.fillStyle = gradient;
          ctx.font = 'bold 48px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText("PERFECT! üèÜ", canvas.width/2, canvas.height/2);
          ctx.fillStyle = '#fff';
          ctx.font = '24px Inter, sans-serif';
          ctx.fillText("You filled the entire board!", canvas.width/2, canvas.height/2 + 50);
          return;
        } else {
          fruit = spawnFruit();
          prevFruitDist = (fruit.x >= 0) ? Math.abs(snake[0].x - fruit.x) + Math.abs(snake[0].y - fruit.y) : Infinity;
          noProgressMoves = 0;
        }
      }
      draw();
    }
    /* ===== SPEED CONTROLS & STARTUP ===== */
    document.getElementById('slowerBtn').onclick = () => changeSpeed(SPEED + SPEED_STEP);
    document.getElementById('fasterBtn').onclick = () => changeSpeed(SPEED - SPEED_STEP);
    function changeSpeed(v){
      v = Math.max(MIN_SPEED, Math.min(MAX_SPEED, v));
      if(v !== SPEED){
        SPEED = v;
        document.getElementById('speedDisplay').textContent = `Speed: ${SPEED}ms`;
        if(gameRunning) {
          clearInterval(loopHandle);
          loopHandle = setInterval(update, SPEED);
        }
      }
    }
    /* ===== PRESET LOADING ===== */
    const presetButtons = document.querySelectorAll('.load-preset');
    presetButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        // flag to prevent dynamic recalculation when grid size changes
        window.loadingPreset = true;
        if (preset === 'small') {
          colsSlider.value = 10; rowsSlider.value = 10; updateGridSize();
          LOOP_STREAK_THRESHOLD = 1; loopThreshSlider.value = 1; document.getElementById('loopThreshValue').textContent = 1;
          NO_PROGRESS_THRESHOLD = 30; progThreshSlider.value = 30; document.getElementById('progThreshValue').textContent = 30;
          ENDGAME_THRESHOLD = 5; endgameSlider.value = 5; document.getElementById('endgameValue').textContent = 5;
          COMPACT_MODE_MAX_STEPS = 50; compactSlider.value = 50; document.getElementById('compactValue').textContent = 50;
          changeSpeed(120);
        } else if (preset === 'balanced') {
          colsSlider.value = 20; rowsSlider.value = 20; updateGridSize();
          LOOP_STREAK_THRESHOLD = 3; loopThreshSlider.value = 3; document.getElementById('loopThreshValue').textContent = 3;
          NO_PROGRESS_THRESHOLD = 70; progThreshSlider.value = 70; document.getElementById('progThreshValue').textContent = 70;
          ENDGAME_THRESHOLD = 40; endgameSlider.value = 40; document.getElementById('endgameValue').textContent = 40;
          COMPACT_MODE_MAX_STEPS = 200; compactSlider.value = 200; document.getElementById('compactValue').textContent = 200;
          changeSpeed(80);
        } else if (preset === 'ultra') {
          colsSlider.value = 30; rowsSlider.value = 30; updateGridSize();
          LOOP_STREAK_THRESHOLD = 5; loopThreshSlider.value = 5; document.getElementById('loopThreshValue').textContent = 5;
          NO_PROGRESS_THRESHOLD = 150; progThreshSlider.value = 150; document.getElementById('progThreshValue').textContent = 150;
          ENDGAME_THRESHOLD = 80; endgameSlider.value = 80; document.getElementById('endgameValue').textContent = 80;
          COMPACT_MODE_MAX_STEPS = 450; compactSlider.value = 450; document.getElementById('compactValue').textContent = 450;
          changeSpeed(40);
        }
        window.loadingPreset = false;
        restartGame();
      });
    });
    // initial start
    restartGame();
    document.getElementById('colsValue').textContent = COLS;
    document.getElementById('rowsValue').textContent = ROWS;
    document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
  </script>
</body>
</html>





