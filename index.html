

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate Snake AI - Perfect Algorithm</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Syncopate:wght@400;700&family=JetBrains+Mono:wght@400;700&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --accent: #f093fb;
      --success: #4ade80;
      --danger: #ef4444;
      --warning: #fbbf24;
      --dark: #1a1a2e;
      --darker: #0f0f23;
      --light: #eef2ff;
      --text: #e2e8f0;
      --glass: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.2);
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
      min-height: 100vh;
      color: var(--text);
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
      opacity: 0.03;
      animation: rotate 60s linear infinite;
      z-index: -1;
    }

    @keyframes rotate { to { transform: rotate(360deg); } }

    .container { max-width: 1600px; margin: 0 auto; padding: 2rem; }
    .header { text-align: center; margin-bottom: 2rem; }
    .header h1 {
      font-family: 'Syncopate', sans-serif;
      font-size: 3rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
      letter-spacing: -2px;
    }
    .header p { opacity: 0.8; font-size: 1rem; }

    .main-grid {
      display: grid;
      grid-template-columns: 320px 1fr 380px;
      gap: 2rem;
      align-items: start;
    }

    .panel {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .panel h3 {
      font-family: 'Syncopate', sans-serif;
      font-size: 0.75rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .panel h3::before {
      content: '';
      width: 3px;
      height: 12px;
      background: var(--accent);
      border-radius: 2px;
    }

    .game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .canvas-wrapper {
      position: relative;
      padding: 8px;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      border-radius: 1rem;
      box-shadow: 0 0 50px rgba(112, 0, 255, 0.3);
    }

    #game {
      display: block;
      border-radius: 8px;
      background: #000;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.75rem;
      width: 100%;
      max-width: 700px;
    }

    .stats-stack {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .stat-card {
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 0.75rem;
      padding: 1rem;
      text-align: center;
      border-bottom: 2px solid var(--accent);
    }

    .stat-label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      opacity: 0.6;
      margin-bottom: 0.25rem;
    }

    .stat-value {
      font-family: 'Syncopate', sans-serif;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent);
    }

    .control-group { margin-bottom: 1.25rem; }

    .control-group label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
      opacity: 0.9;
    }

    .control-group label span {
      color: var(--accent);
      font-weight: 700;
      float: right;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--darker);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      cursor: pointer;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
    }

    .button {
      width: 100%;
      padding: 0.75rem;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: #fff;
      border: none;
      border-radius: 0.5rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      user-select: none;
    }

    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
    }

    .button.danger {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
    }

    .button.warning {
      background: linear-gradient(135deg, var(--warning) 0%, #f59e0b 100%);
      color: #1f2937;
      box-shadow: 0 4px 15px rgba(251, 191, 36, 0.45);
    }

    .button.toggle-active {
      background: linear-gradient(135deg, var(--success) 0%, var(--accent) 100%);
      box-shadow: 0 4px 15px rgba(74, 222, 128, 0.4);
    }

    .button-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.75rem;
    }

    select {
      width: 100%;
      padding: 0.75rem;
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 0.5rem;
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      cursor: pointer;
    }

    select option { background: var(--dark); color: var(--text); }

    .helper-text {
      margin-top: 0.4rem;
      font-size: 0.75rem;
      opacity: 0.7;
    }

    .strategy-display {
      background: var(--darker);
      border-radius: 0.75rem;
      padding: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--glass-border);
    }

    .strategy-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--accent);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .strategy-text { font-size: 0.85rem; line-height: 1.4; opacity: 0.9; }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
      animation: pulse 2s infinite;
    }

    .status-indicator.active { background: var(--success); }

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

    .help-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(18px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2300;
    }

    .help-overlay[hidden] { display: none; }

    .help-card {
      max-width: 480px;
      width: 90%;
      background: radial-gradient(circle at top left, rgba(102, 126, 234, 0.35), var(--darker));
      border-radius: 1.5rem;
      border: 1px solid var(--glass-border);
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.7);
      padding: 2rem 2.25rem 1.75rem;
      color: var(--text);
    }

    .help-card h2 {
      margin-top: 0;
      margin-bottom: 1rem;
      font-size: 1.6rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .help-card h2::before {
      content: '‚å®Ô∏è';
      font-size: 1.4rem;
    }

    .help-card ul {
      list-style: none;
      padding-left: 0;
      margin: 0 0 1.5rem 0;
    }

    .help-card li {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.6rem;
      line-height: 1.5;
    }

    .help-card kbd {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 32px;
      padding: 0.25rem 0.6rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.8);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), rgba(15, 23, 42, 0.6));
      box-shadow: 0 2px 0 rgba(15, 23, 42, 0.9);
      font-size: 0.8rem;
      font-weight: 600;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .help-card li span { opacity: 0.9; font-size: 0.9rem; }
    .help-card .button { width: 100%; justify-content: center; }

    @media (max-width: 1400px) {
      .main-grid { grid-template-columns: 1fr; }
      .stats-grid { grid-template-columns: repeat(2, 1fr); }
      .stats-stack { grid-template-columns: repeat(2, 1fr); }
      .button-row { grid-template-columns: 1fr; }
    }
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ULTIMATE SNAKE AI</h1>
      <p>Perfect algorithm combining Hamiltonian cycles, BFS pathfinding, and advanced heuristics</p>
    </div>

    <div class="main-grid">
      <div class="panel">
        <h3>Game Stats</h3>
        <div class="stats-stack">
          <div class="stat-card" style="border-bottom-color: var(--accent);">
            <div class="stat-label">Length</div>
            <div class="stat-value" id="snakeLength">3</div>
          </div>
          <div class="stat-card" style="border-bottom-color: var(--warning);">
            <div class="stat-label">Free Cells</div>
            <div class="stat-value" id="freeCells">0</div>
          </div>
          <div class="stat-card" style="border-bottom-color: var(--primary);">
            <div class="stat-label">Elapsed</div>
            <div class="stat-value" id="elapsedTime">00:00.0</div>
          </div>
          <div class="stat-card" style="border-bottom-color: var(--success);">
            <div class="stat-label">Best Time</div>
            <div class="stat-value" id="bestTime">--</div>
          </div>
          <div class="stat-card" style="border-bottom-color: var(--danger);">
            <div class="stat-label">Completed</div>
            <div class="stat-value" id="completedRounds">0</div>
          </div>
        </div>

        <div class="strategy-display">
          <div class="strategy-title">
            <span class="status-indicator active"></span>
            Current Strategy
          </div>
          <div class="strategy-text" id="strategyStatus">Strategy: Initializing</div>
          <div class="strategy-text" id="strategyExplanation"></div>
          <div class="strategy-text" id="completionStatus" hidden aria-live="polite"></div>
        </div>

        <div class="strategy-display" style="margin-top: 0.5rem;">
          <div class="strategy-title">Algorithm Status</div>
          <div class="strategy-text">
            <div id="hamStatus"></div>
            <div id="loopStatus"></div>
            <div id="compactStatus"></div>
            <div id="compactStepStatus"></div>
          </div>
        </div>
      </div>

      <div class="game-container">
        <div class="canvas-wrapper">
          <canvas id="game" width="400" height="400"></canvas>
        </div>

        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-label">Apples</div>
            <div class="stat-value" id="applesEaten">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Best</div>
            <div class="stat-value" id="appleHighScore">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Speed</div>
            <div class="stat-value" id="speedDisplay">Speed: 100ms</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Progress</div>
            <div class="stat-value" id="progress">0%</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3>AI Controls</h3>

        <div class="control-group">
          <div class="button-row">
            <button id="slowerBtn" class="button">üêå Slower</button>
            <button id="fasterBtn" class="button">‚ö° Faster</button>
          </div>
        </div>

        <div class="control-group">
          <button id="restartBtn" class="button danger">üîÑ Restart</button>
        </div>

        <div class="control-group">
          <button id="manualToggle" class="button">üïπÔ∏è Try Manual Play</button>
          <p id="manualHint" class="helper-text">Manual mode off ‚Äì AI is playing automatically.</p>
        </div>

        <div class="control-group">
          <label for="themeSelect">Color theme</label>
          <select id="themeSelect">
            <option value="aurora">Aurora ¬∑ Lila &amp; bl√•</option>
            <option value="sunset">Sunset ¬∑ Guld &amp; r√∂tt</option>
            <option value="emerald">Emerald ¬∑ Gr√∂n</option>
            <option value="glacier">Glacier ¬∑ Turkos</option>
            <option value="matrix">Matrix</option>
          </select>
          <p class="helper-text">Pick a palette to recolor the board, snake and interface.</p>
        </div>

        <h3 style="margin-top: 2rem;">Grid Size</h3>
        <div class="control-group">
          <label>Columns <span id="colsValue">10</span></label>
          <input type="range" id="colsSlider" min="10" max="100" value="10" step="5">
        </div>
        <div class="control-group">
          <label>Rows <span id="rowsValue">10</span></label>
          <input type="range" id="rowsSlider" min="10" max="100" value="10" step="5">
        </div>
        <div class="control-group">
          <label>Canvas Size</label>
          <input type="range" id="sizeSlider" min="300" max="800" value="400" step="50">
        </div>

        <h3 style="margin-top: 2rem;">AI Parameters</h3>
        <div class="control-group">
          <label>Endgame Threshold <span id="endgameValue">0</span></label>
          <input type="range" id="endgameSlider" min="0" max="100" value="0" step="5">
        </div>
        <div class="control-group">
          <label>Loop Streak Threshold <span id="loopThreshValue">3</span></label>
          <input type="range" id="loopThreshSlider" min="1" max="10" value="3" step="1">
        </div>
        <div class="control-group">
          <label>No Progress Threshold <span id="progThreshValue">70</span></label>
          <input type="range" id="progThreshSlider" min="10" max="200" value="70" step="5">
        </div>
        <div class="control-group">
          <label for="compactProfile">Compact Mode Style</label>
          <select id="compactProfile">
            <option value="cautious">Extremely cautious</option>
            <option value="balanced" selected>Balanced (current)</option>
            <option value="risky">Extremely daring</option>
          </select>
          <p id="compactProfileHint" class="helper-text">Default behaviour that reacts to pockets or loops.</p>
        </div>
        <div class="control-group">
          <label>Compact Mode Steps <span id="compactValue">200</span></label>
          <input type="range" id="compactSlider" min="0" max="300" value="200" step="10">
        </div>
      </div>
    </div>

  </div>

  <!-- Embedded updated JS logic -->
  <script>
    /* ===== KONFIGURATION ===== */
    let COLS = 10, ROWS = 10;
    let CELL = 30;
    let SPEED = 100;
    const DIRS = [ {dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0} ];
    const DIR_TO_INDEX = DIRS.reduce((acc, dir, idx) => {
      acc[`${dir.dx},${dir.dy}`] = idx;
      return acc;
    }, {});
    const MAX_SPEED = 500, MIN_SPEED = 1, SPEED_STEP = 10;
    let manualMode = false;
    let manualDirection = {dx: 1, dy: 0};
    let pendingManualDirection = null;
    let eatParticles = [];
    let safetyNetEnabled = true;
    let rlTrainingEnabled = false;
    let rlPendingChoice = null;
    let rlEpisodeActive = false;
    let autoRestartEnabled = false;
    let startTime = null;
    let elapsedTimerHandle = null;
    let elapsedTimeEl = null;
    let performanceElapsedEl = null;
    let performanceLengthEl = null;
    let lastElapsedMs = 0;
    let bestTimeMs = null;
    let lastObservedReward = 0;
    let progressRingCircle = null;
    let progressRingMaxLength = null;
    let progressRingPercentLabel = null;
    let rlRewardHistory = [];
    const RL_REWARD_HISTORY_LIMIT = 60;
    let lastRlPhaseLabel = null;

    const THEME_STORAGE_KEY = 'snakeai-theme';
    const THEMES = {
      aurora: {
        label: 'Aurora ¬∑ Lila & bl√•',
        cssVars: {
          '--primary': '#667eea',
          '--secondary': '#764ba2',
          '--accent': '#f093fb',
          '--success': '#4ade80',
          '--danger': '#ef4444',
          '--warning': '#fbbf24',
          '--dark': '#1a1a2e',
          '--darker': '#0f0f23',
          '--light': '#eef2ff',
          '--text': '#e2e8f0',
          '--glass': 'rgba(255, 255, 255, 0.1)',
          '--glass-border': 'rgba(255, 255, 255, 0.2)',
          '--primary-shadow': 'rgba(102, 126, 234, 0.4)',
          '--primary-shadow-strong': 'rgba(102, 126, 234, 0.6)',
          '--primary-ambient': 'rgba(102, 126, 234, 0.3)',
          '--primary-ambient-strong': 'rgba(102, 126, 234, 0.5)',
          '--primary-ambient-xstrong': 'rgba(102, 126, 234, 0.8)',
          '--primary-overlay': 'rgba(102, 126, 234, 0.15)',
          '--primary-overlay-strong': 'rgba(102, 126, 234, 0.4)',
          '--primary-outline': 'rgba(102, 126, 234, 0.08)',
          '--accent-ring': 'rgba(240, 147, 251, 0.25)',
          '--accent-glow': 'rgba(240, 147, 251, 0.35)',
          '--accent-glow-strong': 'rgba(240, 147, 251, 0.75)',
          '--accent-outline': 'rgba(240, 147, 251, 0.45)'
        },
        game: {
          boardGradient: ['#1a1a2e', '#0f0f23'],
          grid: 'rgba(255, 255, 255, 0.02)',
          head: '#667eea',
          headAccent: '#764ba2',
          ham: '#4ade80',
          hamAccent: '#22c55e',
          compact: '#f97316',
          compactAccent: '#ea580c',
          loop: '#fbbf24',
          loopAccent: '#f59e0b',
          bodyStart: '#8b5cf6',
          bodyEnd: '#4338ca',
          apple: '#d62828',
          appleStroke: '#111',
          appleHighlight: 'rgba(255, 255, 255, 0.3)',
          appleGlow: 'rgba(220, 38, 38, 0.5)',
          danger: '#ef4444',
          warning: '#fbbf24',
          deadEnd: '#f97316'
        }
      },
      sunset: {
        label: 'Sunset ¬∑ Guld & r√∂tt',
        cssVars: {
          '--primary': '#f97316',
          '--secondary': '#ef4444',
          '--accent': '#fbbf24',
          '--success': '#4ade80',
          '--danger': '#dc2626',
          '--warning': '#facc15',
          '--dark': '#2b0f05',
          '--darker': '#1a0702',
          '--light': '#fff7ed',
          '--text': '#ffe8d6',
          '--glass': 'rgba(255, 244, 230, 0.08)',
          '--glass-border': 'rgba(255, 244, 230, 0.2)',
          '--primary-shadow': 'rgba(249, 115, 22, 0.45)',
          '--primary-shadow-strong': 'rgba(239, 68, 68, 0.55)',
          '--primary-ambient': 'rgba(249, 115, 22, 0.35)',
          '--primary-ambient-strong': 'rgba(249, 115, 22, 0.55)',
          '--primary-ambient-xstrong': 'rgba(239, 68, 68, 0.75)',
          '--primary-overlay': 'rgba(249, 115, 22, 0.18)',
          '--primary-overlay-strong': 'rgba(239, 68, 68, 0.38)',
          '--primary-outline': 'rgba(249, 115, 22, 0.1)',
          '--accent-ring': 'rgba(251, 191, 36, 0.25)',
          '--accent-glow': 'rgba(251, 191, 36, 0.35)',
          '--accent-glow-strong': 'rgba(251, 191, 36, 0.7)',
          '--accent-outline': 'rgba(251, 191, 36, 0.45)'
        },
        game: {
          boardGradient: ['#2b0f05', '#120401'],
          grid: 'rgba(255, 244, 230, 0.06)',
          head: '#f97316',
          headAccent: '#ef4444',
          ham: '#4ade80',
          hamAccent: '#22c55e',
          compact: '#ea580c',
          compactAccent: '#c2410c',
          loop: '#facc15',
          loopAccent: '#f59e0b',
          bodyStart: '#fbbf24',
          bodyEnd: '#dc2626',
          apple: '#f43f5e',
          appleStroke: '#7f1d1d',
          appleHighlight: 'rgba(255, 255, 255, 0.25)',
          appleGlow: 'rgba(244, 63, 94, 0.45)',
          danger: '#dc2626',
          warning: '#facc15',
          deadEnd: '#fb923c'
        }
      },
      emerald: {
        label: 'Emerald ¬∑ Gr√∂n',
        cssVars: {
          '--primary': '#10b981',
          '--secondary': '#047857',
          '--accent': '#34d399',
          '--success': '#22c55e',
          '--danger': '#ef4444',
          '--warning': '#facc15',
          '--dark': '#052e25',
          '--darker': '#021a16',
          '--light': '#ecfdf5',
          '--text': '#d1fae5',
          '--glass': 'rgba(209, 250, 229, 0.08)',
          '--glass-border': 'rgba(209, 250, 229, 0.2)',
          '--primary-shadow': 'rgba(16, 185, 129, 0.4)',
          '--primary-shadow-strong': 'rgba(16, 185, 129, 0.6)',
          '--primary-ambient': 'rgba(16, 185, 129, 0.3)',
          '--primary-ambient-strong': 'rgba(16, 185, 129, 0.5)',
          '--primary-ambient-xstrong': 'rgba(16, 185, 129, 0.75)',
          '--primary-overlay': 'rgba(16, 185, 129, 0.18)',
          '--primary-overlay-strong': 'rgba(20, 184, 166, 0.35)',
          '--primary-outline': 'rgba(16, 185, 129, 0.1)',
          '--accent-ring': 'rgba(52, 211, 153, 0.28)',
          '--accent-glow': 'rgba(52, 211, 153, 0.4)',
          '--accent-glow-strong': 'rgba(52, 211, 153, 0.75)',
          '--accent-outline': 'rgba(52, 211, 153, 0.5)'
        },
        game: {
          boardGradient: ['#052e25', '#011612'],
          grid: 'rgba(209, 250, 229, 0.05)',
          head: '#10b981',
          headAccent: '#059669',
          ham: '#34d399',
          hamAccent: '#22c55e',
          compact: '#f97316',
          compactAccent: '#ea580c',
          loop: '#facc15',
          loopAccent: '#f59e0b',
          bodyStart: '#34d399',
          bodyEnd: '#047857',
          apple: '#facc15',
          appleStroke: '#14532d',
          appleHighlight: 'rgba(255, 255, 255, 0.25)',
          appleGlow: 'rgba(52, 211, 153, 0.4)',
          danger: '#ef4444',
          warning: '#facc15',
          deadEnd: '#fb923c'
        }
      },
      glacier: {
        label: 'Glacier ¬∑ Turkos',
        cssVars: {
          '--primary': '#38bdf8',
          '--secondary': '#0ea5e9',
          '--accent': '#a855f7',
          '--success': '#2dd4bf',
          '--danger': '#f87171',
          '--warning': '#fde047',
          '--dark': '#05223b',
          '--darker': '#021427',
          '--light': '#e0f2fe',
          '--text': '#dbeafe',
          '--glass': 'rgba(191, 219, 254, 0.08)',
          '--glass-border': 'rgba(191, 219, 254, 0.2)',
          '--primary-shadow': 'rgba(56, 189, 248, 0.4)',
          '--primary-shadow-strong': 'rgba(14, 165, 233, 0.6)',
          '--primary-ambient': 'rgba(56, 189, 248, 0.3)',
          '--primary-ambient-strong': 'rgba(56, 189, 248, 0.5)',
          '--primary-ambient-xstrong': 'rgba(14, 165, 233, 0.75)',
          '--primary-overlay': 'rgba(56, 189, 248, 0.18)',
          '--primary-overlay-strong': 'rgba(14, 165, 233, 0.38)',
          '--primary-outline': 'rgba(56, 189, 248, 0.1)',
          '--accent-ring': 'rgba(168, 85, 247, 0.25)',
          '--accent-glow': 'rgba(168, 85, 247, 0.35)',
          '--accent-glow-strong': 'rgba(168, 85, 247, 0.7)',
          '--accent-outline': 'rgba(168, 85, 247, 0.45)'
        },
        game: {
          boardGradient: ['#05223b', '#021427'],
          grid: 'rgba(219, 234, 254, 0.05)',
          head: '#38bdf8',
          headAccent: '#0ea5e9',
          ham: '#2dd4bf',
          hamAccent: '#14b8a6',
          compact: '#f97316',
          compactAccent: '#ea580c',
          loop: '#fde047',
          loopAccent: '#f59e0b',
          bodyStart: '#60a5fa',
          bodyEnd: '#1d4ed8',
          apple: '#f87171',
          appleStroke: '#7f1d1d',
          appleHighlight: 'rgba(255, 255, 255, 0.25)',
          appleGlow: 'rgba(248, 113, 113, 0.4)',
          danger: '#f87171',
          warning: '#fde047',
          deadEnd: '#fb923c'
        }
      },
      matrix: {
        label: 'Matrix',
        cssVars: {
          '--primary': '#00ff41',
          '--secondary': '#00b533',
          '--accent': '#00ffa3',
          '--success': '#39ff14',
          '--danger': '#00ff41',
          '--warning': '#00ffa3',
          '--dark': '#041204',
          '--darker': '#010503',
          '--light': '#ccffd7',
          '--text': '#9ef7b3',
          '--glass': 'rgba(0, 255, 65, 0.08)',
          '--glass-border': 'rgba(0, 255, 65, 0.22)',
          '--primary-shadow': 'rgba(0, 255, 65, 0.35)',
          '--primary-shadow-strong': 'rgba(0, 255, 65, 0.55)',
          '--primary-ambient': 'rgba(0, 255, 65, 0.3)',
          '--primary-ambient-strong': 'rgba(0, 255, 65, 0.55)',
          '--primary-ambient-xstrong': 'rgba(0, 255, 65, 0.8)',
          '--primary-overlay': 'rgba(0, 255, 65, 0.18)',
          '--primary-overlay-strong': 'rgba(0, 255, 65, 0.36)',
          '--primary-outline': 'rgba(0, 255, 65, 0.12)',
          '--accent-ring': 'rgba(0, 255, 163, 0.25)',
          '--accent-glow': 'rgba(0, 255, 163, 0.35)',
          '--accent-glow-strong': 'rgba(0, 255, 163, 0.65)',
          '--accent-outline': 'rgba(0, 255, 163, 0.45)'
        },
        game: {
          boardGradient: ['#020d02', '#000000'],
          grid: 'rgba(0, 255, 65, 0.07)',
          head: '#00ff41',
          headAccent: '#00b533',
          ham: '#39ff14',
          hamAccent: '#16ff6e',
          compact: '#00cc66',
          compactAccent: '#00994d',
          loop: '#00ffa3',
          loopAccent: '#00d184',
          bodyStart: '#00ff90',
          bodyEnd: '#008f2a',
          apple: '#00ffa3',
          appleStroke: '#003d1a',
          appleHighlight: 'rgba(204, 255, 222, 0.3)',
          appleGlow: 'rgba(0, 255, 144, 0.4)',
          danger: '#00ff41',
          warning: '#00ffa3',
          deadEnd: '#00cc66'
        }
      }
    };
    let currentThemeKey = 'aurora';
    let currentTheme = THEMES[currentThemeKey];
    function applyTheme(themeKey, { persist = false } = {}){
      const theme = THEMES[themeKey] ?? THEMES.aurora;
      currentThemeKey = themeKey;
      currentTheme = theme;
      const root = document.documentElement;
      Object.entries(theme.cssVars).forEach(([name, value]) => {
        root.style.setProperty(name, value);
      });
      root.setAttribute('data-theme', themeKey);
      if(persist){
        try {
          localStorage.setItem(THEME_STORAGE_KEY, themeKey);
        } catch (error){
          console.warn('Unable to persist theme preference', error);
        }
      }
    }
    function initTheme(){
      let stored = null;
      try {
        stored = localStorage.getItem(THEME_STORAGE_KEY);
      } catch (error){
        stored = null;
      }
      if(stored && THEMES[stored]){
        applyTheme(stored);
      } else {
        applyTheme(currentThemeKey);
      }
    }
    function hexToRgb(hex){
      if(typeof hex !== 'string'){ return { r: 0, g: 0, b: 0 }; }
      let normalized = hex.trim().replace('#', '');
      if(normalized.length === 3){
        normalized = normalized.split('').map(ch => ch + ch).join('');
      }
      const intVal = parseInt(normalized, 16);
      if(Number.isNaN(intVal)){
        return { r: 0, g: 0, b: 0 };
      }
      return {
        r: (intVal >> 16) & 255,
        g: (intVal >> 8) & 255,
        b: intVal & 255
      };
    }
    function clampColor(value){
      return Math.max(0, Math.min(255, value));
    }
    function rgbToCss(color, alpha = 1){
      const r = clampColor(Math.round(color.r ?? 0));
      const g = clampColor(Math.round(color.g ?? 0));
      const b = clampColor(Math.round(color.b ?? 0));
      if(alpha >= 0 && alpha < 1){
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }
      return `rgb(${r}, ${g}, ${b})`;
    }
    function mixHexColors(colorA, colorB, t){
      const ratio = Math.max(0, Math.min(1, Number.isFinite(t) ? t : 0));
      const a = hexToRgb(colorA);
      const b = hexToRgb(colorB);
      return {
        r: Math.round(a.r + (b.r - a.r) * ratio),
        g: Math.round(a.g + (b.g - a.g) * ratio),
        b: Math.round(a.b + (b.b - a.b) * ratio)
      };
    }
    function lightenRgb(color, amount){
      const ratio = Math.max(0, Math.min(1, amount));
      return {
        r: Math.round(color.r + (255 - color.r) * ratio),
        g: Math.round(color.g + (255 - color.g) * ratio),
        b: Math.round(color.b + (255 - color.b) * ratio)
      };
    }
    function darkenRgb(color, amount){
      const ratio = Math.max(0, Math.min(1, amount));
      return {
        r: Math.round(color.r * (1 - ratio)),
        g: Math.round(color.g * (1 - ratio)),
        b: Math.round(color.b * (1 - ratio))
      };
    }
    initTheme();
    const RL_REWARD_COMPONENTS = [
      { id: 'stepPenalty', label: 'Step penalty' },
      { id: 'fruitReward', label: 'Fruit reward' },
      { id: 'fruitApproachReward', label: 'Fruit approach bonus' },
      { id: 'winBonus', label: 'Win bonus' },
      { id: 'bestTimeBonus', label: 'Record time bonus' },
      { id: 'endgamePlanReward', label: 'Endgame plan bonus' },
      { id: 'compactModeReward', label: 'Compact mode bonus' },
      { id: 'pocketFillReward', label: 'Pocket fill reward' },
      { id: 'wallDistanceReward', label: 'Wall spacing bonus' },
      { id: 'wallCrashPenalty', label: 'Wall crash penalty' },
      { id: 'selfCrashPenalty', label: 'Self crash penalty' },
      { id: 'deadEndPenalty', label: 'Dead-end penalty' },
      { id: 'deathPenalty', label: 'Generic crash penalty' },
      { id: 'loopPenalty', label: 'Loop stall penalty' }
    ];
    const RL_REWARD_COMPONENT_MAP = RL_REWARD_COMPONENTS.reduce((acc, entry) => {
      acc[entry.id] = entry;
      return acc;
    }, {});
    function createEmptyRewardImpactSnapshot(){
      return RL_REWARD_COMPONENTS.reduce((acc, entry) => {
        acc[entry.id] = 0;
        return acc;
      }, {});
    }
    const rlRewardImpactStats = {
      components: RL_REWARD_COMPONENTS.reduce((acc, entry) => {
        acc[entry.id] = { label: entry.label, total: 0, last: 0, prev: 0 };
        return acc;
      }, {}),
      episodes: 0,
      lastTotal: 0,
      prevTotal: 0
    };
    let rlRewardEpisodeAccumulator = createEmptyRewardImpactSnapshot();
    const BASE_TIMEOUT_PER_CELL_MS = 150;
    const MIN_RUN_TIMEOUT_MS = 30000;
    const DEFAULT_RUN_TIMEOUT_LIMIT_MS = 120000;
    const MAX_RUN_TIMEOUT_MS = 15 * 60 * 1000;
    const TIMEOUT_SLIDER_STEP_MS = 15000;
    let runTimeoutMs = null;
    let runTimeoutDeadline = null;
    let timeoutUserOverride = false;
    let completedRounds = 0;
    let applesEaten = 0;
    let appleHighScore = 0;
    let completionMessage = '';
    let consecutiveSelfCrashCount = 0;
    const rlConfig = {
      stepPenalty: -0.05,
      fruitReward: 5,
      fruitApproachReward: 0.5,
      winBonus: 15,
      bestTimeBonus: 100,
      wallCrashPenalty: -9,
      selfCrashPenalty: -14,
      deathPenalty: -9,
      deadEndPenalty: -12,
      wallDistanceReward: 0.3,
      endgamePlanReward: 1.5,
      compactModeReward: 1,
      pocketFillReward: 0.4,
      loopPenalty: -6,
      alpha: 0.2,
      gamma: 0.9,
      epsilonStart: 0.3,
      epsilonMin: 0.05,
      epsilonDecay: 0.995,
      rewardScale: 1,
      trainingEpisodes: 1,
      parallelSnakes: 0,
      method: 'tabular',
      ppoLearningRate: 0.0005,
      ppoClip: 0.2,
      ppoLambda: 0.95,
      ppoEntropyCoeff: 0.01,
      ppoValueCoeff: 0.5,
      ppoEpochs: 4,
      ppoBatchSize: 64
    };
    /* ===== DYNAMIC THRESHOLDS ===== */
    // Initialize endgame threshold; dynamic updates will override when grid changes
    let ENDGAME_THRESHOLD = 0;
    let MAX_LOOP_DETECTION = Math.max(8,(COLS+ROWS)/2|0);
    let WINDOW_SIZE = Math.max(10, COLS + ROWS);
    let FILL_POCKET_LIMIT = COLS * 4;
    let LOOP_ESCAPE_LIMIT = Math.max(40, Math.floor((COLS * ROWS) / 2));
    /* ===== CANVAS ===== */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    CELL = canvas.width / COLS;
    let lastRender = performance.now();
    /* ===== AI PARAMETERS ===== */
    let LOOP_STREAK_THRESHOLD = 1;
    let NO_PROGRESS_THRESHOLD = 70;
    let COMPACT_MODE_MAX_STEPS = 200;
    let COMPACT_MODE_PROFILE = 'balanced';
    const COMPACT_MODE_PROFILES = {
      cautious: {
        label: 'Extremely cautious',
        hint: 'Activates only when the fruit is tightly boxed in and the loop is confirmed.',
        minFreeCells: 8,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: true,
        minLoopStreak: 2,
        allowCrowding: false
      },
      balanced: {
        label: 'Balanced (current)',
        hint: 'Original behaviour ‚Äì reacts to pockets or detected loops.',
        minFreeCells: 15,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: false,
        minLoopStreak: 1,
        allowCrowding: false
      },
      risky: {
        label: 'Extremely daring',
        hint: 'Jumps in early even at the slightest sign of congestion or awkward fruit.',
        minFreeCells: 0,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: false,
        minLoopStreak: 0,
        allowCrowding: true
      }
    };
    let loopCountAdjust = 0;
    const RL_METHODS = { TABULAR: 'tabular', PPO: 'ppo' };
    const RL_OUTCOME_LABELS = {
      win: 'Wins',
      loss: 'Losses',
      'wall-crash': 'Wall crashes',
      'self-crash': 'Self crashes',
      'dead-end-crash': 'Dead-end crashes',
      timeout: 'Timeouts',
      stalled: 'Stalled loops'
    };
    const rlAgents = {
      tabular: createReinforcementAgent(rlConfig),
      ppo: createPpoAgent(rlConfig)
    };
    let rlMethod = rlConfig.method === RL_METHODS.PPO ? RL_METHODS.PPO : RL_METHODS.TABULAR;
    rlConfig.method = rlMethod;
    let rlAgent = rlAgents[rlMethod];
    let rlBatchActive = false;
    let rlBatchEpisodesRemaining = 0;
    let rlBatchPlannedEpisodes = 1;
    let rlHintOverride = null;
    let backgroundTrainingAbortController = null;
    let backgroundTrainingTask = null;
    let backgroundTrainingStats = null;
    /* ===== GAME STATE ===== */
    let snake=[], snakeSet=new Set();
    let fruit, prevFruitDist=Infinity, noProgressMoves=0;
    let lastMoves=[], windowMoves=[], loopDetected=false, loopStreak=0,
        hamMode=false, compactMode=false, compactModeSteps=0,
        loopHandle=null, currentStrategy="Initializing";
    let compactModeJustActivated = false;
    let endgamePlanThisMove = false;
    let persistentLoopCounter = 0;
    let gameRunning = false;
    let autoRestartTimer = null;
    const STRATEGY_DESCRIPTIONS = {
      "Initializing": "Setting up a safe opening path before committing to a plan.",
      "Forcing Hamilton (Stagnation)": "Switching to the safety cycle because movement became repetitive.",
      "Forcing Hamilton (No progress)": "Entering the Hamilton cycle after too many moves without reaching fruit.",
      "Forcing Hamilton (Immediate Loop)": "Breaking a dangerous loop by following the Hamilton safety route.",
      "Final Hamilton": "Finishing the board by following the final Hamilton path.",
      "Returning to Hamilton": "Navigating back to the Hamilton cycle to stay safe.",
      "Endgame Hamilton": "Sticking to the Hamilton cycle while space is limited.",
      "Hamilton cycle": "Calmly marching along the Hamilton cycle for guaranteed coverage.",
      "Filling smallest pocket": "Closing a small empty pocket before it becomes a trap.",
      "Loop break (Longest)": "Taking the longest safe option to break a repeating loop.",
      "Greedy to fruit": "Charging directly for the fruit while it looks safe.",
      "Compact zig-zag": "Compressing the body with tight zig-zags to clear space.",
      "BFS to fruit": "Calculating the safest shortest path to the fruit.",
      "BFS to tail": "Using breadth-first search to reconnect with the tail safely.",
      "Heuristic": "Balancing fruit hunting with safety heuristics.",
      "No safe move!": "No safe moves remain ‚Äì preparing for impact.",
      "Unsafe chase": "Chasing the fruit without the usual safety checks.",
      "Unsafe roam": "Moving freely ‚Äì expect risky behaviour.",
      "Unsafe random": "Taking a random step with no safety guarantees."
    };
    function getStrategyExplanation(strategy) {
      return STRATEGY_DESCRIPTIONS[strategy] || "Assessing the board and adapting to the current situation.";
    }
    function createReinforcementAgent(config = {}){
      let alpha = typeof config.alpha === 'number' ? config.alpha : 0.2;
      let gamma = typeof config.gamma === 'number' ? config.gamma : 0.9;
      let epsilon = typeof config.epsilonStart === 'number' ? config.epsilonStart : 0.3;
      let epsilonMin = typeof config.epsilonMin === 'number' ? config.epsilonMin : 0.05;
      let epsilonDecay = typeof config.epsilonDecay === 'number' ? config.epsilonDecay : 0.995;
      const qTable = new Map();
      let episodes = 0;
      let totalReward = 0;
      let lastEpisodeReward = 0;
      let lastEpisodeDuration = 0;
      let totalEpisodeDuration = 0;
      let lastEpisodeDeaths = 0;
      let totalEpisodeDeaths = 0;
      let totalOutcomes = 0;
      let completedEpisodes = 0;
      const outcomeCounts = Object.create(null);
      const contexts = new Map();
      const normalizeContextId = (id) => {
        if(typeof id === 'string' && id.trim()){
          return id.trim();
        }
        return 'main';
      };
      const ensureContext = (id) => {
        const key = normalizeContextId(id);
        if(!contexts.has(key)){
          contexts.set(key, {
            episodeReward: 0,
            episodeStartTime: null,
            currentEpisodeDeaths: 0
          });
        }
        return contexts.get(key);
      };
      ensureContext('main');
      const stateKey = state => state.join('|');
      const ensureState = key => {
        if(!qTable.has(key)){
          qTable.set(key, Array(DIRS.length).fill(0));
        }
      };
      const nowMs = () => (typeof performance !== 'undefined' && typeof performance.now === 'function')
        ? performance.now()
        : Date.now();
      const applyHyperparameters = values => {
        if(values && typeof values === 'object'){
          if(typeof values.alpha === 'number'){
            alpha = values.alpha;
            config.alpha = values.alpha;
          }
          if(typeof values.gamma === 'number'){
            gamma = values.gamma;
            config.gamma = values.gamma;
          }
          if(typeof values.epsilonMin === 'number'){
            epsilonMin = values.epsilonMin;
            config.epsilonMin = values.epsilonMin;
          }
          if(typeof values.epsilonDecay === 'number'){
            epsilonDecay = values.epsilonDecay;
            config.epsilonDecay = values.epsilonDecay;
          }
          if(typeof values.epsilonStart === 'number'){
            config.epsilonStart = values.epsilonStart;
          }
        }
      };
      return {
        decide(state, safeMoves){
          if(!safeMoves || !safeMoves.length) return null;
          const key = stateKey(state);
          ensureState(key);
          let actionIdx;
          if(Math.random() < epsilon){
            const choice = safeMoves[(Math.random()*safeMoves.length)|0];
            actionIdx = choice.dirIndex;
          } else {
            const values = qTable.get(key);
            let best = -Infinity;
            let bestIndices = [];
            for(const move of safeMoves){
              const value = values[move.dirIndex];
              if(value > best){
                best = value;
                bestIndices = [move.dirIndex];
              } else if(value === best){
                bestIndices.push(move.dirIndex);
              }
            }
            if(bestIndices.length){
              actionIdx = bestIndices[(Math.random()*bestIndices.length)|0];
            } else {
              actionIdx = safeMoves[(Math.random()*safeMoves.length)|0].dirIndex;
            }
          }
          return { stateKey: key, actionIdx };
        },
        learn(prevKey, actionIdx, reward, nextState, done, contextId){
          const ctx = ensureContext(contextId);
          ensureState(prevKey);
          const values = qTable.get(prevKey);
          let target = reward;
          if(!done && nextState){
            const nextKey = stateKey(nextState);
            ensureState(nextKey);
            const nextValues = qTable.get(nextKey);
            const maxNext = Math.max(...nextValues);
            target += gamma * maxNext;
          }
          values[actionIdx] += alpha * (target - values[actionIdx]);
          ctx.episodeReward += reward;
        },
        startEpisode(contextId){
          const ctx = ensureContext(contextId);
          ctx.episodeReward = 0;
          ctx.episodeStartTime = nowMs();
          ctx.currentEpisodeDeaths = 0;
        },
        endEpisode(contextId){
          const ctx = ensureContext(contextId);
          const finishedAt = nowMs();
          const duration = ctx.episodeStartTime ? finishedAt - ctx.episodeStartTime : 0;
          if(duration > 0){
            lastEpisodeDuration = duration;
            totalEpisodeDuration += duration;
          } else {
            lastEpisodeDuration = 0;
          }
          ctx.episodeStartTime = null;
          totalReward += ctx.episodeReward;
          lastEpisodeReward = ctx.episodeReward;
          lastEpisodeDeaths = ctx.currentEpisodeDeaths;
          totalEpisodeDeaths += ctx.currentEpisodeDeaths;
          episodes++;
          epsilon = Math.max(epsilon * epsilonDecay, epsilonMin);
          ctx.episodeReward = 0;
          ctx.currentEpisodeDeaths = 0;
        },
        registerTerminal(outcome, contextId){
          if(typeof outcome !== 'string') return;
          const key = outcome.trim().toLowerCase();
          if(!key) return;
          const deathOutcomes = new Set(['loss', 'timeout', 'wall-crash', 'self-crash', 'dead-end-crash']);
          if(deathOutcomes.has(key)){
            const ctx = ensureContext(contextId);
            ctx.currentEpisodeDeaths += 1;
          } else if(key === 'win'){
            completedEpisodes += 1;
          }
          outcomeCounts[key] = (outcomeCounts[key] || 0) + 1;
          totalOutcomes++;
        },
        setHyperparameters(values){
          applyHyperparameters(values);
        },
        resetEpsilon(value){
          const next = typeof value === 'number' ? value : config.epsilonStart;
          if(typeof next === 'number' && !Number.isNaN(next)){
            epsilon = next;
            config.epsilonStart = next;
          }
        },
        createContext(id){
          const key = normalizeContextId(id);
          ensureContext(key);
          return key;
        },
        deleteContext(id){
          const key = normalizeContextId(id);
          if(key === 'main') return false;
          return contexts.delete(key);
        },
        async startTraining(episodesToRun = 1, options = {}){
          const total = Number.isFinite(episodesToRun)
            ? Math.max(1, Math.floor(episodesToRun))
            : Infinity;
          const rewardDefaults = {
            stepPenalty: config.stepPenalty,
            fruitReward: config.fruitReward,
            fruitApproachReward: config.fruitApproachReward,
            winBonus: config.winBonus,
            wallCrashPenalty: config.wallCrashPenalty,
            selfCrashPenalty: config.selfCrashPenalty,
            deathPenalty: config.deathPenalty,
            loopPenalty: config.loopPenalty,
            wallDistanceReward: config.wallDistanceReward
          };
          const rewardConfig = Object.assign({}, rewardDefaults, options.rewardConfig || {});
          const cols = Number.isFinite(options.cols) && options.cols >= 4 ? Math.floor(options.cols) : COLS;
          const rows = Number.isFinite(options.rows) && options.rows >= 4 ? Math.floor(options.rows) : ROWS;
          const parallelRequested = Number.isFinite(options.parallelSnakes)
            ? Math.max(1, Math.min(32, Math.floor(options.parallelSnakes)))
            : 1;
          const idleLimit = Number.isFinite(options.idleLimit) && options.idleLimit > 0
            ? Math.floor(options.idleLimit)
            : cols * rows * 4;
          const stepLimit = Number.isFinite(options.stepLimit) && options.stepLimit > 0
            ? Math.floor(options.stepLimit)
            : cols * rows * 10;
          const stepDelay = Number.isFinite(options.stepDelay) && options.stepDelay > 0 ? options.stepDelay : 0;
          const abortSignal = options.signal;
          let aborted = false;
          const abortListeners = [];
          if(abortSignal){
            if(abortSignal.aborted){
              return { episodes: 0, wins: 0, apples: 0, steps: 0, crashes: 0 };
            }
            const onAbort = () => { aborted = true; };
            abortSignal.addEventListener('abort', onAbort, { once: true });
            abortListeners.push(onAbort);
          }
          if(parallelRequested <= 0){
            return { episodes: 0, wins: 0, apples: 0, steps: 0, crashes: 0 };
          }
          const stats = { episodes: 0, wins: 0, apples: 0, steps: 0, crashes: 0 };
          const unlimited = !Number.isFinite(total);
          let scheduled = 0;
          const onEpisodeComplete = typeof options.onEpisodeComplete === 'function'
            ? options.onEpisodeComplete
            : null;
          const nextEpisodeIndex = () => {
            if(aborted) return null;
            if(!unlimited && scheduled >= total) return null;
            const current = scheduled;
            scheduled += 1;
            return current;
          };
          const workerCount = unlimited ? parallelRequested : Math.min(parallelRequested, total);
          const tasks = [];
          const contextPrefix = options.contextPrefix || 'bg';
          for(let i = 0; i < workerCount; i++){
            const contextId = `${contextPrefix}-${Date.now()}-${i}-${Math.random().toString(36).slice(2, 8)}`;
            ensureContext(contextId);
            const env = createBackgroundTrainingEnvironment({
              cols,
              rows,
              idleLimit,
              stepLimit,
              rewardConfig
            });
            const runWorker = async () => {
              while(!aborted){
                const episodeIndex = nextEpisodeIndex();
                if(episodeIndex === null && !unlimited){
                  break;
                }
                const result = await runBackgroundTrainingEpisode({
                  agent: this,
                  contextId,
                  environment: env,
                  rewardConfig,
                  stepDelay,
                  signal: abortSignal
                });
                if(result == null){
                  aborted = true;
                  break;
                }
                stats.episodes += 1;
                stats.steps += result.steps;
                stats.apples += result.apples;
                if(result.outcome === 'win') stats.wins += 1;
                if(result.outcome === 'wall-crash' || result.outcome === 'self-crash'){
                  stats.crashes += 1;
                }
                if(onEpisodeComplete){
                  try {
                    onEpisodeComplete(result);
                  } catch (error){
                    console.error('Background episode callback failed', error);
                  }
                }
                if(!unlimited && stats.episodes >= total){
                  break;
                }
              }
              if(contextId !== 'main'){
                contexts.delete(contextId);
              }
            };
            tasks.push(runWorker());
          }
          try {
            await Promise.all(tasks);
          } finally {
            if(abortSignal && abortListeners.length){
              abortListeners.forEach(listener => abortSignal.removeEventListener('abort', listener));
            }
          }
          if(aborted){
            const abortError = new DOMException('Training aborted', 'AbortError');
            abortError.stats = stats;
            throw abortError;
          }
          return stats;
        },
        exportData(){
          const serializedTable = [];
          qTable.forEach((values, key) => {
            serializedTable.push([key, values.map(v => Number.isFinite(v) ? v : 0)]);
          });
          const mainContext = ensureContext('main');
          return {
            version: 1,
            method: 'tabular',
            hyperparameters: {
              alpha,
              gamma,
              epsilon,
              epsilonMin,
              epsilonDecay,
              epsilonStart: config.epsilonStart
            },
            stats: {
              episodes,
              episodeReward: mainContext.episodeReward,
              totalReward,
              lastEpisodeReward,
              lastEpisodeDuration,
              totalEpisodeDuration,
              currentEpisodeDeaths: mainContext.currentEpisodeDeaths,
              lastEpisodeDeaths,
              totalEpisodeDeaths,
              totalOutcomes,
              completedEpisodes
            },
            outcomes: { ...outcomeCounts },
            qTable: serializedTable
          };
        },
          importData(snapshot = {}){
            if(!snapshot || typeof snapshot !== 'object') return false;
            qTable.clear();
            contexts.clear();
            const mainContext = ensureContext('main');
            const tableData = Array.isArray(snapshot.qTable) ? snapshot.qTable : [];
          for(const entry of tableData){
            if(!Array.isArray(entry) || entry.length < 2) continue;
            const [key, rawValues] = entry;
            if(typeof key !== 'string' || !Array.isArray(rawValues)) continue;
            const normalized = rawValues.map(v => Number.isFinite(v) ? v : 0);
            while(normalized.length < DIRS.length){
              normalized.push(0);
            }
            if(normalized.length > DIRS.length){
              normalized.length = DIRS.length;
            }
            qTable.set(key, normalized);
          }
          const hyper = snapshot.hyperparameters || {};
          applyHyperparameters(hyper);
          if(typeof hyper.epsilon === 'number' && !Number.isNaN(hyper.epsilon)){
            epsilon = hyper.epsilon;
          } else if(typeof config.epsilonStart === 'number' && !Number.isNaN(config.epsilonStart)){
            epsilon = config.epsilonStart;
          }
          const stats = snapshot.stats || {};
          if(Number.isFinite(stats.episodes)) episodes = stats.episodes;
          if(Number.isFinite(stats.episodeReward)) mainContext.episodeReward = stats.episodeReward;
          if(Number.isFinite(stats.totalReward)) totalReward = stats.totalReward;
          if(Number.isFinite(stats.lastEpisodeReward)) lastEpisodeReward = stats.lastEpisodeReward;
          if(Number.isFinite(stats.lastEpisodeDuration)) lastEpisodeDuration = stats.lastEpisodeDuration;
          if(Number.isFinite(stats.totalEpisodeDuration)) totalEpisodeDuration = stats.totalEpisodeDuration;
          if(Number.isFinite(stats.currentEpisodeDeaths)) mainContext.currentEpisodeDeaths = stats.currentEpisodeDeaths;
          if(Number.isFinite(stats.lastEpisodeDeaths)) lastEpisodeDeaths = stats.lastEpisodeDeaths;
          if(Number.isFinite(stats.totalEpisodeDeaths)) totalEpisodeDeaths = stats.totalEpisodeDeaths;
          if(Number.isFinite(stats.totalOutcomes)) totalOutcomes = stats.totalOutcomes;
          if(Number.isFinite(stats.completedEpisodes)) completedEpisodes = stats.completedEpisodes;
          for(const key in outcomeCounts){
            if(Object.prototype.hasOwnProperty.call(outcomeCounts, key)){
              delete outcomeCounts[key];
            }
          }
          if(snapshot.outcomes && typeof snapshot.outcomes === 'object'){
            for(const key of Object.keys(snapshot.outcomes)){
              const value = snapshot.outcomes[key];
              if(Number.isFinite(value)){
                outcomeCounts[key] = value;
              }
            }
          }
          mainContext.episodeStartTime = null;
          return true;
        },
        resetLearning(){
          qTable.clear();
          episodes = 0;
          totalReward = 0;
          lastEpisodeReward = 0;
          lastEpisodeDuration = 0;
          totalEpisodeDuration = 0;
          lastEpisodeDeaths = 0;
          totalEpisodeDeaths = 0;
          totalOutcomes = 0;
          completedEpisodes = 0;
          contexts.clear();
          const mainContext = ensureContext('main');
          mainContext.episodeReward = 0;
          mainContext.episodeStartTime = null;
          mainContext.currentEpisodeDeaths = 0;
          for(const key in outcomeCounts){
            if(Object.prototype.hasOwnProperty.call(outcomeCounts, key)){
              delete outcomeCounts[key];
            }
          }
          applyHyperparameters(config);
          this.resetEpsilon(config.epsilonStart);
        },
        chooseMove(){
          return null;
        },
        getStats(){
          return {
            epsilon,
            episodes,
            lastEpisodeReward,
            averageReward: episodes ? totalReward / episodes : 0,
            lastEpisodeDuration,
            averageEpisodeDuration: episodes ? totalEpisodeDuration / episodes : 0,
            lastEpisodeDeaths,
            averageDeaths: episodes ? totalEpisodeDeaths / episodes : 0,
            completedEpisodes,
            alpha,
            gamma,
            epsilonMin,
            epsilonDecay,
            stateCount: qTable.size,
            outcomes: { ...outcomeCounts },
            totalOutcomes
          };
        }
      };
    }
    function createBackgroundTrainingEnvironment(options = {}){
      const cols = Math.max(4, Math.floor(options.cols || COLS));
      const rows = Math.max(4, Math.floor(options.rows || ROWS));
      const idleLimit = Math.max(10, Math.floor(options.idleLimit || cols * rows * 4));
      const stepLimit = Math.max(idleLimit, Math.floor(options.stepLimit || cols * rows * 10));
      const rewardConfig = options.rewardConfig || {};
      const keyOf = (x, y) => `${x},${y}`;
      const normalizeDirection = (dx, dy) => {
        const length = Math.hypot(dx, dy) || 1;
        return { dx: Math.sign(dx / length), dy: Math.sign(dy / length) };
      };
      const env = {
        cols,
        rows,
        idleLimit,
        stepLimit,
        rewardConfig,
        selfCrashChain: 0,
        state: null,
        reset(){
          const centerX = Math.floor(cols / 2);
          const centerY = Math.floor(rows / 2);
          const snake = [];
          if(cols >= 5){
            snake.push({ x: centerX - 2, y: centerY }, { x: centerX - 1, y: centerY }, { x: centerX, y: centerY });
          } else if(cols >= 3){
            snake.push({ x: centerX - 1, y: centerY }, { x: centerX, y: centerY });
          } else {
            snake.push({ x: centerX, y: centerY });
          }
          snake.reverse();
          const snakeSet = new Set(snake.map(part => keyOf(part.x, part.y)));
          this.state = {
            snake,
            snakeSet,
            fruit: { x: -1, y: -1 },
            direction: { dx: 1, dy: 0 },
            steps: 0,
            idleSteps: 0,
            apples: 0,
            prevFruitDistance: Infinity
          };
          this.state.fruit = this.spawnFruit();
          if(this.state.fruit && this.state.fruit.x >= 0){
            const head = this.state.snake[0];
            this.state.prevFruitDistance = Math.abs(head.x - this.state.fruit.x) + Math.abs(head.y - this.state.fruit.y);
          }
        },
        spawnFruit(){
          const free = [];
          const blocked = this.state?.snakeSet ?? new Set();
          for(let y = 0; y < rows; y++){
            for(let x = 0; x < cols; x++){
              if(!blocked.has(keyOf(x, y))){
                free.push({ x, y });
              }
            }
          }
          return free.length ? free[(Math.random() * free.length) | 0] : { x: -1, y: -1 };
        },
        getMoves(){
          const moves = [];
          const state = this.state;
          const head = state.snake[0];
          const tail = state.snake.length > 1 ? state.snake[state.snake.length - 1] : null;
          for(let i = 0; i < DIRS.length; i++){
            const dir = DIRS[i];
            const nx = head.x + dir.dx;
            const ny = head.y + dir.dy;
            const ate = state.fruit && state.fruit.x === nx && state.fruit.y === ny;
            const isTailStep = tail && nx === tail.x && ny === tail.y;
            const hitsBody = state.snakeSet.has(keyOf(nx, ny)) && !(isTailStep && !ate);
            const outOfBounds = nx < 0 || nx >= cols || ny < 0 || ny >= rows;
            moves.push({
              x: nx,
              y: ny,
              dirIndex: i,
              ate,
              outOfBounds,
              hitsBody
            });
          }
          return moves;
        },
        getSafeMoves(moves){
          return moves.filter(move => !move.outOfBounds && !move.hitsBody);
        },
        getWallDistance(point){
          if(!point) return 0;
          const dxLeft = point.x;
          const dxRight = this.cols - 1 - point.x;
          const dyTop = point.y;
          const dyBottom = this.rows - 1 - point.y;
          return Math.min(dxLeft, dxRight, dyTop, dyBottom);
        },
        buildObservation(moves){
          const state = this.state;
          const head = state.snake[0];
          if(!head) return [1, 1, 1, 0, 0, 1, 0, 0, 0];
          const direction = state.direction || { dx: 1, dy: 0 };
          const candidateMoves = Array.isArray(moves) ? moves : [];
          const safeSet = new Set(candidateMoves.map(move => move.dirIndex));
          const dirIndex = (vector) => {
            const key = `${vector.dx},${vector.dy}`;
            return Object.prototype.hasOwnProperty.call(DIR_TO_INDEX, key) ? DIR_TO_INDEX[key] : DIR_TO_INDEX['1,0'];
          };
          const frontDir = dirIndex(direction);
          const leftDir = dirIndex({ dx: direction.dy, dy: -direction.dx });
          const rightDir = dirIndex({ dx: -direction.dy, dy: direction.dx });
          const fruitDX = state.fruit && state.fruit.x >= 0 ? Math.sign(state.fruit.x - head.x) : 0;
          const fruitDY = state.fruit && state.fruit.y >= 0 ? Math.sign(state.fruit.y - head.y) : 0;
          const freeCells = this.cols * this.rows - state.snake.length;
          const freeBucket = Math.min(3, Math.floor(freeCells / Math.max(1, Math.floor((this.cols * this.rows) / 4))));
          return [
            safeSet.has(frontDir) ? 0 : 1,
            safeSet.has(leftDir) ? 0 : 1,
            safeSet.has(rightDir) ? 0 : 1,
            fruitDX,
            fruitDY,
            direction.dx,
            direction.dy,
            freeBucket,
            0
          ];
        },
        applyMove(move){
          const state = this.state;
          const head = state.snake[0];
          if(move.outOfBounds){
            return { crash: true, crashType: 'wall', ate: false, win: false, done: true };
          }
          const tail = state.snake.length > 1 ? state.snake[state.snake.length - 1] : null;
          const key = keyOf(move.x, move.y);
          const isTailStep = tail && move.x === tail.x && move.y === tail.y;
          if(state.snakeSet.has(key) && !(isTailStep && !move.ate)){
            return { crash: true, crashType: 'self', ate: false, win: false, done: true };
          }
          if(!move.ate){
            const removed = state.snake.pop();
            state.snakeSet.delete(keyOf(removed.x, removed.y));
          } else {
            state.apples += 1;
          }
          state.snake.unshift({ x: move.x, y: move.y });
          state.snakeSet.add(key);
          const dx = move.x - head.x;
          const dy = move.y - head.y;
          state.direction = normalizeDirection(dx, dy);
          state.steps += 1;
          if(move.ate){
            state.idleSteps = 0;
            state.fruit = this.spawnFruit();
          } else {
            state.idleSteps += 1;
          }
          if(state.fruit && state.fruit.x >= 0){
            const newHead = state.snake[0];
            state.prevFruitDistance = Math.abs(newHead.x - state.fruit.x) + Math.abs(newHead.y - state.fruit.y);
          } else {
            state.prevFruitDistance = Infinity;
          }
          const filled = state.snake.length === this.cols * this.rows;
          return { crash: false, crashType: null, ate: move.ate, win: filled, done: filled };
        }
      };
      env.reset();
      return env;
    }
    async function runBackgroundTrainingEpisode({ agent, contextId, environment, rewardConfig, stepDelay = 0, signal }){
      const env = environment;
      env.reset();
      agent.startEpisode(contextId);
      let outcome = null;
      while(true){
        if(signal?.aborted){
          agent.endEpisode(contextId);
          return null;
        }
        const moves = env.getMoves();
        const safeMoves = env.getSafeMoves(moves);
        const candidates = safeMoves.length ? safeMoves : moves;
        const observation = env.buildObservation(candidates);
        const stateKey = observation.join('|');
        let decision = agent.decide(observation, candidates);
        let selected = decision ? candidates.find(move => move.dirIndex === decision.actionIdx) : null;
        if(!selected){
          selected = candidates[(Math.random() * candidates.length) | 0];
          if(decision){
            decision = { ...decision, actionIdx: selected.dirIndex };
          } else {
            decision = { stateKey, actionIdx: selected.dirIndex };
          }
        }
        const prevKey = decision.stateKey || stateKey;
        const actionIdx = decision.actionIdx;
        const headBefore = env.state.snake[0];
        const fruitDistanceBefore = env.state.fruit && env.state.fruit.x >= 0
          ? Math.abs(headBefore.x - env.state.fruit.x) + Math.abs(headBefore.y - env.state.fruit.y)
          : Infinity;
        const wallBefore = env.getWallDistance(headBefore);
        const result = env.applyMove(selected);
        let reward = Number.isFinite(rewardConfig.stepPenalty) ? rewardConfig.stepPenalty : 0;
        if(result.crash){
          const penaltyKey = result.crashType === 'wall' ? 'wallCrashPenalty' : 'selfCrashPenalty';
          let penalty = rewardConfig[penaltyKey];
          if(!Number.isFinite(penalty)){
            penalty = Number.isFinite(rewardConfig.deathPenalty) ? rewardConfig.deathPenalty : -5;
          }
          if(result.crashType === 'self'){
            env.selfCrashChain = Math.min((env.selfCrashChain || 0) + 1, 6);
            if(Number.isFinite(penalty)){
              const streak = Math.min(Math.max(env.selfCrashChain - 1, 0), 6);
              const streakMultiplier = 1 + streak * 0.35;
              penalty *= streakMultiplier;
            }
          } else {
            env.selfCrashChain = 0;
          }
          reward += penalty;
          outcome = result.crashType === 'wall' ? 'wall-crash' : 'self-crash';
        } else {
          if(result.ate){
            reward += Number.isFinite(rewardConfig.fruitReward) ? rewardConfig.fruitReward : 0;
          } else if(env.state.fruit && env.state.fruit.x >= 0 && Number.isFinite(rewardConfig.fruitApproachReward)){
            const headAfter = env.state.snake[0];
            const fruitDistanceAfter = Math.abs(headAfter.x - env.state.fruit.x) + Math.abs(headAfter.y - env.state.fruit.y);
            const delta = fruitDistanceBefore - fruitDistanceAfter;
            if(delta !== 0){
              reward += rewardConfig.fruitApproachReward * delta;
            }
          }
          if(Number.isFinite(rewardConfig.wallDistanceReward)){
            const wallAfter = env.getWallDistance(env.state.snake[0]);
            reward += rewardConfig.wallDistanceReward * (wallAfter - wallBefore);
          }
          if(result.win){
            env.selfCrashChain = 0;
            reward += Number.isFinite(rewardConfig.winBonus) ? rewardConfig.winBonus : 0;
            outcome = 'win';
          }
        }
        let done = !!result.done || !!result.crash;
        if(!done){
          if(env.state.idleSteps >= env.idleLimit){
            const loopPenalty = Number.isFinite(rewardConfig.loopPenalty)
              ? rewardConfig.loopPenalty
              : (Number.isFinite(rewardConfig.deathPenalty) ? rewardConfig.deathPenalty : -5);
            reward += loopPenalty;
            outcome = 'stalled';
            done = true;
            env.selfCrashChain = 0;
          } else if(env.state.steps >= env.stepLimit){
            const timeoutPenalty = Number.isFinite(rewardConfig.deathPenalty) ? rewardConfig.deathPenalty : -5;
            reward += timeoutPenalty;
            outcome = 'timeout';
            done = true;
            env.selfCrashChain = 0;
          }
        }
        const nextMoves = done ? null : env.getMoves();
        const nextSafeMoves = done ? null : env.getSafeMoves(nextMoves);
        const nextObservation = done
          ? null
          : env.buildObservation(nextSafeMoves && nextSafeMoves.length ? nextSafeMoves : nextMoves);
        agent.learn(prevKey, actionIdx, reward, nextObservation, done, contextId);
        if(done){
          const terminalOutcome = outcome || 'loss';
          if(terminalOutcome){
            agent.registerTerminal(terminalOutcome, contextId);
          }
          agent.endEpisode(contextId);
          return {
            outcome: terminalOutcome,
            steps: env.state.steps,
            apples: env.state.apples,
            contextId
          };
        }
        if(stepDelay > 0){
          await new Promise(resolve => setTimeout(resolve, stepDelay));
        } else if(env.state.steps % 400 === 0){
          await new Promise(resolve => setTimeout(resolve, 0));
        }
      }
    }
    function createNeuralRlModule(config = {}){
      if(typeof tf === 'undefined' || !tf?.sequential){
        throw new Error('TensorFlow.js is required for neural RL modules.');
      }
      const observationSize = 9;
      const actionSize = DIRS.length;
      const hiddenUnits = Math.max(16, Math.floor(config.ppoHiddenUnits || 128));
      const initializer = config.ppoInitializer || 'glorotUniform';
      const actor = tf.sequential();
      actor.add(tf.layers.dense({
        units: hiddenUnits,
        activation: 'relu',
        inputShape: [observationSize],
        kernelInitializer: initializer,
        biasInitializer: 'zeros'
      }));
      actor.add(tf.layers.dense({
        units: hiddenUnits,
        activation: 'relu',
        kernelInitializer: initializer,
        biasInitializer: 'zeros'
      }));
      actor.add(tf.layers.dense({
        units: actionSize,
        activation: 'linear',
        kernelInitializer: initializer,
        biasInitializer: 'zeros'
      }));
      const critic = tf.sequential();
      critic.add(tf.layers.dense({
        units: hiddenUnits,
        activation: 'relu',
        inputShape: [observationSize],
        kernelInitializer: initializer,
        biasInitializer: 'zeros'
      }));
      critic.add(tf.layers.dense({
        units: hiddenUnits,
        activation: 'relu',
        kernelInitializer: initializer,
        biasInitializer: 'zeros'
      }));
      critic.add(tf.layers.dense({
        units: 1,
        activation: 'linear',
        kernelInitializer: initializer,
        biasInitializer: 'zeros'
      }));
      return { actor, critic, observationSize, actionSize };
    }
    function createPpoAgent(config = {}){
      const nowMs = () => (typeof performance !== 'undefined' && typeof performance.now === 'function')
        ? performance.now()
        : Date.now();
      if(typeof tf === 'undefined' || !tf?.train){
        console.warn('TensorFlow.js not detected ‚Äì PPO agent disabled.');
        const unavailableAgent = {
          available: false,
          unavailableReason: 'TensorFlow.js was not detected, so PPO training is unavailable.',
          decide(){ return null; },
          learn(){},
          startEpisode(){},
          endEpisode(){},
          registerTerminal(){},
          setHyperparameters(){},
          resetEpsilon(){},
          async exportData(){ return { method: 'ppo', warning: 'TensorFlow.js unavailable' }; },
          async importData(){ return false; },
          resetLearning(){},
          chooseMove(){ return null; },
          getStats(){
            return {
              epsilon: 0,
              episodes: 0,
              lastEpisodeReward: 0,
              averageReward: 0,
              lastEpisodeDuration: 0,
              averageEpisodeDuration: 0,
              lastEpisodeDeaths: 0,
              averageDeaths: 0,
              completedEpisodes: 0,
              alpha: 0,
              gamma: typeof config.gamma === 'number' ? config.gamma : 0.99,
              epsilonMin: 0,
              epsilonDecay: 0,
              stateCount: 0,
              outcomes: {},
              totalOutcomes: 0
            };
          },
          async startTraining(){ return { warning: 'PPO unavailable without TensorFlow.js' }; }
        };
        return unavailableAgent;
      }
      let { actor, critic, observationSize, actionSize } = createNeuralRlModule(config);
      let optimizer = tf.train.adam(typeof config.ppoLearningRate === 'number' && config.ppoLearningRate > 0 ? config.ppoLearningRate : 0.0005);
      const outcomeCounts = Object.create(null);
      let totalOutcomes = 0;
      let episodes = 0;
      let episodeReward = 0;
      let totalReward = 0;
      let lastEpisodeReward = 0;
      let episodeStartTime = null;
      let lastEpisodeDuration = 0;
      let totalEpisodeDuration = 0;
      let currentEpisodeDeaths = 0;
      let lastEpisodeDeaths = 0;
      let totalEpisodeDeaths = 0;
      let completedEpisodes = 0;
      let episodeTransitions = [];
      function rebuildNetworks(){
        if(actor){ actor.dispose(); }
        if(critic){ critic.dispose(); }
        const rebuilt = createNeuralRlModule(config);
        actor = rebuilt.actor;
        critic = rebuilt.critic;
        observationSize = rebuilt.observationSize;
        actionSize = rebuilt.actionSize;
      }
      function rebuildOptimizer(){
        const lr = typeof config.ppoLearningRate === 'number' && config.ppoLearningRate > 0 ? config.ppoLearningRate : 0.0005;
        if(typeof optimizer?.dispose === 'function'){
          optimizer.dispose();
        }
        optimizer = tf.train.adam(lr);
      }
      function computeValue(observation){
        if(!Array.isArray(observation)) return 0;
        return tf.tidy(() => {
          const input = tf.tensor2d([observation], [1, observationSize]);
          const result = critic.apply(input);
          const value = result.dataSync()[0];
          return Number.isFinite(value) ? value : 0;
        });
      }
      function samplePolicy(observation, moves){
        return tf.tidy(() => {
          const state = tf.tensor2d([observation], [1, observationSize]);
          let logits = actor.apply(state);
          const allowed = new Set(Array.isArray(moves) && moves.length ? moves.map(m => m.dirIndex) : DIRS.map((_, idx) => idx));
          if(allowed.size && allowed.size < actionSize){
            const maskValues = new Float32Array(actionSize).fill(-1e9);
            allowed.forEach(idx => { maskValues[idx] = 0; });
            const mask = tf.tensor2d([maskValues], [1, actionSize]);
            logits = logits.add(mask);
          }
          const probsTensor = tf.softmax(logits);
          const probs = Array.from(probsTensor.dataSync());
          const valueTensor = critic.apply(state);
          const value = valueTensor.dataSync()[0];
          const allowedIndices = probs.map((_, idx) => idx).filter(idx => !allowed.size || allowed.has(idx));
          let choice = null;
          let cumulative = 0;
          const r = Math.random();
          for(const idx of allowedIndices){
            cumulative += probs[idx];
            if(r <= cumulative){
              choice = idx;
              break;
            }
          }
          if(choice === null){
            let best = allowedIndices[0] ?? 0;
            let bestProb = -Infinity;
            for(const idx of allowedIndices){
              if(probs[idx] > bestProb){
                bestProb = probs[idx];
                best = idx;
              }
            }
            choice = best;
          }
          return {
            actionIdx: choice,
            logProb: Math.log(Math.max(probs[choice], 1e-8)),
            value: Number.isFinite(value) ? value : 0,
            policy: probs
          };
        });
      }
      function normalizeAdvantages(values){
        return tf.tidy(() => {
          const tensor = tf.tensor1d(values, 'float32');
          const moments = tf.moments(tensor);
          const normalized = tensor.sub(moments.mean).div(moments.variance.add(1e-8).sqrt());
          return normalized;
        });
      }
      function performPpoUpdate(){
        if(!episodeTransitions.length) return;
        const gamma = typeof config.gamma === 'number' ? config.gamma : 0.99;
        const lambda = typeof config.ppoLambda === 'number' ? config.ppoLambda : 0.95;
        const clipRange = typeof config.ppoClip === 'number' ? config.ppoClip : 0.2;
        const entropyCoeff = typeof config.ppoEntropyCoeff === 'number' ? config.ppoEntropyCoeff : 0.01;
        const valueCoeff = typeof config.ppoValueCoeff === 'number' ? config.ppoValueCoeff : 0.5;
        const epochs = Math.max(1, Math.round(config.ppoEpochs || 4));
        const batchSize = Math.max(8, Math.round(config.ppoBatchSize || 64));
        const returns = new Array(episodeTransitions.length);
        const advantages = new Array(episodeTransitions.length);
        let gae = 0;
        for(let i = episodeTransitions.length - 1; i >= 0; i--){
          const transition = episodeTransitions[i];
          const reward = Number(transition.reward) || 0;
          const nextValue = transition.done ? 0 : (Number(transition.nextValue) || 0);
          const delta = reward + gamma * nextValue - transition.value;
          gae = delta + gamma * lambda * (transition.done ? 0 : gae);
          advantages[i] = gae;
          returns[i] = gae + transition.value;
        }
        const statesTensor = tf.tensor2d(episodeTransitions.map(t => t.state), [episodeTransitions.length, observationSize]);
        const actionsTensor = tf.tensor1d(episodeTransitions.map(t => t.action), 'int32');
        const oldLogProbsTensor = tf.tensor1d(episodeTransitions.map(t => t.logProb), 'float32');
        const returnsTensor = tf.tensor1d(returns, 'float32');
        const advantagesTensor = normalizeAdvantages(advantages);
        const indices = [...episodeTransitions.keys()];
        for(let epoch = 0; epoch < epochs; epoch++){
          tf.util.shuffle(indices);
          for(let start = 0; start < indices.length; start += batchSize){
            const batchIdx = indices.slice(start, Math.min(start + batchSize, indices.length));
            const result = optimizer.minimize(() => {
              return tf.tidy(() => {
                const idxTensor = tf.tensor1d(batchIdx, 'int32');
                const batchStates = tf.gather(statesTensor, idxTensor);
                const batchActions = tf.gather(actionsTensor, idxTensor);
                const batchOldLogProbs = tf.gather(oldLogProbsTensor, idxTensor);
                const batchAdvantages = tf.gather(advantagesTensor, idxTensor);
                const batchReturns = tf.gather(returnsTensor, idxTensor);
                const logits = actor.apply(batchStates, { training: true });
                const logProbs = tf.logSoftmax(logits);
                const actionMask = tf.oneHot(batchActions, actionSize);
                const selectedLogProbs = tf.sum(actionMask.mul(logProbs), 1);
                const ratios = tf.exp(selectedLogProbs.sub(batchOldLogProbs));
                const clipped = tf.clipByValue(ratios, 1 - clipRange, 1 + clipRange);
                const surrogate1 = ratios.mul(batchAdvantages);
                const surrogate2 = clipped.mul(batchAdvantages);
                const policyLoss = tf.neg(tf.minimum(surrogate1, surrogate2).mean());
                const values = critic.apply(batchStates, { training: true }).reshape([-1]);
                const valueLoss = tf.mean(tf.square(batchReturns.sub(values))).mul(valueCoeff);
                const probs = tf.exp(logProbs);
                const entropy = tf.neg(probs.mul(logProbs).sum(1).mean());
                const loss = policyLoss.add(valueLoss).sub(entropy.mul(entropyCoeff));
                idxTensor.dispose();
                return loss;
              });
            }, false);
            result?.dispose?.();
          }
        }
        statesTensor.dispose();
        actionsTensor.dispose();
        oldLogProbsTensor.dispose();
        returnsTensor.dispose();
        advantagesTensor.dispose();
        episodeTransitions = [];
      }
      const agent = {
        available: true,
        decide(observation, moves){
          if(!Array.isArray(observation)) return null;
          const decision = samplePolicy(observation, moves);
          if(!decision) return null;
          return {
            actionIdx: decision.actionIdx,
            logProb: decision.logProb,
            value: decision.value,
            state: observation.slice(),
            policy: decision.policy
          };
        },
        learn(decision, reward, nextObservation, done){
          if(!decision) return;
          const normalizedReward = Number.isFinite(reward) ? reward : 0;
          const nextValue = done ? 0 : computeValue(nextObservation);
          episodeTransitions.push({
            state: decision.state.slice(),
            action: decision.actionIdx,
            logProb: decision.logProb,
            value: decision.value,
            reward: normalizedReward,
            nextValue,
            done: !!done
          });
          episodeReward += normalizedReward;
        },
        startEpisode(){
          episodeTransitions = [];
          episodeReward = 0;
          episodeStartTime = nowMs();
          currentEpisodeDeaths = 0;
        },
        endEpisode(){
          const finishedAt = nowMs();
          const duration = episodeStartTime ? finishedAt - episodeStartTime : 0;
          if(duration > 0){
            lastEpisodeDuration = duration;
            totalEpisodeDuration += duration;
          } else {
            lastEpisodeDuration = 0;
          }
          episodeStartTime = null;
          performPpoUpdate();
          totalReward += episodeReward;
          lastEpisodeReward = episodeReward;
          lastEpisodeDeaths = currentEpisodeDeaths;
          totalEpisodeDeaths += currentEpisodeDeaths;
          episodes++;
          episodeReward = 0;
          currentEpisodeDeaths = 0;
        },
        registerTerminal(outcome){
          if(typeof outcome !== 'string') return;
          const key = outcome.trim().toLowerCase();
          if(!key) return;
          const fatal = new Set(['loss', 'timeout', 'wall-crash', 'self-crash', 'dead-end-crash']);
          if(fatal.has(key)){
            currentEpisodeDeaths += 1;
          } else if(key === 'win'){
            completedEpisodes += 1;
          }
          outcomeCounts[key] = (outcomeCounts[key] || 0) + 1;
          totalOutcomes++;
        },
        setHyperparameters(values){
          if(!values || typeof values !== 'object') return;
          let optimizerChanged = false;
          if(typeof values.gamma === 'number') config.gamma = values.gamma;
          if(typeof values.ppoLearningRate === 'number'){ config.ppoLearningRate = values.ppoLearningRate; optimizerChanged = true; }
          if(typeof values.ppoClip === 'number') config.ppoClip = values.ppoClip;
          if(typeof values.ppoLambda === 'number') config.ppoLambda = values.ppoLambda;
          if(typeof values.ppoEntropyCoeff === 'number') config.ppoEntropyCoeff = values.ppoEntropyCoeff;
          if(typeof values.ppoValueCoeff === 'number') config.ppoValueCoeff = values.ppoValueCoeff;
          if(typeof values.ppoEpochs === 'number') config.ppoEpochs = values.ppoEpochs;
          if(typeof values.ppoBatchSize === 'number') config.ppoBatchSize = values.ppoBatchSize;
          if(optimizerChanged){
            rebuildOptimizer();
          }
        },
        resetEpsilon(){},
        async exportData(){
          const serialize = async (model) => {
            const weights = model.getWeights();
            const payload = [];
            for(const tensor of weights){
              const data = await tensor.data();
              payload.push({ shape: tensor.shape, data: Array.from(data) });
            }
            return payload;
          };
          return {
            version: 1,
            method: 'ppo',
            hyperparameters: {
              gamma: config.gamma,
              ppoLearningRate: config.ppoLearningRate,
              ppoClip: config.ppoClip,
              ppoLambda: config.ppoLambda,
              ppoEntropyCoeff: config.ppoEntropyCoeff,
              ppoValueCoeff: config.ppoValueCoeff,
              ppoEpochs: config.ppoEpochs,
              ppoBatchSize: config.ppoBatchSize
            },
            stats: {
              episodes,
              episodeReward,
              totalReward,
              lastEpisodeReward,
              lastEpisodeDuration,
              totalEpisodeDuration,
              currentEpisodeDeaths,
              lastEpisodeDeaths,
              totalEpisodeDeaths,
              totalOutcomes,
              completedEpisodes
            },
            outcomes: { ...outcomeCounts },
            actor: await serialize(actor),
            critic: await serialize(critic)
          };
        },
        async importData(snapshot = {}){
          if(!snapshot || typeof snapshot !== 'object') return false;
          if(snapshot.method && snapshot.method !== 'ppo') return false;
          const assign = async (model, payload) => {
            if(!Array.isArray(payload)) return;
            const tensors = payload.map(entry => {
              if(!entry || !Array.isArray(entry.shape) || !Array.isArray(entry.data)) return null;
              return tf.tensor(entry.data, entry.shape, 'float32');
            }).filter(Boolean);
            if(!tensors.length) return;
            await model.setWeights(tensors);
            tensors.forEach(t => t.dispose());
          };
          await assign(actor, snapshot.actor || []);
          await assign(critic, snapshot.critic || []);
          this.setHyperparameters(snapshot.hyperparameters || {});
          const stats = snapshot.stats || {};
          if(Number.isFinite(stats.episodes)) episodes = stats.episodes;
          if(Number.isFinite(stats.episodeReward)) episodeReward = stats.episodeReward;
          if(Number.isFinite(stats.totalReward)) totalReward = stats.totalReward;
          if(Number.isFinite(stats.lastEpisodeReward)) lastEpisodeReward = stats.lastEpisodeReward;
          if(Number.isFinite(stats.lastEpisodeDuration)) lastEpisodeDuration = stats.lastEpisodeDuration;
          if(Number.isFinite(stats.totalEpisodeDuration)) totalEpisodeDuration = stats.totalEpisodeDuration;
          if(Number.isFinite(stats.currentEpisodeDeaths)) currentEpisodeDeaths = stats.currentEpisodeDeaths;
          if(Number.isFinite(stats.lastEpisodeDeaths)) lastEpisodeDeaths = stats.lastEpisodeDeaths;
          if(Number.isFinite(stats.totalEpisodeDeaths)) totalEpisodeDeaths = stats.totalEpisodeDeaths;
          if(Number.isFinite(stats.totalOutcomes)) totalOutcomes = stats.totalOutcomes;
          if(Number.isFinite(stats.completedEpisodes)) completedEpisodes = stats.completedEpisodes;
          for(const key in outcomeCounts){
            if(Object.prototype.hasOwnProperty.call(outcomeCounts, key)){
              delete outcomeCounts[key];
            }
          }
          if(snapshot.outcomes && typeof snapshot.outcomes === 'object'){
            for(const key of Object.keys(snapshot.outcomes)){
              const value = snapshot.outcomes[key];
              if(Number.isFinite(value)){
                outcomeCounts[key] = value;
              }
            }
          }
          episodeTransitions = [];
          return true;
        },
        resetLearning(){
          episodeTransitions = [];
          episodes = 0;
          episodeReward = 0;
          totalReward = 0;
          lastEpisodeReward = 0;
          episodeStartTime = null;
          lastEpisodeDuration = 0;
          totalEpisodeDuration = 0;
          currentEpisodeDeaths = 0;
          lastEpisodeDeaths = 0;
          totalEpisodeDeaths = 0;
          totalOutcomes = 0;
          completedEpisodes = 0;
          for(const key in outcomeCounts){
            if(Object.prototype.hasOwnProperty.call(outcomeCounts, key)){
              delete outcomeCounts[key];
            }
          }
          rebuildNetworks();
          rebuildOptimizer();
        },
        chooseMove(head, moves, options = {}){
          const observation = Array.isArray(options.observation) ? options.observation : buildRlObservation(moves);
          const decision = this.decide(observation, moves);
          if(!decision) return null;
          const match = Array.isArray(moves) ? moves.find(move => move.dirIndex === decision.actionIdx) : null;
          return match ? { x: match.x, y: match.y } : null;
        },
        getStats(){
          return {
            epsilon: 0,
            episodes,
            lastEpisodeReward,
            averageReward: episodes ? totalReward / episodes : 0,
            lastEpisodeDuration,
            averageEpisodeDuration: episodes ? totalEpisodeDuration / episodes : 0,
            lastEpisodeDeaths,
            averageDeaths: episodes ? totalEpisodeDeaths / Math.max(episodes, 1) : 0,
            completedEpisodes,
            alpha: 0,
            gamma: typeof config.gamma === 'number' ? config.gamma : 0.99,
            epsilonMin: 0,
            epsilonDecay: 0,
            stateCount: 0,
            outcomes: { ...outcomeCounts },
            totalOutcomes,
            ppoLearningRate: config.ppoLearningRate,
            ppoClip: config.ppoClip,
            ppoLambda: config.ppoLambda,
            ppoEntropyCoeff: config.ppoEntropyCoeff,
            ppoValueCoeff: config.ppoValueCoeff,
            ppoEpochs: config.ppoEpochs,
            ppoBatchSize: config.ppoBatchSize
          };
        },
        async startTraining(){
          return { warning: 'Batch auto-training for PPO is not implemented.' };
        }
      };
      return agent;
    }
    /* ===== PAGE NAVIGATION ===== */
    const navLinks = document.querySelectorAll('.nav-link');
    const pages = document.querySelectorAll('.page');
    navLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetPage = link.dataset.page;
        navLinks.forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        pages.forEach(p => p.classList.remove('active'));
        document.getElementById(`${targetPage}-page`).classList.add('active');
      });
    });
    const manualToggleBtn = document.getElementById('manualToggle');
    const manualHint = document.getElementById('manualHint');
    const themeSelect = document.getElementById('themeSelect');
    const rlToggleBtn = document.getElementById('rlToggle');
    const rlHint = document.getElementById('rlHint');
    const rlParamFieldset = document.getElementById('rlParamFieldset');
    const rlMethodSelect = document.getElementById('rlMethodSelect');
    updateRlMethodUI();
    const rlResetButton = document.getElementById('rlResetLearning');
    const autoRestartToggle = document.getElementById('autoRestartToggle');
    const timeoutSliderEl = document.getElementById('timeoutSlider');
    const timeoutValueDisplay = document.getElementById('timeoutSliderValue');
    const rlLiveMetricsEl = document.getElementById('rlLiveMetrics');
    const rlEpisodeHistoryRows = document.getElementById('rlEpisodeHistoryRows');
    const rlPanelToggleBtn = document.getElementById('rlPanelToggle');
    const rlExportButton = document.getElementById('rlExportButton');
    const rlImportButton = document.getElementById('rlImportButton');
    const rlImportFileInput = document.getElementById('rlImportFile');
    const rewardImpactSectionEl = document.getElementById('rewardImpactSection');
    const rewardImpactToggleBtn = document.getElementById('rewardImpactToggle');
    const rewardImpactContentEl = document.getElementById('rewardImpactContent');
    const rlConfigSectionEl = document.querySelector('.rl-config-section');
    const rlParamContentEl = document.getElementById('rlParamContent');
    const gridSizeSectionEl = document.getElementById('gridSizeSection');
    const gridSizeToggleBtn = document.getElementById('gridSizeToggle');
    const gridSizeContentEl = document.getElementById('gridSizeContent');
    const canvasSizeSectionEl = document.getElementById('canvasSizeSection');
    const canvasSizeToggleBtn = document.getElementById('canvasSizeToggle');
    const canvasSizeContentEl = document.getElementById('canvasSizeContent');
    const aiParamsSectionEl = document.getElementById('aiParamsSection');
    const aiParamsToggleBtn = document.getElementById('aiParamsToggle');
    const aiParamsContentEl = document.getElementById('aiParamsContent');
    const gameStatusSectionEl = document.getElementById('gameStatusSection');
    const gameStatusToggleBtn = document.getElementById('gameStatusToggle');
    const gameStatusContentEl = document.getElementById('gameStatusContent');
    const aiStatusSectionEl = document.getElementById('aiStatusSection');
    const aiStatusToggleBtn = document.getElementById('aiStatusToggle');
    const aiStatusContentEl = document.getElementById('aiStatusContent');
    const helpOverlayEl = document.getElementById('helpOverlay');
    const helpCloseBtn = document.getElementById('helpCloseBtn');
    if (helpCloseBtn && helpOverlayEl) {
      helpCloseBtn.addEventListener('click', () => {
        helpOverlayEl.hidden = true;
      });
    }

    if(themeSelect){
      themeSelect.value = currentThemeKey;
      themeSelect.addEventListener('change', (event) => {
        const selected = event.target.value;
        applyTheme(selected, { persist: true });
        draw();
      });
    }
    const RL_CONTROL_BINDINGS = [
      { id: 'rlStepPenalty', valueId: 'rlStepPenaltyValue', key: 'stepPenalty', parser: parseFloat, format: v => v.toFixed(2) },
      { id: 'rlFruitReward', valueId: 'rlFruitRewardValue', key: 'fruitReward', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlFruitApproach', valueId: 'rlFruitApproachValue', key: 'fruitApproachReward', parser: parseFloat, format: v => v.toFixed(2) },
      { id: 'rlWinBonus', valueId: 'rlWinBonusValue', key: 'winBonus', parser: parseFloat, format: v => v.toFixed(0) },
      { id: 'rlBestTimeBonus', valueId: 'rlBestTimeBonusValue', key: 'bestTimeBonus', parser: parseFloat, format: v => v.toFixed(0) },
      { id: 'rlEndgameReward', valueId: 'rlEndgameRewardValue', key: 'endgamePlanReward', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlCompactReward', valueId: 'rlCompactRewardValue', key: 'compactModeReward', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlPocketReward', valueId: 'rlPocketRewardValue', key: 'pocketFillReward', parser: parseFloat, format: v => v.toFixed(2) },
      { id: 'rlWallDistance', valueId: 'rlWallDistanceValue', key: 'wallDistanceReward', parser: parseFloat, format: v => v.toFixed(2) },
      { id: 'rlWallCrashPenalty', valueId: 'rlWallCrashPenaltyValue', key: 'wallCrashPenalty', parser: parseFloat, format: v => v.toFixed(0) },
      { id: 'rlSelfCrashPenalty', valueId: 'rlSelfCrashPenaltyValue', key: 'selfCrashPenalty', parser: parseFloat, format: v => v.toFixed(0) },
      { id: 'rlDeathPenalty', valueId: 'rlDeathPenaltyValue', key: 'deathPenalty', parser: parseFloat, format: v => v.toFixed(0) },
      { id: 'rlDeadEndPenalty', valueId: 'rlDeadEndPenaltyValue', key: 'deadEndPenalty', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlLoopPenalty', valueId: 'rlLoopPenaltyValue', key: 'loopPenalty', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlAlpha', valueId: 'rlAlphaValue', key: 'alpha', parser: parseFloat, format: v => v.toFixed(2), onChange: v => { if(rlMethod === 'tabular'){ rlAgent.setHyperparameters({ alpha: v }); } } },
      { id: 'rlGamma', valueId: 'rlGammaValue', key: 'gamma', parser: parseFloat, format: v => v.toFixed(2), onChange: v => rlAgent.setHyperparameters({ gamma: v }) },
      { id: 'rlEpsilonStart', valueId: 'rlEpsilonStartValue', key: 'epsilonStart', parser: parseFloat, format: v => v.toFixed(2), onChange: v => { if(rlMethod === 'tabular'){ rlAgent.setHyperparameters({ epsilonStart: v }); rlAgent.resetEpsilon(v); } } },
      { id: 'rlEpsilonMin', valueId: 'rlEpsilonMinValue', key: 'epsilonMin', parser: parseFloat, format: v => v.toFixed(2), onChange: v => { if(rlMethod === 'tabular'){ rlAgent.setHyperparameters({ epsilonMin: v }); } } },
      { id: 'rlEpsilonDecay', valueId: 'rlEpsilonDecayValue', key: 'epsilonDecay', parser: parseFloat, format: v => v.toFixed(3), onChange: v => { if(rlMethod === 'tabular'){ rlAgent.setHyperparameters({ epsilonDecay: v }); } } },
      { id: 'rlPpoLr', valueId: 'rlPpoLrValue', key: 'ppoLearningRate', parser: parseFloat, format: v => v.toFixed(5), onChange: v => { if(rlMethod === 'ppo'){ rlAgent.setHyperparameters({ ppoLearningRate: v }); } } },
      { id: 'rlPpoClip', valueId: 'rlPpoClipValue', key: 'ppoClip', parser: parseFloat, format: v => v.toFixed(2), onChange: v => { if(rlMethod === 'ppo'){ rlAgent.setHyperparameters({ ppoClip: v }); } } },
      { id: 'rlPpoLambda', valueId: 'rlPpoLambdaValue', key: 'ppoLambda', parser: parseFloat, format: v => v.toFixed(2), onChange: v => { if(rlMethod === 'ppo'){ rlAgent.setHyperparameters({ ppoLambda: v }); } } },
      { id: 'rlPpoEntropy', valueId: 'rlPpoEntropyValue', key: 'ppoEntropyCoeff', parser: parseFloat, format: v => v.toFixed(3), onChange: v => { if(rlMethod === 'ppo'){ rlAgent.setHyperparameters({ ppoEntropyCoeff: v }); } } },
      { id: 'rlPpoValueCoeff', valueId: 'rlPpoValueCoeffValue', key: 'ppoValueCoeff', parser: parseFloat, format: v => v.toFixed(2), onChange: v => { if(rlMethod === 'ppo'){ rlAgent.setHyperparameters({ ppoValueCoeff: v }); } } },
      { id: 'rlPpoEpochs', valueId: 'rlPpoEpochsValue', key: 'ppoEpochs', parser: value => Math.max(1, Math.round(Number(value) || 1)), format: v => Math.round(v), onChange: v => { if(rlMethod === 'ppo'){ rlAgent.setHyperparameters({ ppoEpochs: v }); } } },
      { id: 'rlPpoBatchSize', valueId: 'rlPpoBatchSizeValue', key: 'ppoBatchSize', parser: value => Math.max(8, Math.round(Number(value) || 8)), format: v => Math.round(v), onChange: v => { if(rlMethod === 'ppo'){ rlAgent.setHyperparameters({ ppoBatchSize: v }); } } },
      { id: 'rlEpisodes', valueId: 'rlEpisodesValue', key: 'trainingEpisodes', parser: value => {
        const parsed = Number(value);
        if(Number.isNaN(parsed)) return 1;
        return Math.max(1, Math.round(parsed));
      }, format: v => Math.round(v), onChange: v => {
        if(rlTrainingEnabled && !autoRestartEnabled){
          rlBatchPlannedEpisodes = Math.max(1, Math.round(v));
          if(rlBatchPlannedEpisodes > 1){
            rlBatchActive = true;
            rlBatchEpisodesRemaining = rlBatchPlannedEpisodes - 1;
          } else {
            rlBatchActive = false;
            rlBatchEpisodesRemaining = 0;
          }
        }
      } },
      { id: 'rlParallelSnakes', valueId: 'rlParallelSnakesValue', key: 'parallelSnakes', parser: value => {
        const parsed = Number(value);
        if(Number.isNaN(parsed)) return 0;
        return Math.max(0, Math.min(32, Math.round(parsed)));
      }, format: v => Math.round(v), onChange: v => {
        rlConfig.parallelSnakes = v;
        if(rlTrainingEnabled && rlMethod === RL_METHODS.TABULAR){
          restartBackgroundTrainingIfActive();
        } else if(!rlTrainingEnabled){
          stopBackgroundTraining();
          backgroundTrainingStats = null;
          updateRlStatus();
        }
      } },
      { id: 'rlRewardScale', valueId: 'rlRewardScaleValue', key: 'rewardScale', parser: parseFloat, format: v => v.toFixed(1) }
    ];
    if(timeoutSliderEl){
      timeoutSliderEl.min = String(MIN_RUN_TIMEOUT_MS);
      timeoutSliderEl.max = String(MAX_RUN_TIMEOUT_MS);
      timeoutSliderEl.step = String(TIMEOUT_SLIDER_STEP_MS);
      const initialTimeout = getTimeoutSliderValue();
      if(Number.isFinite(initialTimeout)){
        updateTimeoutSliderDisplay(initialTimeout);
      } else {
        updateTimeoutSliderDisplay(MIN_RUN_TIMEOUT_MS);
      }
      timeoutSliderEl.addEventListener('input', (event) => {
        const parsed = parseInt(event.target.value, 10);
        const normalized = clampTimeoutValue(parsed);
        if(Number.isFinite(normalized)){
          if(String(normalized) !== event.target.value){
            event.target.value = normalized;
          }
          timeoutUserOverride = true;
          updateTimeoutSliderDisplay(normalized);
          if(rlTrainingEnabled){
            runTimeoutMs = normalized;
            resetRunTimeoutDeadline();
          } else {
            runTimeoutMs = null;
            resetRunTimeoutDeadline();
          }
        }
      });
    } else if(timeoutValueDisplay){
      updateTimeoutSliderDisplay(MIN_RUN_TIMEOUT_MS);
    }
    const MAX_EPISODE_HISTORY = 10;
    const rlEpisodeLog = [];
    function formatRewardValue(value){
      return Number.isFinite(value) ? value.toFixed(2) : '--';
    }
    function formatPercentage(value){
      if(!Number.isFinite(value) || value <= 0){
        return '0%';
      }
      if(value >= 10){
        return `${Math.round(value)}%`;
      }
      return `${value.toFixed(1)}%`;
    }
    function formatRewardChange(value){
      if(!Number.isFinite(value)) return '--';
      const rounded = value.toFixed(2);
      if(value > 0) return `+${rounded}`;
      if(value === 0) return '0.00';
      return rounded;
    }

    function getRlPhase(epsilon, epsilonStart, epsilonEnd){
      if(!Number.isFinite(epsilon) || !Number.isFinite(epsilonStart) || !Number.isFinite(epsilonEnd)){
        return null;
      }
      const range = epsilonStart - epsilonEnd;
      if(range <= 0){
        return epsilon <= epsilonEnd ? 'Exploiting' : 'Exploring';
      }
      const clampedEps = Math.max(Math.min(epsilon, epsilonStart), epsilonEnd);
      const progress = (epsilonStart - clampedEps) / range;
      if(progress < 0.15) return 'Warm‚Äëup';
      if(progress < 0.55) return 'Exploring';
      if(progress < 0.9) return 'Balancing';
      return 'Exploiting';
    }
    function pushRlRewardSample(stats){
      if(!stats || !Number.isFinite(stats.lastEpisodeReward)) return;
      rlRewardHistory.push(stats.lastEpisodeReward);
      if(rlRewardHistory.length > RL_REWARD_HISTORY_LIMIT){
        rlRewardHistory.splice(0, rlRewardHistory.length - RL_REWARD_HISTORY_LIMIT);
      }
    }
    function updateRlSparkline(episodeCount){
      const svg = document.getElementById('rlRewardSparkline');
      const path = document.getElementById('rlRewardSparklinePath');
      const label = document.getElementById('rlRewardTrendLabel');
      if(!svg || !path || !rlRewardHistory.length) return;
      const viewBox = svg.viewBox && svg.viewBox.baseVal
        ? svg.viewBox.baseVal
        : { x: 0, y: 0, width: 220, height: 50 };
      const width = viewBox.width || 220;
      const height = viewBox.height || 50;
      const min = Math.min(...rlRewardHistory);
      const max = Math.max(...rlRewardHistory);
      const span = max - min || 1;
      const n = rlRewardHistory.length;
      const stepX = n > 1 ? width / (n - 1) : width;
      let d = '';
      rlRewardHistory.forEach((value, index) => {
        const x = index * stepX;
        const normalized = (value - min) / span;
        const y = height - normalized * height;
        d += (index === 0 ? 'M' : ' L') + x.toFixed(2) + ',' + y.toFixed(2);
      });
      path.setAttribute('d', d);
      if(label){
        const windowSize = Math.min(RL_REWARD_HISTORY_LIMIT, rlRewardHistory.length);
        const episodesText = episodeCount && Number.isFinite(episodeCount)
          ? `${episodesTextFormatter(episodeCount)} eps`
          : 'recent episodes';
        label.textContent = `${windowSize} sample(s) ¬∑ ${episodesText}`;
      }
    }
    function episodesTextFormatter(value){
      if(!Number.isFinite(value)) return '--';
      if(value >= 1000){
        return (value / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
      }
      return value.toLocaleString();
    }
    function formatImpactTrend(diff){
      if(!Number.isFinite(diff) || Math.abs(diff) < 0.01){
        return '<span class="trend trend-flat">‚Äî</span>';
      }
      const directionClass = diff > 0 ? 'trend-up' : 'trend-down';
      const arrow = diff > 0 ? '‚ñ≤' : '‚ñº';
      return `<span class="trend ${directionClass}">${arrow} ${formatRewardChange(diff)}</span>`;
    }
    function normalizeRewardBreakdown(entries, reward, effectiveReward, scaleApplied, scaleValue){
      if(!Array.isArray(entries) || !entries.length) return [];
      const sanitized = entries
        .map(entry => ({ id: entry?.id, amount: Number(entry?.amount) }))
        .filter(entry => entry.id && RL_REWARD_COMPONENT_MAP[entry.id] && Number.isFinite(entry.amount));
      if(!sanitized.length) return [];
      let factor = 1;
      if(scaleApplied && Number.isFinite(scaleValue) && scaleValue !== 1){
        if(Number.isFinite(reward) && Math.abs(reward) > 1e-9){
          factor = effectiveReward / reward;
        } else if(Number.isFinite(effectiveReward)){
          factor = scaleValue;
        }
      }
      if(factor !== 1){
        return sanitized.map(entry => ({ id: entry.id, amount: entry.amount * factor }));
      }
      return sanitized;
    }
    function recordRewardBreakdown(entries){
      if(!Array.isArray(entries) || !entries.length) return;
      entries.forEach(entry => {
        if(!(entry.id in rlRewardEpisodeAccumulator)) return;
        const value = Number(entry.amount);
        if(!Number.isFinite(value)) return;
        rlRewardEpisodeAccumulator[entry.id] += value;
      });
    }
    function resetRewardImpactEpisode(){
      rlRewardEpisodeAccumulator = createEmptyRewardImpactSnapshot();
    }
    function resetRewardImpactStats(){
      RL_REWARD_COMPONENTS.forEach(entry => {
        rlRewardImpactStats.components[entry.id] = {
          label: entry.label,
          total: 0,
          last: 0,
          prev: 0
        };
      });
      rlRewardImpactStats.episodes = 0;
      rlRewardImpactStats.prevTotal = 0;
      rlRewardImpactStats.lastTotal = 0;
      resetRewardImpactEpisode();
      updateRewardImpactUI();
    }
    function finalizeRewardImpactEpisode(){
      rlRewardImpactStats.episodes += 1;
      let episodeTotal = 0;
      RL_REWARD_COMPONENTS.forEach(entry => {
        const stats = rlRewardImpactStats.components[entry.id];
        const amount = rlRewardEpisodeAccumulator[entry.id] ?? 0;
        stats.prev = stats.last;
        stats.last = amount;
        stats.total += amount;
        episodeTotal += amount;
      });
      rlRewardImpactStats.prevTotal = rlRewardImpactStats.lastTotal;
      rlRewardImpactStats.lastTotal = episodeTotal;
      resetRewardImpactEpisode();
      updateRewardImpactUI();
    }
    function updateRewardImpactUI(){
      const rowsContainer = document.getElementById('rlRewardImpactRows');
      const summaryEl = document.getElementById('rlRewardImpactSummary');
      if(!rowsContainer) return;
      if(rlRewardImpactStats.episodes === 0){
        const message = rlTrainingEnabled
          ? 'Play an RL episode to populate impact data.'
          : 'Enable RL to start tracking reward impact.';
        rowsContainer.innerHTML = `<p class="reward-impact-empty">${message}</p>`;
        if(summaryEl){
          summaryEl.textContent = rlTrainingEnabled
            ? 'Waiting for the first RL episode to complete.'
            : 'Reward impact stats will appear once RL training is active.';
        }
        return;
      }
      const rowsData = RL_REWARD_COMPONENTS.map(entry => {
        const stats = rlRewardImpactStats.components[entry.id];
        const average = rlRewardImpactStats.episodes > 0
          ? stats.total / rlRewardImpactStats.episodes
          : 0;
        return {
          id: entry.id,
          label: entry.label,
          last: stats.last,
          avg: average,
          diff: stats.last - stats.prev
        };
      });
      const totalAbsAvg = rowsData.reduce((sum, row) => sum + Math.abs(row.avg), 0);
      const maxShare = rowsData.reduce((max, row) => {
        const share = totalAbsAvg > 0 ? Math.abs(row.avg) / totalAbsAvg : 0;
        return Math.max(max, share);
      }, 0);
      const rowsHtml = rowsData.map(row => {
        const share = totalAbsAvg > 0 ? Math.abs(row.avg) / totalAbsAvg : 0;
        const shareText = `${Math.round(share * 100)}%`;
        const classes = ['reward-impact-row'];
        if(maxShare > 0 && Math.abs(share - maxShare) < 1e-6){
          classes.push('impact-top');
        }
        return `
          <div class="${classes.join(' ')}">
            <span>${row.label}</span>
            <span>${formatRewardValue(row.last)}</span>
            <span>${formatRewardValue(row.avg)}</span>
            <span>${shareText}</span>
            <span>${formatImpactTrend(row.diff)}</span>
          </div>
        `;
      }).join('');
      rowsContainer.innerHTML = rowsHtml;
      if(summaryEl){
        const summaryParts = [
          `Episodes tracked: ${rlRewardImpactStats.episodes}`,
          `Last total: ${formatRewardValue(rlRewardImpactStats.lastTotal)}`
        ];
        if(rlRewardImpactStats.episodes > 1){
          const delta = rlRewardImpactStats.lastTotal - rlRewardImpactStats.prevTotal;
          summaryParts.push(`Œî vs prev: ${formatRewardChange(delta)}`);
        }
        if(rlEpisodeActive){
          summaryParts.push('Current episode running‚Ä¶');
        }
        summaryEl.textContent = summaryParts.join(' ¬∑ ');
      }
    }
    function formatEpisodeDuration(ms){
      if(!Number.isFinite(ms) || ms <= 0){
        return '--';
      }
      if(ms >= 60000){
        const minutes = Math.floor(ms / 60000);
        const seconds = ((ms % 60000) / 1000).toFixed(minutes >= 10 ? 0 : 1);
        return minutes ? `${minutes}m ${seconds}s` : `${seconds}s`;
      }
      return `${(ms / 1000).toFixed(2)}s`;
    }
    function formatDeathSummary(deaths, avgDeaths){
      const deathCount = Number.isFinite(deaths) ? deaths : 0;
      const avgText = Number.isFinite(avgDeaths) ? avgDeaths.toFixed(2) : '--';
      return `${deathCount} (${avgText})`;
    }
    function renderRlEpisodeHistory(){
      if(!rlEpisodeHistoryRows) return;
      if(!rlEpisodeLog.length){
        const message = rlTrainingEnabled
          ? 'No completed RL episodes yet.'
          : 'Enable RL to start logging episodes.';
        rlEpisodeHistoryRows.innerHTML = `<p class="episode-history-empty">${message}</p>`;
        return;
      }
      const rowsHtml = rlEpisodeLog.map(entry => `
        <div class="episode-history-row">
          <span>#${entry.episode}</span>
          <span>${formatRewardValue(entry.reward)}</span>
          <span>${formatRewardValue(entry.avgReward)}</span>
          <span>${formatDeathSummary(entry.deaths, entry.avgDeaths)}</span>
          <span>${formatEpisodeDuration(entry.duration)}</span>
          <span>${formatEpisodeDuration(entry.avgDuration)}</span>
        </div>
      `).join('');
      rlEpisodeHistoryRows.innerHTML = rowsHtml;
    }
    function recordRlEpisodeSnapshot(){
      const stats = rlAgent.getStats();
      pushRlRewardSample(stats);

      if(!Number.isFinite(stats.episodes) || stats.episodes <= 0) return;
      rlEpisodeLog.unshift({
        episode: stats.episodes,
        reward: stats.lastEpisodeReward,
        avgReward: stats.averageReward,
        deaths: stats.lastEpisodeDeaths,
        avgDeaths: stats.averageDeaths,
        duration: stats.lastEpisodeDuration,
        avgDuration: stats.averageEpisodeDuration
      });
      if(rlEpisodeLog.length > MAX_EPISODE_HISTORY){
        rlEpisodeLog.length = MAX_EPISODE_HISTORY;
      }
      renderRlEpisodeHistory();
    }
    function sanitizeTrainingEpisodes(value){
      if(!Number.isFinite(value)) return 1;
      return Math.max(1, Math.round(value));
    }
    function resetRlBatchProgress(){
      rlBatchPlannedEpisodes = sanitizeTrainingEpisodes(rlConfig.trainingEpisodes);
      rlBatchActive = false;
      rlBatchEpisodesRemaining = 0;
    }
    function configureRlBatchForSession(){
      rlBatchPlannedEpisodes = sanitizeTrainingEpisodes(rlConfig.trainingEpisodes);
      if(!autoRestartEnabled && rlBatchPlannedEpisodes > 1){
        rlBatchActive = true;
        rlBatchEpisodesRemaining = rlBatchPlannedEpisodes - 1;
      } else {
        rlBatchActive = false;
        rlBatchEpisodesRemaining = 0;
      }
    }
    function cancelScheduledAutoRestart(){
      if(autoRestartTimer){
        clearTimeout(autoRestartTimer);
        autoRestartTimer = null;
      }
    }
    function handleRlEpisodeCompletion(){
      if(!rlTrainingEnabled || !rlBatchActive) return null;
      if(rlBatchEpisodesRemaining > 0){
        rlBatchEpisodesRemaining--;
        const completed = rlBatchPlannedEpisodes - (rlBatchEpisodesRemaining + 1);
        scheduleAutoRestart(450, true);
        return {
          trainingDisabled: false,
          message: `Batch training ${completed}/${rlBatchPlannedEpisodes} complete ‚Äì restarting‚Ä¶`
        };
      }
      const total = rlBatchPlannedEpisodes;
      cancelScheduledAutoRestart();
        rlTrainingEnabled = false;
        rlEpisodeActive = false;
        rlPendingChoice = null;
        syncRunTimeout();
        resetRlBatchProgress();
        stopBackgroundTraining();
        backgroundTrainingStats = null;
        return {
          trainingDisabled: true,
          message: `Completed ${total} RL episodes ‚Äì training paused.`
        };
      }
    function setupCollapsibleSection(sectionEl, buttonEl, contentEl, options = {}){
      if(!sectionEl || !buttonEl || !contentEl) return null;
      const {
        collapsed = false,
        expandedLabel = 'Hide settings',
        collapsedLabel = 'Show settings'
      } = options;
      let isCollapsed = !!collapsed;
      const labelEl = buttonEl.querySelector('.collapse-label');
      function sync(){
        sectionEl.classList.toggle('collapsed', isCollapsed);
        buttonEl.setAttribute('aria-expanded', String(!isCollapsed));
        if(labelEl){
          labelEl.textContent = isCollapsed ? collapsedLabel : expandedLabel;
        }
        contentEl.hidden = isCollapsed;
        contentEl.setAttribute('aria-hidden', String(isCollapsed));
      }
      buttonEl.addEventListener('click', () => {
        isCollapsed = !isCollapsed;
        sync();
      });
      sync();
      return {
        setCollapsed(value){
          isCollapsed = !!value;
          sync();
        },
        isCollapsed(){
          return isCollapsed;
        }
      };
    }
    setupCollapsibleSection(
      rlConfigSectionEl,
      rlPanelToggleBtn,
      rlParamContentEl,
      { collapsed: true, expandedLabel: 'Hide settings', collapsedLabel: 'Show settings' }
    );
    setupCollapsibleSection(
      rewardImpactSectionEl,
      rewardImpactToggleBtn,
      rewardImpactContentEl,
      { collapsed: true, expandedLabel: 'Hide breakdown', collapsedLabel: 'Show breakdown' }
    );
    setupCollapsibleSection(
      gridSizeSectionEl,
      gridSizeToggleBtn,
      gridSizeContentEl,
      { collapsed: true }
    );
    setupCollapsibleSection(
      canvasSizeSectionEl,
      canvasSizeToggleBtn,
      canvasSizeContentEl,
      { collapsed: true }
    );
    setupCollapsibleSection(
      aiParamsSectionEl,
      aiParamsToggleBtn,
      aiParamsContentEl,
      { collapsed: true }
    );
    setupCollapsibleSection(
      gameStatusSectionEl,
      gameStatusToggleBtn,
      gameStatusContentEl,
      { collapsed: true, expandedLabel: 'Hide status', collapsedLabel: 'Show status' }
    );
    setupCollapsibleSection(
      aiStatusSectionEl,
      aiStatusToggleBtn,
      aiStatusContentEl,
      { collapsed: true, expandedLabel: 'Hide status', collapsedLabel: 'Show status' }
    );
    updateRewardImpactUI();
    elapsedTimeEl = document.getElementById('elapsedTime');
    performanceElapsedEl = document.getElementById('performanceElapsed');
    performanceLengthEl = document.getElementById('performanceLength');
    const bestTimeEl = document.getElementById('bestTime');
    const completedRoundsEl = document.getElementById('completedRounds');
    const applesEatenEl = document.getElementById('applesEaten');
    const appleHighScoreEl = document.getElementById('appleHighScore');
    function formatTime(ms){
      if(!Number.isFinite(ms) || ms < 0) return '00:00.0';
      const totalSeconds = ms / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const tenths = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 10);
      return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${tenths}`;
    }
    function updateElapsedTimeDisplay(ms = 0){
      const formatted = formatTime(ms);
      if(elapsedTimeEl){
        elapsedTimeEl.textContent = formatted;
      }
      if(performanceElapsedEl){
        performanceElapsedEl.textContent = formatted;
      }
    }
    function updateCompletedRoundsDisplay(){
      if(completedRoundsEl){
        completedRoundsEl.textContent = completedRounds;
      }
    }
    function updateAppleStats(){
      if(applesEatenEl){
        applesEatenEl.textContent = applesEaten;
      }
      if(appleHighScoreEl){
        appleHighScoreEl.textContent = appleHighScore;
      }
    }
    function clampTimeoutValue(value){
      if(!Number.isFinite(value)) return null;
      const clamped = Math.max(MIN_RUN_TIMEOUT_MS, Math.min(MAX_RUN_TIMEOUT_MS, value));
      if(TIMEOUT_SLIDER_STEP_MS > 0){
        const stepped = Math.round(clamped / TIMEOUT_SLIDER_STEP_MS) * TIMEOUT_SLIDER_STEP_MS;
        return Math.max(MIN_RUN_TIMEOUT_MS, Math.min(MAX_RUN_TIMEOUT_MS, stepped));
      }
      return clamped;
    }
    function formatTimeoutLabel(ms){
      if(!Number.isFinite(ms) || ms <= 0) return '00:00';
      const totalSeconds = Math.round(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }
    function updateTimeoutSliderDisplay(ms){
      if(timeoutValueDisplay){
        timeoutValueDisplay.textContent = formatTimeoutLabel(ms);
      }
    }
    function getTimeoutSliderValue(){
      if(!timeoutSliderEl) return null;
      const parsed = parseInt(timeoutSliderEl.value, 10);
      return clampTimeoutValue(parsed);
    }
    function applyTimeoutToSlider(ms){
      if(!timeoutSliderEl) return;
      const normalized = clampTimeoutValue(ms);
      if(!Number.isFinite(normalized)) return;
      timeoutSliderEl.value = normalized;
      updateTimeoutSliderDisplay(normalized);
    }
    function computeRunTimeout(){
      if(!rlTrainingEnabled){
        return null;
      }
      const area = COLS * ROWS;
      if(area === 15 * 15){
        return clampTimeoutValue(5 * 60 * 1000);
      }
      const estimated = area * BASE_TIMEOUT_PER_CELL_MS;
      const limited = Math.min(DEFAULT_RUN_TIMEOUT_LIMIT_MS, estimated);
      return clampTimeoutValue(limited);
    }
    function resetRunTimeoutDeadline(){
      if(!Number.isFinite(runTimeoutMs) || runTimeoutMs <= 0){
        runTimeoutDeadline = null;
        return;
      }
      const now = performance.now();
      runTimeoutDeadline = now + runTimeoutMs;
    }
    function syncRunTimeout(){
      let targetTimeout = null;
      if(rlTrainingEnabled){
        if(timeoutUserOverride){
          const sliderValue = getTimeoutSliderValue();
          if(Number.isFinite(sliderValue)){
            targetTimeout = sliderValue;
            updateTimeoutSliderDisplay(sliderValue);
          } else {
            timeoutUserOverride = false;
          }
        }
        if(!timeoutUserOverride){
          const computed = computeRunTimeout();
          if(Number.isFinite(computed)){
            targetTimeout = computed;
            applyTimeoutToSlider(computed);
          }
        }
      } else {
        updateTimeoutSliderDisplay(getTimeoutSliderValue() ?? MIN_RUN_TIMEOUT_MS);
      }
      runTimeoutMs = Number.isFinite(targetTimeout) ? targetTimeout : null;
      resetRunTimeoutDeadline();
    }
    function updateBestTimeDisplay(){
      if(bestTimeEl){
        bestTimeEl.textContent = bestTimeMs != null ? formatTime(bestTimeMs) : '--';
      }
    }
    function cancelRunTimer(){
      if(elapsedTimerHandle){
        clearInterval(elapsedTimerHandle);
        elapsedTimerHandle = null;
      }
      startTime = null;
      lastElapsedMs = 0;
      updateElapsedTimeDisplay(0);
    }
    function startRunTimer(){
      cancelRunTimer();
      startTime = performance.now();
      elapsedTimerHandle = setInterval(() => {
        if(!gameRunning || startTime === null) return;
        lastElapsedMs = performance.now() - startTime;
        updateElapsedTimeDisplay(lastElapsedMs);
      }, 200);
    }
    function finishRun(won = false){
      if(won){
        consecutiveSelfCrashCount = 0;
      }
      if(startTime !== null){
        lastElapsedMs = performance.now() - startTime;
      }
      if(elapsedTimerHandle){
        clearInterval(elapsedTimerHandle);
        elapsedTimerHandle = null;
      }
      if(lastElapsedMs > 0){
        updateElapsedTimeDisplay(lastElapsedMs);
        if(won && (bestTimeMs === null || lastElapsedMs < bestTimeMs)){
          bestTimeMs = lastElapsedMs;
          updateBestTimeDisplay();
        }
      }
      startTime = null;
      runTimeoutDeadline = null;
    }
    updateElapsedTimeDisplay(0);
    updateBestTimeDisplay();
    syncRunTimeout();
    updateCompletedRoundsDisplay();
    const KEY_TO_DIR = {
      'arrowup': {dx: 0, dy: -1},
      'w': {dx: 0, dy: -1},
      'arrowdown': {dx: 0, dy: 1},
      's': {dx: 0, dy: 1},
      'arrowleft': {dx: -1, dy: 0},
      'a': {dx: -1, dy: 0},
      'arrowright': {dx: 1, dy: 0},
      'd': {dx: 1, dy: 0}
    };
    function updateManualUI(){
      if(!manualToggleBtn || !manualHint) return;
      if(manualMode){
        manualToggleBtn.classList.add('toggle-active');
        manualToggleBtn.textContent = 'üß† Return to AI';
        manualHint.textContent = 'Manual mode active! Use arrow keys or WASD to steer the snake.';
      } else {
        manualToggleBtn.classList.remove('toggle-active');
        manualToggleBtn.textContent = 'üïπÔ∏è Try Manual Play';
        manualHint.textContent = 'Manual mode off ‚Äì AI is playing automatically.';
      }
    }
    function setInitialManualDirection(){
      if(snake.length > 1){
        manualDirection = {
          dx: snake[0].x - snake[1].x,
          dy: snake[0].y - snake[1].y
        };
      } else {
        manualDirection = {dx: 1, dy: 0};
      }
      pendingManualDirection = null;
    }
    function setManualDirection(dx, dy){
      const current = pendingManualDirection || manualDirection;
      if(current.dx === -dx && current.dy === -dy) return;
      pendingManualDirection = {dx, dy};
    }
    function toggleManualMode(){
      manualMode = !manualMode;
      if(manualMode){
        setInitialManualDirection();
        currentStrategy = 'Manual control';
      } else {
        pendingManualDirection = null;
      }
      updateManualUI();
    }
    function updateRlToggleUI(){
      if(!rlToggleBtn || !rlHint) return;
      const agentUnavailable = rlMethod === RL_METHODS.PPO && rlAgent && rlAgent.available === false;
      if(rlTrainingEnabled){
        rlToggleBtn.classList.add('toggle-active');
        rlToggleBtn.textContent = 'ü§ñ RL Training On';
        rlToggleBtn.disabled = false;
        const stats = rlAgent.getStats();
        rlHint.textContent = `RL is learning live ‚Äì episodes: ${stats.episodes}`;
      } else {
        rlToggleBtn.classList.remove('toggle-active');
        rlToggleBtn.disabled = agentUnavailable;
        rlToggleBtn.textContent = agentUnavailable
          ? 'ü§ñ PPO unavailable'
          : 'ü§ñ Enable Reinforcement Learning';
        if(agentUnavailable){
          rlHint.textContent = rlHintOverride || rlAgent?.unavailableReason || 'PPO training is unavailable because TensorFlow.js did not load.';
        } else {
          rlHint.textContent = rlHintOverride || 'Reinforcement learning is currently disabled.';
        }
      }
      if(rlParamFieldset){
        const disableParams = !rlTrainingEnabled || agentUnavailable;
        rlParamFieldset.disabled = disableParams;
        rlParamFieldset.classList.toggle('inactive', disableParams);
      }
      if(autoRestartToggle){
        autoRestartToggle.checked = autoRestartEnabled;
        autoRestartToggle.disabled = !rlTrainingEnabled || agentUnavailable;
      }
      updateRlLiveMetrics();
      updateRlMethodUI();
      renderRlEpisodeHistory();
      updateRewardImpactUI();
    }
    function updateRlMethodUI(){
      if(rlParamFieldset){
        rlParamFieldset.setAttribute('data-active-method', rlMethod);
      }
      if(rlMethodSelect){
        rlMethodSelect.value = rlMethod;
      }
    }
    function setRlMethod(method){
      const normalized = method === RL_METHODS.PPO ? RL_METHODS.PPO : RL_METHODS.TABULAR;
      if(normalized === rlMethod && rlAgent === rlAgents[normalized]){
        rlConfig.method = normalized;
        updateRlMethodUI();
        return;
      }
      if(rlEpisodeActive){
        rlAgent.endEpisode?.();
        rlEpisodeActive = false;
      }
      rlPendingChoice = null;
      rlMethod = normalized;
      rlConfig.method = normalized;
      rlAgent = rlAgents[normalized];
      stopBackgroundTraining();
      const agentUnavailable = rlMethod === RL_METHODS.PPO && rlAgent && rlAgent.available === false;
      if(agentUnavailable){
        rlTrainingEnabled = false;
        rlEpisodeActive = false;
        rlHintOverride = rlAgent.unavailableReason || 'PPO training is unavailable because TensorFlow.js did not load.';
        cancelScheduledAutoRestart();
        syncRunTimeout();
        resetRlBatchProgress();
        backgroundTrainingStats = null;
      } else if(rlTrainingEnabled){
        rlAgent.resetEpsilon?.(rlConfig.epsilonStart);
        rlAgent.startEpisode?.();
        rlEpisodeActive = true;
        resetRewardImpactEpisode();
        updateRewardImpactUI();
        restartBackgroundTrainingIfActive();
      }
      updateRlMethodUI();
      updateRlStatus();
      if(agentUnavailable && rlHint){
        rlHint.textContent = rlHintOverride;
      }
      window.rlAgent = rlAgent;
    }
    function getManualNext(){
      const direction = pendingManualDirection || manualDirection;
      manualDirection = direction;
      pendingManualDirection = null;
      const head = snake[0];
      const next = {x: head.x + direction.dx, y: head.y + direction.dy};
      currentStrategy = 'Manual control';
      hamMode = false;
      loopDetected = false;
      compactMode = false;
      compactModeSteps = 0;
      return next;
    }
    function getCurrentDirection(){
      if(snake.length > 1){
        const dx = snake[0].x - snake[1].x;
        const dy = snake[0].y - snake[1].y;
        if(dx !== 0 || dy !== 0){
          return {dx: Math.sign(dx), dy: Math.sign(dy)};
        }
      }
      if(lastMoves.length > 1){
        const head = lastMoves[lastMoves.length - 1];
        const prev = lastMoves[lastMoves.length - 2];
        const dx = head.x - prev.x;
        const dy = head.y - prev.y;
        if(dx !== 0 || dy !== 0){
          return {dx: Math.sign(dx), dy: Math.sign(dy)};
        }
      }
      return {dx: 1, dy: 0};
    }
    function getDirIndex(dir){
      const key = `${dir.dx},${dir.dy}`;
      if(Object.prototype.hasOwnProperty.call(DIR_TO_INDEX, key)){
        return DIR_TO_INDEX[key];
      }
      return DIR_TO_INDEX['1,0'];
    }
    function getSafeMovesForRL(){
      const head = snake[0];
      if(!head) return [];
      const safeMoves = [];
      const tail = snake.length > 1 ? snake[snake.length - 1] : null;
      for(let i = 0; i < DIRS.length; i++){
        const d = DIRS[i];
        const nx = head.x + d.dx;
        const ny = head.y + d.dy;
        if(nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
        const key = `${nx},${ny}`;
        const ate = fruit && fruit.x === nx && fruit.y === ny;
        const isTailStep = tail && nx === tail.x && ny === tail.y;
        if(snakeSet.has(key) && !(isTailStep && !ate)) continue;
        if(safetyNetEnabled){
          const simulated = ate
            ? [{x: nx, y: ny}, ...snake]
            : [{x: nx, y: ny}, ...snake.slice(0, -1)];
          if(!canReachTailFrom({x: nx, y: ny}, simulated)) continue;
        }
        safeMoves.push({x: nx, y: ny, dirIndex: i, ate});
      }
      return safeMoves;
    }
    function countImmediateFreeNeighbors(){
      const head = snake[0];
      if(!head) return 0;
      const tail = snake.length > 1 ? snake[snake.length - 1] : null;
      let free = 0;
      for(const d of DIRS){
        const nx = head.x + d.dx;
        const ny = head.y + d.dy;
        if(nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
        const key = `${nx},${ny}`;
        const ate = fruit && fruit.x === nx && fruit.y === ny;
        const isTailStep = tail && nx === tail.x && ny === tail.y;
        if(!snakeSet.has(key) || (isTailStep && !ate)){
          free++;
        }
      }
      return free;
    }
    function isMoveLethal(move){
      return move?.outOfBounds || move?.hitsBody;
    }
    function pickViableMove(preferred, moves){
      if(!moves || !moves.length) return null;
      const preferredMatch = preferred
        ? moves.find(move => move.dirIndex === preferred.dirIndex)
        : null;
      if(preferredMatch && !isMoveLethal(preferredMatch)){
        return preferredMatch;
      }
      const safeOptions = moves.filter(move => !isMoveLethal(move));
      if(safeOptions.length){
        return safeOptions[(Math.random() * safeOptions.length) | 0];
      }
      return preferredMatch || moves[(Math.random() * moves.length) | 0];
    }
    function getAllMovesForRL(){
      const head = snake[0];
      if(!head) return [];
      const moves = [];
      const tail = snake.length > 1 ? snake[snake.length - 1] : null;
      for(let i = 0; i < DIRS.length; i++){
        const d = DIRS[i];
        const nx = head.x + d.dx;
        const ny = head.y + d.dy;
        const ate = fruit && fruit.x === nx && fruit.y === ny;
        const isTailStep = tail && nx === tail.x && ny === tail.y;
        const hitsBody = snakeSet.has(`${nx},${ny}`) && !(isTailStep && !ate);
        moves.push({
          x: nx,
          y: ny,
          dirIndex: i,
          ate,
          outOfBounds: nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS,
          hitsBody
        });
      }
      return moves;
    }
    function pickUnsafeMove(){
      const head = snake[0];
      if(!head) return null;
      const moves = getAllMovesForRL();
      if(!moves.length) return null;
      const safeMoves = moves.filter(move => !isMoveLethal(move));
      const currentDist = fruit && fruit.x >= 0
        ? Math.abs(head.x - fruit.x) + Math.abs(head.y - fruit.y)
        : Infinity;
      let best = null;
      const candidates = safeMoves.length ? safeMoves : moves;
      for(const move of candidates){
        let score = 0;
        if(move.ate) score += 50;
        if(!move.outOfBounds) score += 20; else score -= 15;
        if(!move.hitsBody) score += 15; else score -= 10;
        if(fruit && fruit.x >= 0){
          const dist = Math.abs(move.x - fruit.x) + Math.abs(move.y - fruit.y);
          score += (currentDist - dist) * 5;
        }
        score += Math.random();
        move.score = score;
        if(!best || score > best.score){
          best = move;
        }
      }
      if(best){
        return {x: best.x, y: best.y};
      }
      const fallback = pickViableMove(null, moves);
      if(fallback){
        return {x: fallback.x, y: fallback.y};
      }
      return null;
    }
    function buildRlObservation(safeMoves){
      const head = snake[0];
      if(!head) return ['empty'];
      const direction = getCurrentDirection();
      const safeSet = new Set((safeMoves || []).map(m => m.dirIndex));
      const frontDir = getDirIndex(direction);
      const leftDir = getDirIndex({dx: direction.dy, dy: -direction.dx});
      const rightDir = getDirIndex({dx: -direction.dy, dy: direction.dx});
      const frontDanger = safeSet.has(frontDir) ? 0 : 1;
      const leftDanger = safeSet.has(leftDir) ? 0 : 1;
      const rightDanger = safeSet.has(rightDir) ? 0 : 1;
      const fruitDX = fruit && fruit.x >= 0 ? Math.sign(fruit.x - head.x) : 0;
      const fruitDY = fruit && fruit.y >= 0 ? Math.sign(fruit.y - head.y) : 0;
      const freeCells = COLS * ROWS - snake.length;
      const freeBucket = Math.min(3, Math.floor(freeCells / Math.max(1, Math.floor((COLS * ROWS) / 4))));
      return [
        frontDanger,
        leftDanger,
        rightDanger,
        fruitDX,
        fruitDY,
        direction.dx,
        direction.dy,
        freeBucket,
        hamMode ? 1 : 0
      ];
    }
    function updateRlLiveMetrics(reward){
      if(!rlLiveMetricsEl) return;
      if(!rlTrainingEnabled){
        rlLiveMetricsEl.textContent = 'RL disabled ‚Äì live metrics paused.';
        return;
      }
      if(typeof reward === 'number' && !Number.isNaN(reward)){
        lastObservedReward = reward;
      }
      const stats = rlAgent.getStats();
      const rewardText = Number.isFinite(lastObservedReward) ? lastObservedReward.toFixed(2) : '0.00';
      const lastEpisodeText = Number.isFinite(stats.lastEpisodeReward) ? stats.lastEpisodeReward.toFixed(2) : '0.00';
      const avgText = Number.isFinite(stats.averageReward) ? stats.averageReward.toFixed(2) : '0.00';
      const episodesText = Number.isFinite(stats.episodes) ? stats.episodes : 0;
      const winsText = Number.isFinite(stats.completedEpisodes) ? stats.completedEpisodes : 0;
      const stateCountText = Number.isFinite(stats.stateCount) ? stats.stateCount.toLocaleString() : '0';
      const epsilonText = Number.isFinite(stats.epsilon) ? stats.epsilon.toFixed(3) : '--';
      const epsilonMinText = Number.isFinite(stats.epsilonMin) ? stats.epsilonMin.toFixed(2) : '--';
      const epsilonDecayText = Number.isFinite(stats.epsilonDecay) ? stats.epsilonDecay.toFixed(3) : '--';
      const alphaText = Number.isFinite(stats.alpha) ? stats.alpha.toFixed(2) : '--';
      const gammaText = Number.isFinite(stats.gamma) ? stats.gamma.toFixed(2) : '--';
      const lastDurationText = formatEpisodeDuration(stats.lastEpisodeDuration);
      const avgDurationText = formatEpisodeDuration(stats.averageEpisodeDuration);
      const lineOne = `Live: reward=${rewardText} ¬∑ last episode=${lastEpisodeText} ¬∑ avg=${avgText}`;
      const lastDeathsText = Number.isFinite(stats.lastEpisodeDeaths) ? stats.lastEpisodeDeaths : 0;
      const avgDeathsText = Number.isFinite(stats.averageDeaths) ? stats.averageDeaths.toFixed(2) : '0.00';
      const lineTwo = `episodes=${episodesText} ¬∑ wins=${winsText} ¬∑ states=${stateCountText} ¬∑ deaths last=${lastDeathsText} (avg=${avgDeathsText}) ¬∑ time last=${lastDurationText} ¬∑ avg=${avgDurationText}`;
      const lineThree = `Œµ=${epsilonText} (min=${epsilonMinText}, decay=${epsilonDecayText}) ¬∑ Œ±=${alphaText} ¬∑ Œ≥=${gammaText}`;
      const outcomes = stats.outcomes || {};
      const wallCrashCount = Number.isFinite(outcomes['wall-crash']) ? outcomes['wall-crash'] : 0;
      const selfCrashCount = Number.isFinite(outcomes['self-crash']) ? outcomes['self-crash'] : 0;
      const deadEndCrashCount = Number.isFinite(outcomes['dead-end-crash']) ? outcomes['dead-end-crash'] : 0;
      const timeoutCount = Number.isFinite(outcomes.timeout) ? outcomes.timeout : 0;
      const lineFour = `crashes wall=${wallCrashCount} ¬∑ self=${selfCrashCount} ¬∑ dead-end=${deadEndCrashCount} ¬∑ timeouts=${timeoutCount}`;
      rlLiveMetricsEl.innerHTML = `${lineOne}<br>${lineTwo}<br>${lineThree}<br>${lineFour}`;
    }
    function stopBackgroundTraining(){
      if(backgroundTrainingAbortController){
        backgroundTrainingAbortController.abort();
        backgroundTrainingAbortController = null;
      }
      backgroundTrainingTask = null;
    }
    function restartBackgroundTrainingIfActive(){
      stopBackgroundTraining();
      if(!rlTrainingEnabled || rlMethod !== RL_METHODS.TABULAR){
        if(!rlTrainingEnabled){
          backgroundTrainingStats = null;
        }
        updateRlStatus();
        return;
      }
      const requested = Math.max(0, Math.round(rlConfig.parallelSnakes || 0));
      if(requested <= 0){
        backgroundTrainingStats = null;
        updateRlStatus();
        return;
      }
      backgroundTrainingStats = {
        episodes: 0,
        wins: 0,
        crashes: 0,
        apples: 0,
        steps: 0
      };
      const controller = new AbortController();
      backgroundTrainingAbortController = controller;
      backgroundTrainingTask = rlAgent.startTraining(Number.POSITIVE_INFINITY, {
        parallelSnakes: requested,
        cols: COLS,
        rows: ROWS,
        signal: controller.signal,
        onEpisodeComplete: (episode) => {
          if(!backgroundTrainingStats) return;
          backgroundTrainingStats.episodes += 1;
          backgroundTrainingStats.steps += episode.steps;
          backgroundTrainingStats.apples += episode.apples;
          if(episode.outcome === 'win') backgroundTrainingStats.wins += 1;
          if(episode.outcome === 'wall-crash' || episode.outcome === 'self-crash'){
            backgroundTrainingStats.crashes += 1;
          }
          updateRlStatus();
        }
      }).catch(error => {
        if(error?.name === 'AbortError') return;
        console.error('Background training failed', error);
      });
    }
    function applyRlUpdate(reward, done, options = {}){
      if(!rlTrainingEnabled){
        rlPendingChoice = null;
        return;
      }
      const shouldScale = !options.skipScaling && typeof reward === 'number' && Number.isFinite(reward);
      const scale = Number.isFinite(rlConfig.rewardScale) ? rlConfig.rewardScale : 1;
      const effectiveReward = shouldScale && scale !== 1 ? reward * scale : reward;
      const breakdownEntries = normalizeRewardBreakdown(
        options.breakdown,
        reward,
        effectiveReward,
        shouldScale && scale !== 1,
        scale
      );
      if(breakdownEntries.length){
        recordRewardBreakdown(breakdownEntries);
      }
      let episodeJustEnded = false;
      if(rlPendingChoice){
        const nextObservation = done ? null : buildRlObservation(getSafeMovesForRL());
        if(rlPendingChoice.method === RL_METHODS.PPO){
          rlAgent.learn(rlPendingChoice.decision, effectiveReward, nextObservation, done);
        } else {
          const decision = rlPendingChoice.decision || rlPendingChoice;
          rlAgent.learn(decision.stateKey, decision.actionIdx, effectiveReward, nextObservation, done);
        }
        if(done && rlEpisodeActive){
          rlAgent.endEpisode();
          rlEpisodeActive = false;
          episodeJustEnded = true;
        }
        rlPendingChoice = null;
      } else if(done && rlTrainingEnabled && rlEpisodeActive){
        rlAgent.endEpisode();
        rlEpisodeActive = false;
        episodeJustEnded = true;
      }
      let completionInfo = null;
      if(episodeJustEnded){
        recordRlEpisodeSnapshot();
        completionInfo = handleRlEpisodeCompletion();
        finalizeRewardImpactEpisode();
      }
      if(completionInfo?.trainingDisabled){
        rlHintOverride = completionInfo.message ?? rlHintOverride;
        updateRlToggleUI();
      }
      updateRlStatus();
      updateRlLiveMetrics(effectiveReward);
      if(!completionInfo?.trainingDisabled && completionInfo?.message && rlHint){
        rlHint.textContent = completionInfo.message;
      }
    }
    function updateRlStatus(){
      const rlStatusEl = document.getElementById('rlStatus');
      if(!rlStatusEl) return;
      rlStatusEl.classList.add('rl-status-card');
      const methodLabel = rlMethod === RL_METHODS.PPO ? 'PPO policy gradient' : 'Tabular Q-learning';
      const agentUnavailable = rlMethod === RL_METHODS.PPO && rlAgent && rlAgent.available === false;
      if(!rlTrainingEnabled){
        rlStatusEl.classList.add('rl-inactive');
        const rlBadgeEl = document.getElementById('rlModeBadge');
        if(rlBadgeEl){
          rlBadgeEl.hidden = true;
        }
        if(agentUnavailable){
          rlStatusEl.innerHTML = `
            <div class="rl-status-header">
              <span class="rl-status-indicator paused" aria-hidden="true"></span>
              <span>${methodLabel} unavailable</span>
            </div>
            <p class="rl-status-note">TensorFlow.js could not be loaded, so PPO training is disabled. Check your internet connection or switch to the tabular agent.</p>
          `;
          if(rlHint){
            rlHint.textContent = rlHintOverride ?? rlAgent?.unavailableReason ?? 'PPO training is unavailable because TensorFlow.js did not load.';
          }
        } else {
          rlStatusEl.innerHTML = `
            <div class="rl-status-header">
              <span class="rl-status-indicator paused" aria-hidden="true"></span>
              <span>${methodLabel} paused</span>
            </div>
            <p class="rl-status-note">RL disabled ‚Äì using handcrafted strategies only.</p>
          `;
          if(rlHint){
            rlHint.textContent = rlHintOverride ?? 'Reinforcement learning is currently disabled.';
          }
        }
        updateRlLiveMetrics();
        return;
      }
      rlStatusEl.classList.remove('rl-inactive');
      const stats = rlAgent.getStats();
      const episodes = Number.isFinite(stats.episodes) ? stats.episodes : 0;
      const wins = Number.isFinite(stats.completedEpisodes) ? stats.completedEpisodes : 0;
      const lastRewardText = formatRewardValue(stats.lastEpisodeReward);
      const avgRewardText = formatRewardValue(stats.averageReward);
      const lastDurationText = formatEpisodeDuration(stats.lastEpisodeDuration);
      const avgDurationText = formatEpisodeDuration(stats.averageEpisodeDuration);
      const lastDeaths = Number.isFinite(stats.lastEpisodeDeaths) ? stats.lastEpisodeDeaths : 0;
      const avgDeaths = Number.isFinite(stats.averageDeaths) ? stats.averageDeaths.toFixed(2) : '0.00';
      const totalOutcomes = Number.isFinite(stats.totalOutcomes) ? stats.totalOutcomes : 0;
      const epsilonText = Number.isFinite(stats.epsilon) ? stats.epsilon.toFixed(3) : '--';
      const epsilonMinText = Number.isFinite(stats.epsilonMin) ? stats.epsilonMin.toFixed(2) : '--';
      const epsilonDecayText = Number.isFinite(stats.epsilonDecay) ? stats.epsilonDecay.toFixed(3) : '--';
      const alphaText = Number.isFinite(stats.alpha) ? stats.alpha.toFixed(2) : '--';
      const gammaText = Number.isFinite(stats.gamma) ? stats.gamma.toFixed(2) : '--';
      const lrText = Number.isFinite(stats.ppoLearningRate) ? stats.ppoLearningRate.toFixed(5) : '--';
      const clipText = Number.isFinite(stats.ppoClip) ? stats.ppoClip.toFixed(2) : '--';
      const lambdaText = Number.isFinite(stats.ppoLambda) ? stats.ppoLambda.toFixed(2) : '--';
      const entropyText = Number.isFinite(stats.ppoEntropyCoeff) ? stats.ppoEntropyCoeff.toFixed(3) : '--';
      const valueCoeffText = Number.isFinite(stats.ppoValueCoeff) ? stats.ppoValueCoeff.toFixed(2) : '--';
      const epochsText = Number.isFinite(stats.ppoEpochs) ? stats.ppoEpochs : '--';
      const batchText = Number.isFinite(stats.ppoBatchSize) ? stats.ppoBatchSize : '--';
      const baseItems = [
        { label: 'Episodes', value: episodes.toLocaleString() },
        { label: 'Wins', value: wins.toLocaleString() },
        { label: 'Last reward', value: lastRewardText },
        { label: 'Avg reward', value: avgRewardText },
        { label: 'Deaths (avg)', value: `${lastDeaths} (${avgDeaths})` },
        { label: 'Episode time', value: `${lastDurationText} ¬∑ avg ${avgDurationText}` },
        { label: 'Outcome samples', value: totalOutcomes.toLocaleString() }
      ];
      const approachWeightText = Number.isFinite(rlConfig.fruitApproachReward)
        ? rlConfig.fruitApproachReward.toFixed(2)
        : '--';
      const wallWeightText = Number.isFinite(rlConfig.wallDistanceReward)
        ? rlConfig.wallDistanceReward.toFixed(2)
        : '--';
      baseItems.push(
        { label: 'Fruit distance √óŒî', value: approachWeightText },
        { label: 'Wall distance √óŒî', value: wallWeightText }
      );
      if(rlMethod === RL_METHODS.PPO){
        lastRlPhaseLabel = null;
        baseItems.push(
          { label: 'Learning rate', value: lrText },
          { label: 'Clip range', value: clipText },
          { label: 'GAE Œª', value: lambdaText },
          { label: 'Entropy coeff', value: entropyText },
          { label: 'Value coeff', value: valueCoeffText },
          { label: 'Epochs', value: epochsText },
          { label: 'Batch size', value: batchText },
          { label: 'Œ≥', value: gammaText }
        );
      } else {
        const epsilonPhaseLabel = getRlPhase(stats.epsilon, rlConfig.epsilonStart, rlConfig.epsilonEnd);
        baseItems.push(
          { label: 'Œµ', value: `${epsilonText} ‚Üí ${epsilonMinText}` },
          { label: 'Œµ decay', value: epsilonDecayText },
          { label: 'Œ±', value: alphaText },
          { label: 'Œ≥', value: gammaText }
        );
        if(epsilonPhaseLabel){
          baseItems.push({ label: 'Phase', value: epsilonPhaseLabel });
        }
        lastRlPhaseLabel = epsilonPhaseLabel || null;
        const parallelCount = Math.max(0, Math.round(rlConfig.parallelSnakes || 0));
        if(parallelCount > 0){
          baseItems.push({ label: 'Background snakes', value: parallelCount.toLocaleString() });
          if(backgroundTrainingStats){
            baseItems.push({
              label: 'Background episodes',
              value: backgroundTrainingStats.episodes.toLocaleString()
            });
          }
        }
      }
      const gridHtml = baseItems.map(item => `
        <div class="rl-status-item">
          <span class="rl-status-label">${item.label}</span>
          <span class="rl-status-value">${item.value}</span>
        </div>
      `).join('');
      const outcomes = stats.outcomes || {};
      const outcomeEntries = Object.entries(outcomes)
        .filter(([, value]) => Number.isFinite(value) && value > 0)
        .map(([key, value]) => ({
          key,
          value,
          label: RL_OUTCOME_LABELS[key] || key.replace(/-/g, ' ')
        }))
        .sort((a, b) => b.value - a.value);
      let outcomeHtml = '';
      if(outcomeEntries.length && totalOutcomes > 0){
        const rows = outcomeEntries.map(entry => {
          const percent = totalOutcomes > 0 ? (entry.value / totalOutcomes) * 100 : 0;
          return `
            <div class="rl-outcome-item">
              <span class="rl-outcome-label">${entry.label}</span>
              <span class="rl-outcome-value">${entry.value.toLocaleString()} (${formatPercentage(percent)})</span>
            </div>
          `;
        }).join('');
        outcomeHtml = `<div class="rl-outcome-grid">${rows}</div>`;
      } else {
        outcomeHtml = '<p class="rl-status-note">No completed RL episodes yet ‚Äì finish a run to collect outcome stats.</p>';
      }
      const indicatorState = rlEpisodeActive ? 'active' : 'paused';
      const runStateText = rlEpisodeActive ? 'Episode in progress' : 'Awaiting restart';
      rlStatusEl.innerHTML = `
        <div class="rl-status-header">
          <span class="rl-status-indicator ${indicatorState}" aria-hidden="true"></span>
          <span>${methodLabel} ¬∑ ${runStateText}</span>
        </div>
        <div class="rl-status-grid">
          ${gridHtml}
        </div>
        ${outcomeHtml}
        <div class="rl-status-extra">
          <div class="rl-sparkline-wrapper">
            <div class="rl-sparkline-header">
              <span class="rl-sparkline-title">Reward trend</span>
              <span class="rl-sparkline-sub" id="rlRewardTrendLabel">Waiting for episodes...</span>
            </div>
            <svg id="rlRewardSparkline" class="rl-sparkline" viewBox="0 0 220 50" preserveAspectRatio="none" role="img" aria-label="Reward trend over recent RL episodes">
              <path id="rlRewardSparklinePath" class="rl-sparkline-path" d=""></path>
            </svg>
          </div>
        </div>
      `;
      if(rlHint){
        let hintText;
        if(rlHintOverride){
          hintText = rlHintOverride;
        } else if(episodes < 10){
          hintText = 'RL warm-up ‚Äì let it explore the board for a bit.';
        } else if(wins === 0){
          hintText = 'RL is still searching for its first flawless run ‚Äì keep it training.';
        } else if(wins > 0 && wins < 20){
          hintText = `RL is stabilising ‚Äì ${wins.toLocaleString()} perfect runs so far.`;
        } else {
          hintText = `RL is refining its policy ‚Äì episodes: ${episodes.toLocaleString()}, wins: ${wins.toLocaleString()}.`;
        }
        rlHint.textContent = hintText;
      }
      updateRlSparkline(episodes);
      const badgeEl = document.getElementById('rlModeBadge');
      const badgeTextEl = document.getElementById('rlBadgeText');
      if(badgeEl && badgeTextEl){
        badgeEl.hidden = false;
        badgeEl.classList.toggle('rl-mode-badge--ppo', rlMethod === RL_METHODS.PPO);
        badgeEl.classList.toggle('rl-mode-badge--tabular', rlMethod !== RL_METHODS.PPO);
        const phasePart = lastRlPhaseLabel ? ` ¬∑ ${lastRlPhaseLabel}` : '';
        badgeTextEl.textContent = `${episodes.toLocaleString()} eps${phasePart}`;
      }
      updateRlLiveMetrics();
    }
    function setupRlControls(){
      RL_CONTROL_BINDINGS.forEach(binding => {
        const input = document.getElementById(binding.id);
        const valueEl = document.getElementById(binding.valueId);
        if(!input || !valueEl) return;
        const applyValue = raw => {
          if(Number.isNaN(raw)) return;
          rlConfig[binding.key] = raw;
          if(input){
            input.value = raw;
          }
          valueEl.textContent = typeof binding.format === 'function' ? binding.format(raw) : raw;
          if(typeof binding.onChange === 'function'){
            binding.onChange(raw);
          }
          updateRlStatus();
        };
        const initial = binding.parser(input.value);
        applyValue(initial);
        input.addEventListener('input', event => {
          const parsed = binding.parser(event.target.value);
          applyValue(parsed);
        });
      });
      if(rlMethodSelect){
        rlMethodSelect.value = rlMethod;
        rlMethodSelect.addEventListener('change', event => {
          setRlMethod(event.target.value);
          applyRlConfigValues(rlConfig);
        });
      }
      updateRlMethodUI();
      rlResetButton?.addEventListener('click', () => {
        rlAgent.resetLearning();
        lastObservedReward = 0;
        rlEpisodeLog.length = 0;
        rlHintOverride = null;
        updateRlStatus();
        updateRlLiveMetrics(0);
        renderRlEpisodeHistory();
        resetRewardImpactStats();
        if(rlHint){
          rlHint.textContent = 'RL reset ‚Äì start a new training run to collect data.';
        }
      });
    }
    function applyRlConfigValues(values){
      if(!values || typeof values !== 'object') return;
      RL_CONTROL_BINDINGS.forEach(binding => {
        if(!(binding.key in values)) return;
        const target = values[binding.key];
        if(typeof target !== 'number' || Number.isNaN(target)) return;
        const input = document.getElementById(binding.id);
        if(!input) return;
        input.value = target;
        input.dispatchEvent(new Event('input', { bubbles: true }));
      });
    }
    function spawnEatEffect(cellX, cellY){
      const originX = cellX * CELL + CELL / 2;
      const originY = cellY * CELL + CELL / 2;
      const count = Math.max(14, Math.floor(CELL / 2));
      for(let i = 0; i < count; i++){
        const angle = Math.random() * Math.PI * 2;
        const speed = (Math.random() * 0.6 + 0.2) * CELL / 8;
        const lifetime = 1.2 + Math.random() * 0.6;
        eatParticles.push({
          x: originX,
          y: originY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: lifetime,
          maxLife: lifetime,
          size: CELL * (0.15 + Math.random() * 0.15),
          hue: 200 + Math.random() * 40
        });
      }
    }
    function updateParticles(delta){
      const decay = delta / 1000;
      eatParticles = eatParticles.filter(p => {
        p.life -= decay;
        if(p.life <= 0) return false;
        p.x += p.vx * (delta / (1000 / 60));
        p.y += p.vy * (delta / (1000 / 60));
        p.vx *= 0.98;
        p.vy *= 0.98;
        return true;
      });
    }
    document.addEventListener('keydown', (event) => {
      const key = event.key;
      if(key === '?' || (key === 'h' && !event.ctrlKey && !event.metaKey)){
        const overlay = document.getElementById('helpOverlay');
        if(overlay){
          overlay.hidden = !overlay.hidden;
        }
        event.preventDefault();
        return;
      }
      if(key === ' ' && !event.repeat){
        const activeTag = (document.activeElement && document.activeElement.tagName) || '';
        if(!/^(INPUT|TEXTAREA|SELECT|BUTTON)$/i.test(activeTag)){
          toggleManualMode();
          event.preventDefault();
        }
      }
    });
    manualToggleBtn?.addEventListener('click', toggleManualMode);
    document.addEventListener('keydown', (event) => {
      if(!manualMode) return;
      const dir = KEY_TO_DIR[event.key.toLowerCase()];
      if(!dir) return;
      setManualDirection(dir.dx, dir.dy);
      event.preventDefault();
    });
    autoRestartToggle?.addEventListener('change', (event) => {
      autoRestartEnabled = !!event.target.checked;
      if(autoRestartEnabled){
        resetRlBatchProgress();
      } else if(rlTrainingEnabled){
        configureRlBatchForSession();
        if(rlBatchActive && rlHint){
          rlHint.textContent = `Batch training ${rlBatchPlannedEpisodes} episodes ‚Äì episode 1 in progress.`;
        }
      }
    });
    updateManualUI();
    rlToggleBtn?.addEventListener('click', () => {
      if(rlTrainingEnabled){
        if(rlEpisodeActive){
          rlAgent.endEpisode();
        }
        rlTrainingEnabled = false;
        rlEpisodeActive = false;
        rlPendingChoice = null;
        rlHintOverride = null;
        cancelScheduledAutoRestart();
        resetRlBatchProgress();
        resetRewardImpactEpisode();
        stopBackgroundTraining();
        backgroundTrainingStats = null;
        syncRunTimeout();
        updateRlToggleUI();
        updateRlStatus();
        updateRewardImpactUI();
        return;
      }
      if(rlMethod === RL_METHODS.PPO && rlAgent && rlAgent.available === false){
        rlTrainingEnabled = false;
        rlEpisodeActive = false;
        rlPendingChoice = null;
        rlHintOverride = rlAgent.unavailableReason || 'PPO training is unavailable because TensorFlow.js did not load.';
        if(rlHint){
          rlHint.textContent = rlHintOverride;
        }
        syncRunTimeout();
        updateRlToggleUI();
        updateRlStatus();
        return;
      }
      rlTrainingEnabled = true;
      rlHintOverride = null;
      manualMode = false;
      updateManualUI();
      rlPendingChoice = null;
      configureRlBatchForSession();
      rlAgent.resetEpsilon(rlConfig.epsilonStart);
      rlAgent.startEpisode();
      rlEpisodeActive = true;
      resetRewardImpactEpisode();
      syncRunTimeout();
      restartBackgroundTrainingIfActive();
      updateRlToggleUI();
      updateRlStatus();
      if(rlTrainingEnabled && rlBatchActive && rlHint){
        rlHint.textContent = `Batch training ${rlBatchPlannedEpisodes} episodes ‚Äì episode 1 in progress.`;
      }
      updateRewardImpactUI();
    });
    updateRlToggleUI();
    updateRlStatus();
    setupRlControls();
    rlExportButton?.addEventListener('click', async () => {
      try {
        const snapshot = await createTrainingSnapshot();
        downloadTrainingSnapshot(snapshot);
        if(rlHint){
          rlHint.textContent = 'Training snapshot downloaded to your device.';
        }
      } catch (error){
        console.error('Failed to create training snapshot', error);
        alert('Export failed ‚Äì please try again.');
      }
    });
    rlImportButton?.addEventListener('click', () => {
      rlImportFileInput?.click();
    });
    rlImportFileInput?.addEventListener('change', handleTrainingImport);
    /* ===== SIZE CONTROL ===== */
    const sizeSlider = document.getElementById('sizeSlider');
    const initialCanvasSize = parseInt(sizeSlider.value);
    if (!Number.isNaN(initialCanvasSize)) {
      canvas.width = initialCanvasSize;
      canvas.height = initialCanvasSize;
      CELL = canvas.width / COLS;
    }
    sizeSlider.addEventListener('input', (e) => {
      const size = parseInt(e.target.value);
      canvas.width = size;
      canvas.height = size;
      CELL = size / COLS;
      if (gameRunning) draw();
    });
    /* ===== GRID CONTROLS ===== */
    const colsSlider = document.getElementById('colsSlider');
    const rowsSlider = document.getElementById('rowsSlider');
    function updateGridSize(newSize) {
      const targetSize = typeof newSize === 'number' ? newSize : parseInt(colsSlider.value);
      if (Number.isNaN(targetSize)) return;
      const targetValue = String(targetSize);
      if (colsSlider.value !== targetValue) colsSlider.value = targetValue;
      if (rowsSlider.value !== targetValue) rowsSlider.value = targetValue;
      if (targetSize !== COLS || targetSize !== ROWS) {
        COLS = targetSize;
        ROWS = targetSize;
        document.getElementById('colsValue').textContent = COLS;
        document.getElementById('rowsValue').textContent = ROWS;
        CELL = canvas.width / COLS;
        // When not loading a preset, update dynamic thresholds based on grid size
        if (!window.loadingPreset) {
          ENDGAME_THRESHOLD = Math.min(40, Math.floor((COLS * ROWS) * 0.2));
          MAX_LOOP_DETECTION = Math.max(8, (COLS + ROWS) / 2 | 0);
          FILL_POCKET_LIMIT = COLS * 4;
          WINDOW_SIZE = Math.max(10, COLS + ROWS);
          LOOP_ESCAPE_LIMIT = Math.max(40, Math.floor((COLS * ROWS) / 2));
          NO_PROGRESS_THRESHOLD = Math.max(30, (COLS * ROWS) / 6);
          COMPACT_MODE_MAX_STEPS = Math.floor((COLS * ROWS) / 2);
          document.getElementById('progThreshValue').textContent = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
          document.getElementById('progThreshSlider').max = Math.max(200, COLS * ROWS);
          document.getElementById('progThreshSlider').value = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactSlider').max = Math.max(300, COLS * ROWS);
          document.getElementById('compactSlider').value = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameSlider').max = Math.max(100, Math.floor((COLS * ROWS) * 0.4));
        }
        restartGame();
        restartBackgroundTrainingIfActive();
      }
    }
    function handleGridInput(event) {
      const value = parseInt(event.target.value);
      if (Number.isNaN(value)) return;
      updateGridSize(value);
    }
    colsSlider.addEventListener('input', handleGridInput);
    rowsSlider.addEventListener('input', handleGridInput);
    /* ===== AI PARAMETER CONTROLS ===== */
    const loopThreshSlider = document.getElementById('loopThreshSlider');
    loopThreshSlider.addEventListener('input', (e) => {
      LOOP_STREAK_THRESHOLD = parseInt(e.target.value);
      document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    });
    const progThreshSlider = document.getElementById('progThreshSlider');
    progThreshSlider.addEventListener('input', (e) => {
      NO_PROGRESS_THRESHOLD = parseInt(e.target.value);
      document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    });
    const endgameSlider = document.getElementById('endgameSlider');
    endgameSlider.addEventListener('input', (e) => {
      ENDGAME_THRESHOLD = parseInt(e.target.value);
      document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    });
    const compactSlider = document.getElementById('compactSlider');
    compactSlider.addEventListener('input', (e) => {
      COMPACT_MODE_MAX_STEPS = parseInt(e.target.value);
      document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
    });
    const compactProfileSelect = document.getElementById('compactProfile');
    const compactProfileHint = document.getElementById('compactProfileHint');
    function updateCompactProfile(profileKey){
      if(!COMPACT_MODE_PROFILES[profileKey]) profileKey = 'balanced';
      COMPACT_MODE_PROFILE = profileKey;
      if(compactProfileSelect && compactProfileSelect.value !== profileKey){
        compactProfileSelect.value = profileKey;
      }
      if(compactProfileHint){
        compactProfileHint.textContent = COMPACT_MODE_PROFILES[profileKey].hint;
      }
    }
    compactProfileSelect?.addEventListener('change', (e) => {
      updateCompactProfile(e.target.value);
    });
    function gatherAiSettings(){
      const rlConfigCopy = {};
      Object.keys(rlConfig).forEach(key => {
        const value = rlConfig[key];
        rlConfigCopy[key] = typeof value === 'number' ? Number(value) : value;
      });
      return {
        grid: {
          cols: COLS,
          rows: ROWS,
          canvasSize: canvas.width
        },
        thresholds: {
          loopStreak: LOOP_STREAK_THRESHOLD,
          noProgress: NO_PROGRESS_THRESHOLD,
          endgame: ENDGAME_THRESHOLD,
          compactSteps: COMPACT_MODE_MAX_STEPS
        },
        compactProfile: COMPACT_MODE_PROFILE,
        speed: SPEED,
        autoRestartEnabled,
        timeout: {
          value: getTimeoutSliderValue(),
          userOverride: timeoutUserOverride
        },
        rlConfig: rlConfigCopy,
        toggles: {
          rlTrainingEnabled,
          manualMode
        }
      };
    }
    function applyAiSettings(settings){
      if(!settings || typeof settings !== 'object') return;
      const { grid, thresholds, compactProfile, speed, autoRestartEnabled: autoFlag, timeout: timeoutSettings, rlConfig: rlValues, toggles } = settings;
      if(grid && typeof grid === 'object'){
        const targetCols = Number.isFinite(grid.cols) ? Math.max(5, Math.round(grid.cols)) : null;
        const targetRows = Number.isFinite(grid.rows) ? Math.max(5, Math.round(grid.rows)) : targetCols;
        const canvasSize = Number.isFinite(grid.canvasSize) ? Math.max(100, Math.round(grid.canvasSize)) : null;
        if(targetCols){
          window.loadingPreset = true;
          colsSlider.value = targetCols;
          rowsSlider.value = targetRows || targetCols;
          updateGridSize(targetCols);
          window.loadingPreset = false;
        }
        if(canvasSize){
          sizeSlider.value = canvasSize;
          canvas.width = canvasSize;
          canvas.height = canvasSize;
          CELL = canvas.width / COLS;
        }
      }
      if(thresholds && typeof thresholds === 'object'){
        if(Number.isFinite(thresholds.loopStreak)){
          LOOP_STREAK_THRESHOLD = Math.max(0, Math.round(thresholds.loopStreak));
          loopThreshSlider.value = LOOP_STREAK_THRESHOLD;
          document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
        }
        if(Number.isFinite(thresholds.noProgress)){
          NO_PROGRESS_THRESHOLD = Math.max(0, Math.round(thresholds.noProgress));
          progThreshSlider.value = NO_PROGRESS_THRESHOLD;
          document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
        }
        if(Number.isFinite(thresholds.endgame)){
          ENDGAME_THRESHOLD = Math.max(0, Math.round(thresholds.endgame));
          endgameSlider.value = ENDGAME_THRESHOLD;
          document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
        }
        if(Number.isFinite(thresholds.compactSteps)){
          COMPACT_MODE_MAX_STEPS = Math.max(0, Math.round(thresholds.compactSteps));
          compactSlider.value = COMPACT_MODE_MAX_STEPS;
          document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
        }
      }
      if(typeof compactProfile === 'string'){
        updateCompactProfile(compactProfile);
      }
      if(Number.isFinite(speed)){
        changeSpeed(Math.max(MIN_SPEED, Math.min(MAX_SPEED, Math.round(speed))));
      }
      if(typeof autoFlag === 'boolean' && autoRestartToggle){
        autoRestartEnabled = autoFlag;
        autoRestartToggle.checked = autoFlag;
      }
      if(timeoutSettings && timeoutSliderEl){
        const sliderValue = clampTimeoutValue(timeoutSettings.value);
        if(Number.isFinite(sliderValue)){
          timeoutSliderEl.value = sliderValue;
          updateTimeoutSliderDisplay(sliderValue);
        }
        timeoutUserOverride = !!timeoutSettings.userOverride && Number.isFinite(sliderValue);
      } else {
        timeoutUserOverride = false;
      }
      if(rlValues && typeof rlValues === 'object'){
        if(typeof rlValues.method === 'string'){
          setRlMethod(rlValues.method);
        }
        applyRlConfigValues(rlValues);
      }
      if(toggles && typeof toggles === 'object'){
        if(typeof toggles.manualMode === 'boolean'){
          manualMode = toggles.manualMode;
          updateManualUI();
        }
        if(typeof toggles.rlTrainingEnabled === 'boolean'){
          rlTrainingEnabled = toggles.rlTrainingEnabled;
          rlEpisodeActive = false;
          rlHintOverride = null;
          updateRlToggleUI();
          syncRunTimeout();
        }
      }
      if(!toggles || typeof toggles.rlTrainingEnabled !== 'boolean'){
        syncRunTimeout();
      }
      updateRlStatus();
    }
    async function createTrainingSnapshot(){
      const rlSnapshot = await rlAgent.exportData();
      return {
        version: 1,
        timestamp: new Date().toISOString(),
        rl: rlSnapshot,
        aiSettings: gatherAiSettings()
      };
    }
    function downloadTrainingSnapshot(snapshot){
      try {
        const serialized = JSON.stringify(snapshot, null, 2);
        const blob = new Blob([serialized], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const filename = `snake-training-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = filename;
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
        URL.revokeObjectURL(url);
      } catch (error){
        console.error('Failed to export training snapshot', error);
        alert('Export failed ‚Äì please try again.');
      }
    }
    async function handleTrainingImport(event){
      const input = event.target;
      const file = input?.files && input.files[0];
      if(!file) return;
      try {
        const text = await file.text();
        const parsed = JSON.parse(text);
        const rlPayload = parsed.rl || parsed.training || parsed;
        if(rlPayload && typeof rlPayload.method === 'string'){
          setRlMethod(rlPayload.method);
        }
        const imported = await rlAgent.importData(rlPayload);
        if(!imported){
          throw new Error('Invalid RL payload');
        }
        if(parsed.aiSettings){
          applyAiSettings(parsed.aiSettings);
        } else if(parsed.settings){
          applyAiSettings(parsed.settings);
        }
        rlPendingChoice = null;
        rlEpisodeActive = false;
        rlEpisodeLog.length = 0;
        lastObservedReward = 0;
        rlHintOverride = null;
        renderRlEpisodeHistory();
        updateRlLiveMetrics(0);
        updateRlStatus();
        if(rlHint){
          rlHint.textContent = 'RL data loaded ‚Äì ready to continue training.';
        }
        restartGame();
      } catch (error){
        console.error('Failed to import training data', error);
        alert('Import failed ‚Äì please ensure the file was exported from this simulator.');
      } finally {
        if(input){
          input.value = '';
        }
      }
    }
    /* ===== RESTART FUNCTION ===== */
    function spawnFruitForState(state){
      const free=[];
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if(!state.snakeSet.has(`${x},${y}`)) free.push({x,y});
        }
      }
      return free.length ? free[(Math.random()*free.length)|0] : {x:-1,y:-1};
    }
    function createFreshState(){
      const state = {
        snake: [],
        snakeSet: new Set(),
        fruit: {x:-1,y:-1},
        prevFruitDist: Infinity,
        noProgressMoves: 0,
        lastMoves: [],
        windowMoves: [],
        loopDetected: false,
        loopStreak: 0,
        hamMode: false,
        compactMode: false,
        compactModeSteps: 0,
        loopCountAdjust: 0,
        currentStrategy: "Initializing"
      };
      const sx = Math.floor(COLS/2), sy = Math.floor(ROWS/2);
      if (COLS >= 5) {
        state.snake.push({x:sx-2,y:sy},{x:sx-1,y:sy},{x:sx,y:sy});
      } else if (COLS >= 3) {
        state.snake.push({x:sx-1,y:sy},{x:sx,y:sy});
      } else {
        state.snake.push({x:sx,y:sy});
      }
      state.snake.reverse();
      state.snakeSet = new Set(state.snake.map(p => `${p.x},${p.y}`));
      state.fruit = spawnFruitForState(state);
      if(state.fruit && state.fruit.x >= 0){
        state.prevFruitDist = Math.abs(state.snake[0].x - state.fruit.x) + Math.abs(state.snake[0].y - state.fruit.y);
      }
      return state;
    }
    function restartGame() {
      const manualRestart = gameRunning;
      cancelRunTimer();
      const fresh = createFreshState();
      snake = fresh.snake;
      snakeSet = fresh.snakeSet;
      fruit = fresh.fruit;
      prevFruitDist = fresh.prevFruitDist;
      noProgressMoves = fresh.noProgressMoves;
      lastMoves = fresh.lastMoves;
      windowMoves = fresh.windowMoves;
      loopDetected = fresh.loopDetected;
      loopStreak = fresh.loopStreak;
      hamMode = fresh.hamMode;
      compactMode = fresh.compactMode;
      compactModeSteps = fresh.compactModeSteps;
      loopCountAdjust = fresh.loopCountAdjust;
      currentStrategy = fresh.currentStrategy;
      compactModeJustActivated = false;
      endgamePlanThisMove = false;
      persistentLoopCounter = 0;
      applesEaten = 0;
      completionMessage = '';
      updateAppleStats();
      if(manualMode){
        setInitialManualDirection();
        currentStrategy = 'Manual control';
      }
      eatParticles = [];
      lastRender = performance.now();
      HAM = buildHamilton();
      if (loopHandle) clearInterval(loopHandle);
      gameRunning = true;
      syncRunTimeout();
      if(rlTrainingEnabled){
        if(rlEpisodeActive){
          rlAgent.endEpisode();
        }
        resetRewardImpactEpisode();
        rlAgent.startEpisode();
        rlEpisodeActive = true;
        updateRewardImpactUI();
      } else {
        rlEpisodeActive = false;
      }
      rlPendingChoice = null;
      updateRlStatus();
      draw();
      loopHandle = setInterval(update, SPEED);
      startRunTimer();
      updateCompletedRoundsDisplay();
      if(manualRestart){
        consecutiveSelfCrashCount = 0;
      }
    }
    document.getElementById('restartBtn').addEventListener('click', restartGame);
    /* ===== HAMILTON-SLINGA ===== */
    function buildHamilton(){
      const path=[]; let dir=1;
      for(let y=0; y<ROWS; y++){
        if(dir>0){
          for(let x=0; x<COLS; x++) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        } else {
          for(let x=COLS-1; x>=0; x--) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        }
        dir = -dir;
      }
      return path;
    }
    let HAM = buildHamilton();
    const idxOf = p => HAM.findIndex(q=>q.x===p.x&&q.y===p.y);
    const hamNext = p => {const i=idxOf(p); return i<0?null:HAM[(i+1)%HAM.length];};
    /* ===== HELPER FUNCTIONS ===== */
    function spawnFruit(){
      const free=[]; for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)
        if(!snakeSet.has(`${x},${y}`)) free.push({x,y});
      return free.length ? free[(Math.random()*free.length)|0] : {x:-1,y:-1};
    }
    function distanceFromNearestWall(point){
      if(!point) return 0;
      const dxLeft = point.x;
      const dxRight = COLS - 1 - point.x;
      const dyTop = point.y;
      const dyBottom = ROWS - 1 - point.y;
      return Math.min(dxLeft, dxRight, dyTop, dyBottom);
    }
    function isFruitAccessible(head){
      if(!fruit || fruit.x<0) return false;
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTail=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTail) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    function bfsWithAlternatives(sx,sy,gx,gy,allowTail,preferRandom=false){
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const prev=Array.from({length:ROWS},()=>Array(COLS).fill(null));
      let Q=[{x:sx,y:sy}]; vis[sy][sx]=true;
      while(Q.length){
        if(preferRandom) Q.sort(()=>Math.random()-0.5);
        const {x,y}=Q.shift();
        if(x===gx&&y===gy) break;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=allowTail&&snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; prev[ny][nx]={x,y}; Q.push({x:nx,y:ny});
        }
      }
      if(!vis[gy][gx]) return null;
      const path=[]; for(let cx=gx,cy=gy;!(cx===sx&&cy===sy);){
        path.unshift({x:cx,y:cy}); const p=prev[cy][cx]; if(!p) return null; cx=p.x; cy=p.y;
      }
      return path;
    }
    function canReachTailFrom(head,body){
      if(!body || body.length<2) return true;
      const tail=body[body.length-1];
      if(head.x===tail.x&&head.y===tail.y) return true;
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===tail.x&&y===tail.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          const key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          if(blocked.has(key)&&!(nx===tail.x&&ny===tail.y)) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    const floodSize=(sx,sy,body)=>{
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const startKey=`${sx},${sy}`;
      if(sx<0||sx>=COLS||sy<0||sy>=ROWS||blocked.has(startKey)) return 0;
      const vis=new Set([startKey]); const Q=[{x:sx,y:sy}]; let cnt=1;
      while(Q.length){
        const {x,y}=Q.shift();
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy, key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis.has(key)||blocked.has(key)) continue;
          vis.add(key); cnt++; Q.push({x:nx,y:ny});
        }
      }
      return cnt;
    };
    function countFreeNeighbors(x, y, body){
      const blocked = new Set(body.map(p => `${p.x},${p.y}`));
      let count = 0;
      for(const d of DIRS){
        const nx = x + d.dx;
        const ny = y + d.dy;
        if(nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
        if(blocked.has(`${nx},${ny}`)) continue;
        count++;
      }
      return count;
    }
    function countEnclosedEmptyCells(body){
      if(!Array.isArray(body) || body.length === 0) return 0;
      const blocked = new Set(body.map(p => `${p.x},${p.y}`));
      const visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
      const queue = [];
      const enqueue = (x, y) => {
        if(x < 0 || x >= COLS || y < 0 || y >= ROWS) return;
        if(visited[y][x]) return;
        if(blocked.has(`${x},${y}`)) return;
        visited[y][x] = true;
        queue.push({x, y});
      };
      for(let x = 0; x < COLS; x++){
        enqueue(x, 0);
        enqueue(x, ROWS - 1);
      }
      for(let y = 0; y < ROWS; y++){
        enqueue(0, y);
        enqueue(COLS - 1, y);
      }
      let idx = 0;
      while(idx < queue.length){
        const {x, y} = queue[idx++];
        for(const d of DIRS){
          enqueue(x + d.dx, y + d.dy);
        }
      }
      let enclosed = 0;
      for(let y = 0; y < ROWS; y++){
        for(let x = 0; x < COLS; x++){
          if(blocked.has(`${x},${y}`)) continue;
          if(!visited[y][x]) enclosed++;
        }
      }
      return enclosed;
    }
    function getDistancesFromTail(){
      const dmap=Array.from({length:ROWS},()=>Array(COLS).fill(-1));
      if(snake.length<2) return dmap;
      const tail=snake[snake.length-1];
      const Q=[{x:tail.x,y:tail.y,dist:0}]; dmap[tail.y][tail.x]=0;
      const blocked=new Set(snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
      let idx=0; while(idx<Q.length){
        const {x,y,dist}=Q[idx++];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          if(dmap[ny][nx]>=0) continue;
          if(blocked.has(`${nx},${ny}`)) continue;
          dmap[ny][nx]=dist+1; Q.push({x:nx,y:ny,dist:dist+1});
        }
      }
      return dmap;
    };
    function detectLoop(){
      if(lastMoves.length<MAX_LOOP_DETECTION) return false;
      const recent=lastMoves.slice(-MAX_LOOP_DETECTION);
      const unique=new Set(recent.map(p=>`${p.x},${p.y}`)).size;
      return unique<=MAX_LOOP_DETECTION/2;
    }
    function calculateZigZagPath(){
      const head=snake[0];
      let lastDx=0,lastDy=0;
      if(lastMoves.length){
        const ph=lastMoves[lastMoves.length-1]; lastDx=head.x-ph.x; lastDy=head.y-ph.y;
      }
      const moves=[];
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`, isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const ate=fruit&&fruit.x>=0&&nx===fruit.x&&ny===fruit.y;
        const sim=ate?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        let prio=0;
        if((d.dx&&lastDy)||(d.dy&&lastDx)) prio=1;
        else if(d.dx===lastDx&&d.dy===lastDy) prio=2;
        else if(d.dx===-lastDx&&d.dy===-lastDy) prio=-1;
        moves.push({x:nx,y:ny,priority:prio});
      }
      if(!moves.length) return null;
      moves.sort((a,b)=>b.priority-a.priority);
      return {x:moves[0].x,y:moves[0].y};
    }
    function getBackToHamilton(head){
      const currentIdx=idxOf(head);
      if(currentIdx!==-1) return null;
      let best=null, minDist=Infinity;
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`;
        const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        const idx=idxOf({x:nx,y:ny});
        if(idx!==-1){
          const dist=Math.min(Math.abs(idx-currentIdx),HAM.length-Math.abs(idx-currentIdx));
          if(dist<minDist){minDist=dist; best={x:nx,y:ny};}
        }
      }
      return best;
    }
    function isFruitInPocket(){
      if(!fruit||fruit.x<0) return false;
      let blocked=0;
      for(const d of DIRS){
        const nx=fruit.x+d.dx, ny=fruit.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) blocked++;
        else if(snakeSet.has(`${nx},${ny}`)) blocked++;
      }
      const steps=getMinStepsToFruit();
      return blocked>=3 || (blocked>=2 && steps>(COLS+ROWS)/2);
    }
    function shouldEnterCompactMode(context){
      const profile = COMPACT_MODE_PROFILES[COMPACT_MODE_PROFILE] || COMPACT_MODE_PROFILES.balanced;
      if(context.freeCells <= profile.minFreeCells) return false;
      const loopReady = profile.allowLoop && context.loopDetected && context.loopStreak >= profile.minLoopStreak;
      if(profile.allowPocket && context.inPocket){
        if(profile.requirePocketWithLoop && !loopReady) return false;
        return true;
      }
      if(loopReady && !profile.requirePocketWithLoop){
        return true;
      }
      if(profile.allowCrowding && !context.fruitAcc){
        return true;
      }
      return false;
    }
    function fillSmallestPocket(){
      const head=snake[0];
      const freeCells=[], vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const blocked=new Set(snake.map(p=>`${p.x},${p.y}`));
      for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
        if(vis[y][x]||blocked.has(`${x},${y}`)) continue;
        const pocket=[], Q=[{x,y}]; vis[y][x]=true;
        while(Q.length){
          const {x:cx,y:cy}=Q.shift(); pocket.push({x:cx,y:cy});
          for(const d of DIRS){
            const nx=cx+d.dx, ny=cy+d.dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]||blocked.has(`${nx},${ny}`)) continue;
            vis[ny][nx]=true; Q.push({x:nx,y:ny});
          }
        }
        freeCells.push(pocket);
      }
      freeCells.sort((a,b)=>a.length-b.length);
      for(const pocket of freeCells){
        if(!pocket.length) continue;
        const target=pocket[0];
        const path=bfsWithAlternatives(head.x,head.y,target.x,target.y,true,true);
        if(path&&path.length){
          const nxt=path[0];
          const sim=[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)) return nxt;
        }
      }
      return null;
    }
    function getMinStepsToFruit(){
      if(!fruit||fruit.x<0) return Infinity;
      const head=snake[0];
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const dist=Array.from({length:ROWS},()=>Array(COLS).fill(Infinity));
      const Q=[{x:head.x,y:head.y}];
      vis[head.y][head.x]=true; dist[head.y][head.x]=0;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return dist[y][x];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; dist[ny][nx]=dist[y][x]+1; Q.push({x:nx,y:ny});
        }
      }
      return Infinity;
    }
    /* ===== GET NEXT ===== */
    function getNext(){
      HAM = buildHamilton();
      const head=snake[0];
      const rlSafeMoves = rlTrainingEnabled ? getSafeMovesForRL() : null;
      endgamePlanThisMove = false;
      compactModeJustActivated = false;
      windowMoves.push(`${head.x},${head.y}`);
      if(windowMoves.length>WINDOW_SIZE) windowMoves.shift();
      lastMoves.push({x:head.x,y:head.y});
      if(lastMoves.length>MAX_LOOP_DETECTION) lastMoves.shift();
      const freeCells=COLS*ROWS - snake.length;
      const isEndgame = freeCells <= (ENDGAME_THRESHOLD + loopCountAdjust);
      if(safetyNetEnabled){
        if(!hamMode && freeCells > (ENDGAME_THRESHOLD + loopCountAdjust)){
          const uniq=new Set(windowMoves).size;
          if(uniq < WINDOW_SIZE/2){
            hamMode = true; loopStreak = 0; noProgressMoves = 0;
            currentStrategy = "Forcing Hamilton (Stagnation)";
            loopCountAdjust++;
          }
        }
        if(freeCells <= 1){
          const nxt = hamNext(head);
          if(nxt){
            const isTail=snake.length>1 && nxt.x===snake[snake.length-1].x && nxt.y===snake[snake.length-1].y;
            if(!snakeSet.has(`${nxt.x},${nxt.y}`) || isTail){
              currentStrategy = "Final Hamilton";
              endgamePlanThisMove = true;
              return nxt;
            }
          }
        }
        if(isEndgame){
          const back=getBackToHamilton(head);
          if(back){ currentStrategy="Returning to Hamilton"; endgamePlanThisMove = true; return back; }
          const nxt=hamNext(head);
          if(nxt){
            const key=`${nxt.x},${nxt.y}`;
            const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
            const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
            if((!snakeSet.has(key)||isTailStep) && canReachTailFrom(nxt,sim)){
              currentStrategy="Endgame Hamilton"; endgamePlanThisMove = true; return nxt;
            }
          }
        }
        if(fruit && fruit.x >= 0){
          const d = Math.abs(head.x - fruit.x) + Math.abs(head.y - fruit.y);
          if(d < prevFruitDist){ prevFruitDist = d; noProgressMoves = 0; }
          else noProgressMoves++;
        } else {
          prevFruitDist = Infinity; noProgressMoves = 0;
        }
        if(!hamMode && noProgressMoves >= NO_PROGRESS_THRESHOLD){
          hamMode = true; loopStreak = 0; noProgressMoves = 0;
          currentStrategy = "Forcing Hamilton (No progress)";
          loopCountAdjust++;
        }
        if(hamMode){
          const nxt = hamNext(head);
          if(nxt){
            const key=`${nxt.x},${nxt.y}`;
            const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
            const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
            if((!snakeSet.has(key)||isTailStep) && canReachTailFrom(nxt,sim)){
              currentStrategy = "Hamilton cycle";
              if(isEndgame) endgamePlanThisMove = true;
              return nxt;
            }
          }
          hamMode = false;
        }
        loopDetected = detectLoop();
        loopStreak = loopDetected ? loopStreak + 1 : 0;
        if(loopDetected && !hamMode){
          hamMode = true;
          loopStreak = 0;
          currentStrategy = "Forcing Hamilton (Immediate Loop)";
          loopCountAdjust++;
        }
        if(loopDetected && snake.length >= 2){
          if(freeCells <= FILL_POCKET_LIMIT){
            const fillMove = fillSmallestPocket();
            if(fillMove){ currentStrategy="Filling smallest pocket"; return fillMove; }
          }
          const dmap = getDistancesFromTail();
          let best=null,bestDist=-1;
          for(const d of DIRS){
            const nx=head.x+d.dx, ny=head.y+d.dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
            const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
            if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
            const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
            if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
            const dist=dmap[ny][nx];
            if(dist>bestDist){bestDist=dist; best={x:nx,y:ny};}
          }
          if(best){ currentStrategy="Loop break (Longest)"; return best; }
        }
        if(rlTrainingEnabled && !hamMode){
          if(!rlEpisodeActive){
            resetRewardImpactEpisode();
            rlAgent.startEpisode();
            rlEpisodeActive = true;
            updateRewardImpactUI();
          }
          if(rlSafeMoves && rlSafeMoves.length){
            const rlState = buildRlObservation(rlSafeMoves);
            const decision = rlAgent.decide(rlState, rlSafeMoves);
            if(decision){
              const selected = rlSafeMoves.find(move => move.dirIndex === decision.actionIdx);
              if(selected){
                rlPendingChoice = { method: rlMethod, decision };
                currentStrategy = 'RL policy';
                return {x: selected.x, y: selected.y};
              }
            }
          }
        }
        const fruitAcc = isFruitAccessible(head);
        if(fruitAcc && freeCells>15){
          let choices=[],minD=Infinity;
          for(const d of DIRS){
            const nx=head.x+d.dx, ny=head.y+d.dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
            const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
            if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
            const nd=Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y);
            if(nd>minD) continue;
            const sim=(nx===fruit.x&&ny===fruit.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
            if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
            if(nd<minD){minD=nd; choices=[{x:nx,y:ny}];}
            else if(nd===minD){choices.push({x:nx,y:ny});}
          }
          if(choices.length){ currentStrategy="Greedy to fruit"; return choices[(Math.random()*choices.length)|0]; }
        }
        const inPocket = isFruitInPocket();
        if(!compactMode && shouldEnterCompactMode({
          inPocket,
          loopDetected,
          loopStreak,
          fruitAcc,
          freeCells
        })){
          compactMode = true; compactModeSteps = 0; compactModeJustActivated = true;
        }
        if(compactMode){
          if(compactModeSteps >= COMPACT_MODE_MAX_STEPS){
            compactMode = false; compactModeSteps = 0;
          } else {
            const zig = calculateZigZagPath();
            if(zig){ compactModeSteps++; currentStrategy="Compact zig-zag"; return zig; }
            else{ compactMode = false; }
          }
        }
        if(fruitAcc && freeCells>1){
          const path=bfsWithAlternatives(head.x,head.y,fruit.x,fruit.y,false,loopDetected);
          if(path && path.length){
            const nxt=path[0];
            const sim=(nxt.x===fruit.x&&nxt.y===fruit.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
            if(canReachTailFrom(nxt,sim)){ currentStrategy="BFS to fruit"; return nxt; }
          }
        }
        let bestScore=-Infinity,bestMoves=[];
        const tailPos=snake.length>1?snake[snake.length-1]:null;
        const randomFactor=loopDetected?Math.random()*5:0;
        const avoidFactor=loopDetected?0.5:1;
        const currentDir = getCurrentDirection();
        for(let dirIndex = 0; dirIndex < DIRS.length; dirIndex++){
          const d = DIRS[dirIndex];
          const nx=head.x+d.dx, ny=head.y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
          const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
          if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
          const freeAfter=floodSize(nx,ny,sim);
          if(freeAfter<COLS*ROWS-sim.length) continue;
          const neighborFreedom = countFreeNeighbors(nx, ny, sim);
          const isTurn = d.dx !== currentDir.dx || d.dy !== currentDir.dy;
          let score=0;
          if(fruit&&fruit.x>=0&&freeCells>Math.max(6, COLS-2)){
            score+=(COLS+ROWS-(Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y)))*2*avoidFactor;
          }
          if(isEndgame && tailPos && nx===tailPos.x && ny===tailPos.y) score+=10000;
          score+=neighborFreedom * 3;
          if(!isEndgame && neighborFreedom <= 1) score-=6;
          score+=isTurn ? -0.5 : 1.5;
          score+=Math.min(nx,ny,COLS-1-nx,ROWS-1-ny);
          score+=randomFactor;
          score+=freeAfter*2;
          const moveData = {
            x: nx,
            y: ny,
            dirIndex,
            dx: d.dx,
            dy: d.dy,
            baseScore: score,
            willEat: fruit && fruit.x === nx && fruit.y === ny,
            freeAfter
          };
          if(score>bestScore){ bestScore=score; bestMoves=[moveData]; }
          else if(score===bestScore){ bestMoves.push(moveData); }
        }
        if(bestMoves.length){
          currentStrategy="Heuristic";
          const observation = buildRlObservation(rlSafeMoves && rlSafeMoves.length ? rlSafeMoves : bestMoves);
          const rlChoice = rlAgent.chooseMove(head, bestMoves, { isEndgame, observation });
          if(rlChoice){
            return rlChoice;
          }
          return bestMoves[(Math.random()*bestMoves.length)|0];
        }
        const tail=snake.length>1?snake[snake.length-1]:head;
        const path=bfsWithAlternatives(head.x,head.y,tail.x,tail.y,true,loopDetected);
        if(path && path.length){
          const nxt=path[0];
          const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)){ currentStrategy="BFS to tail"; return nxt; }
        }
        currentStrategy="No safe move!";
        return null;
      }
      loopDetected = false;
      loopStreak = 0;
      compactMode = false;
      compactModeSteps = 0;
      hamMode = false;
      const rlMoves = rlTrainingEnabled ? getAllMovesForRL() : [];
      if(rlTrainingEnabled){
        if(!rlEpisodeActive){
          resetRewardImpactEpisode();
          rlAgent.startEpisode();
          rlEpisodeActive = true;
          updateRewardImpactUI();
        }
        if(rlMoves && rlMoves.length){
          let candidateMoves = rlMoves.filter(move => !move.outOfBounds && !move.hitsBody);
          if(!candidateMoves.length){
            candidateMoves = rlMoves;
          }
          const observationMoves = rlSafeMoves && rlSafeMoves.length ? rlSafeMoves : candidateMoves;
          const rlState = buildRlObservation(observationMoves);
          const decision = rlAgent.decide(rlState, candidateMoves);
          if(decision){
            let selected = candidateMoves.find(move => move.dirIndex === decision.actionIdx);
            if(!selected){
              selected = pickViableMove({ dirIndex: decision.actionIdx }, candidateMoves) || pickViableMove(null, candidateMoves);
            }
            if(selected){
              const updatedDecision = { ...decision, actionIdx: selected.dirIndex ?? decision.actionIdx };
              rlPendingChoice = { method: rlMethod, decision: updatedDecision };
              currentStrategy = 'RL policy';
              return {x: selected.x, y: selected.y};
            }
          }
        }
      }
      const unsafeMove = pickUnsafeMove();
      if(unsafeMove){
        currentStrategy = fruit && fruit.x >= 0 ? 'Unsafe chase' : 'Unsafe roam';
        return unsafeMove;
      }
      if(rlMoves && rlMoves.length){
        const randomPick = pickViableMove(null, rlMoves);
        currentStrategy = 'Unsafe random';
        if(randomPick){
          return {x: randomPick.x, y: randomPick.y};
        }
      }
      currentStrategy = 'No safe move!';
      return null;
    }
    /* ===== RENDER ===== */
    function draw(){
      const now = performance.now();
      const delta = now - lastRender;
      lastRender = now;
      const minimalRender = false;
      if(!minimalRender){
        updateParticles(delta);
      } else if(eatParticles.length){
        eatParticles = [];
      }
      const themeGame = currentTheme?.game ?? THEMES.aurora.game;
      const boardStart = Array.isArray(themeGame.boardGradient) ? themeGame.boardGradient[0] : '#1a1a2e';
      const boardEnd = Array.isArray(themeGame.boardGradient) ? themeGame.boardGradient[1] : '#0f0f23';
      if(minimalRender){
        ctx.fillStyle = boardStart;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, boardStart);
        gradient.addColorStop(1, boardEnd);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = themeGame.grid ?? 'rgba(255, 255, 255, 0.02)';
        ctx.lineWidth = 1;
        for(let i = 0; i <= COLS; i++) {
          ctx.beginPath();
          ctx.moveTo(i * CELL, 0);
          ctx.lineTo(i * CELL, canvas.height);
          ctx.stroke();
        }
        for(let i = 0; i <= ROWS; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * CELL);
          ctx.lineTo(canvas.width, i * CELL);
          ctx.stroke();
        }
      }
      if(fruit && fruit.x >= 0){
        const centerX = fruit.x * CELL + CELL / 2;
        const centerY = fruit.y * CELL + CELL / 2;
        if(minimalRender){
          const appleRadius = CELL / 3;
          ctx.beginPath();
          ctx.arc(centerX, centerY, appleRadius, 0, 2 * Math.PI);
          ctx.fillStyle = themeGame.apple ?? '#d62828';
          ctx.fill();
        } else {
          const appleRadius = CELL / 2.6;
          const glowGradient = ctx.createRadialGradient(
            centerX, centerY, 0,
            centerX, centerY, CELL
          );
          glowGradient.addColorStop(0, themeGame.appleGlow ?? 'rgba(220, 38, 38, 0.5)');
          glowGradient.addColorStop(1, 'transparent');
          ctx.fillStyle = glowGradient;
          ctx.fillRect(fruit.x * CELL, fruit.y * CELL, CELL, CELL);
          ctx.beginPath();
          ctx.arc(centerX, centerY, appleRadius, 0, 2 * Math.PI);
          ctx.fillStyle = themeGame.apple ?? '#d62828';
          ctx.fill();
          ctx.lineWidth = Math.max(2, CELL / 8);
          ctx.strokeStyle = themeGame.appleStroke ?? '#111';
          ctx.stroke();
          ctx.lineWidth = 1;
          ctx.fillStyle = themeGame.appleHighlight ?? 'rgba(255, 255, 255, 0.3)';
          ctx.beginPath();
          ctx.arc(centerX - appleRadius / 2.2, centerY - appleRadius / 2.2, appleRadius / 4, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
      if(!minimalRender){
        eatParticles.forEach(p => {
          const alpha = Math.max(0, p.life / p.maxLife);
          const flare = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
          flare.addColorStop(0, `hsla(${p.hue}, 90%, 80%, ${alpha * 0.85})`);
          flare.addColorStop(0.6, `hsla(${p.hue}, 90%, 65%, ${alpha * 0.45})`);
          flare.addColorStop(1, `hsla(${p.hue}, 90%, 40%, 0)`);
          ctx.fillStyle = flare;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      const baseHead = themeGame.head ?? '#667eea';
      const headColor = hamMode
        ? themeGame.ham ?? '#4ade80'
        : compactMode
        ? themeGame.compact ?? '#f97316'
        : loopDetected
        ? themeGame.loop ?? '#fbbf24'
        : baseHead;
      const headAccent = hamMode
        ? themeGame.hamAccent ?? themeGame.ham ?? '#22c55e'
        : compactMode
        ? themeGame.compactAccent ?? themeGame.compact ?? '#ea580c'
        : loopDetected
        ? themeGame.loopAccent ?? themeGame.loop ?? '#f59e0b'
        : themeGame.headAccent ?? '#764ba2';
      const bodyStart = themeGame.bodyStart ?? '#8b5cf6';
      const bodyEnd = themeGame.bodyEnd ?? '#4338ca';
      snake.forEach((p, i) => {
        if(minimalRender){
          const ratio = snake.length > 1 ? i / (snake.length - 1) : 0;
          const baseColor = i === 0
            ? headColor
            : rgbToCss(mixHexColors(bodyStart, bodyEnd, ratio));
          ctx.fillStyle = baseColor;
          ctx.fillRect(p.x * CELL, p.y * CELL, CELL, CELL);
          return;
        }
        const isHead = i === 0;
        const size = CELL * 0.95;
        const offset = (CELL - size) / 2;
        const x = p.x * CELL + offset;
        const y = p.y * CELL + offset;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(x + 2, y + 2, size, size);
        const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
        if(isHead) {
          ctx.save();
          ctx.shadowColor = headAccent;
          ctx.shadowBlur = CELL * 0.6;
          ctx.fillStyle = headColor;
          ctx.fillRect(x, y, size, size);
          ctx.restore();
          gradient.addColorStop(0, headColor);
          gradient.addColorStop(1, headAccent);
        } else {
          const ratio = snake.length > 1 ? i / (snake.length - 1) : 0;
          const baseColor = mixHexColors(bodyStart, bodyEnd, ratio);
          const highlight = rgbToCss(lightenRgb(baseColor, 0.18));
          const shadow = rgbToCss(darkenRgb(baseColor, 0.2));
          gradient.addColorStop(0, highlight);
          gradient.addColorStop(1, shadow);
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, size, size);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(x, y, size, size/3);
        if(isHead) {
          ctx.fillStyle = '#fff';
          let eyeX1, eyeY1, eyeX2, eyeY2;
          if(snake.length > 1){
            const dx = p.x - snake[1].x;
            const dy = p.y - snake[1].y;
            if(dx === 1) {
              eyeX1 = x + size - size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size - size/4;
            } else if(dx === -1) {
              eyeX1 = x + size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size/4;
              eyeY2 = y + size - size/4;
            } else if(dy === 1) {
              eyeX1 = x + size/4;
              eyeY1 = y + size - size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size - size/4;
            } else {
              eyeX1 = x + size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size/4;
            }
            ctx.beginPath(); ctx.arc(eyeX1, eyeY1, size/10, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX2, eyeY2, size/10, 0, 2*Math.PI); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(eyeX1, eyeY1, size/20, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX2, eyeY2, size/20, 0, 2*Math.PI); ctx.fill();
          }
        }
      });
      if(performanceLengthEl){
        performanceLengthEl.textContent = snake.length;
      }
      if(minimalRender){
        return;
      }
      document.getElementById('strategyStatus').textContent = `Strategy: ${currentStrategy}`;
      document.getElementById('strategyExplanation').textContent = getStrategyExplanation(currentStrategy);
      const completionEl = document.getElementById('completionStatus');
      if(completionEl){
        if(completionMessage){
          completionEl.textContent = completionMessage;
          completionEl.hidden = false;
        } else {
          completionEl.textContent = '';
          completionEl.hidden = true;
        }
      }
      document.getElementById('hamStatus').textContent = hamMode ? "Following the Hamilton safety cycle." : "";
      document.getElementById('loopStatus').textContent = loopDetected ? `Detected a loop ‚Äì streak ${loopStreak}.` : "";
      document.getElementById('compactStatus').textContent = compactMode ? "Compressing the body to clear space." : "";
      document.getElementById('compactStepStatus').textContent = compactMode ? `Compact path step ${compactModeSteps} of ${COMPACT_MODE_MAX_STEPS}.` : "";
      const freeCellsCount = COLS * ROWS - snake.length;
      document.getElementById('snakeLength').textContent = snake.length;
      if(performanceLengthEl){
        performanceLengthEl.textContent = snake.length;
      }
      document.getElementById('freeCells').textContent = freeCellsCount;
      const progressRatio = snake.length / (COLS * ROWS);
      document.getElementById('progress').textContent = (progressRatio * 100).toFixed(1) + '%';
      updateProgressVisual(progressRatio);
      updateAppleStats();
      updateRlStatus();
    }

    function updateProgressVisual(progressRatio){
      if(!progressRingCircle || progressRingMaxLength == null) return;
      const clamped = Math.max(0, Math.min(1, progressRatio || 0));
      const offset = progressRingMaxLength * (1 - clamped);
      progressRingCircle.style.strokeDashoffset = offset;
      if(progressRingPercentLabel){
        progressRingPercentLabel.textContent = (clamped * 100).toFixed(1) + '%';
      }
    }

    function showOverlay(title, subtitle, color = currentTheme?.game?.danger ?? '#ef4444'){
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = color;
      ctx.font = 'bold 32px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(title, canvas.width / 2, canvas.height / 2);
      if(subtitle){
        ctx.fillStyle = '#fff';
        ctx.font = '20px Inter, sans-serif';
        ctx.fillText(subtitle, canvas.width / 2, canvas.height / 2 + 40);
      }
    }
    function scheduleAutoRestart(delay = 600, force = false){
      if(!rlTrainingEnabled) return;
      if(!force && !autoRestartEnabled) return;
      cancelScheduledAutoRestart();
      autoRestartTimer = setTimeout(() => {
        autoRestartTimer = null;
        if(!gameRunning){
          restartGame();
        }
      }, delay);
    }
    function handleSnakeDeath({ title = 'Crash! üí•', subtitle, color = currentTheme?.game?.danger ?? '#ef4444', penalty = rlConfig.deathPenalty, outcome = 'loss', componentId } = {}){
      const normalizedOutcome = typeof outcome === 'string' ? outcome.toLowerCase() : '';
      const isSelfInflicted = normalizedOutcome === 'self-crash' || normalizedOutcome === 'dead-end-crash';
      if(isSelfInflicted){
        consecutiveSelfCrashCount = Math.min(consecutiveSelfCrashCount + 1, 6);
      } else {
        consecutiveSelfCrashCount = 0;
      }
      if(rlTrainingEnabled){
        rlAgent.registerTerminal(outcome);
      }
      let penaltyValue = Number.isFinite(penalty) ? penalty : rlConfig.deathPenalty;
      if(isSelfInflicted && Number.isFinite(penaltyValue)){
        const streak = Math.min(Math.max(consecutiveSelfCrashCount - 1, 0), 6);
        const streakMultiplier = 1 + streak * 0.35;
        penaltyValue *= streakMultiplier;
      }
      let penaltyComponent = componentId && RL_REWARD_COMPONENT_MAP[componentId]
        ? componentId
        : null;
      if(!penaltyComponent){
        if(normalizedOutcome === 'dead-end-crash' || penaltyValue === rlConfig.deadEndPenalty || outcome === 'timeout'){
          penaltyComponent = 'deadEndPenalty';
        } else if(normalizedOutcome === 'wall-crash' || penaltyValue === rlConfig.wallCrashPenalty){
          penaltyComponent = 'wallCrashPenalty';
        } else if(isSelfInflicted || penaltyValue === rlConfig.selfCrashPenalty){
          penaltyComponent = 'selfCrashPenalty';
        } else {
          penaltyComponent = 'deathPenalty';
        }
      }
      const penaltyBreakdown = rlTrainingEnabled
        ? [{ id: penaltyComponent, amount: penaltyValue }]
        : null;
      applyRlUpdate(penaltyValue, true, { skipScaling: true, breakdown: penaltyBreakdown });
      clearInterval(loopHandle);
      gameRunning = false;
      finishRun(false);
      completionMessage = '';
      draw();
      showOverlay(title, subtitle ?? `Final length: ${snake.length}`, color);
      scheduleAutoRestart();
    }
    /* ===== UPDATE ===== */
    function update(){
      if(!snake.length){ clearInterval(loopHandle); gameRunning = false; finishRun(false); return; }
      if(runTimeoutDeadline !== null && performance.now() > runTimeoutDeadline){
        const timeoutPenalty = Number.isFinite(rlConfig.deadEndPenalty) ? rlConfig.deadEndPenalty : rlConfig.deathPenalty;
        handleSnakeDeath({
          title: 'Timeout ‚è±Ô∏è',
          subtitle: `Restart efter ${formatTime(runTimeoutMs)} utan framsteg.`,
          color: currentTheme?.game?.warning ?? '#fbbf24',
          penalty: timeoutPenalty,
          outcome: 'timeout',
          componentId: 'deadEndPenalty'
        });
        return;
      }
      let stepReward = rlConfig.stepPenalty;
      let rewardBreakdown = rlTrainingEnabled ? [{ id: 'stepPenalty', amount: rlConfig.stepPenalty }] : null;
      let stepDone = false;
      const headBeforeMove = snake[0];
      const fruitDistanceBefore = (fruit && fruit.x >= 0 && headBeforeMove)
        ? Math.abs(headBeforeMove.x - fruit.x) + Math.abs(headBeforeMove.y - fruit.y)
        : Infinity;
      const wallDistanceBefore = headBeforeMove ? distanceFromNearestWall(headBeforeMove) : 0;
      const freeNeighborsBeforeMove = countImmediateFreeNeighbors();
      const themeGame = currentTheme?.game ?? THEMES.aurora.game;
      const enclosedEmptyBefore = rlTrainingEnabled ? countEnclosedEmptyCells(snake) : null;
      const nxt = manualMode ? getManualNext() : getNext();
      if(!nxt){
        handleSnakeDeath({
          title: 'Dead end! üîí',
          subtitle: `Final length: ${snake.length}`,
          color: currentTheme?.game?.deadEnd ?? '#f97316',
          penalty: Number.isFinite(rlConfig.deadEndPenalty) ? rlConfig.deadEndPenalty : rlConfig.deathPenalty,
          outcome: 'dead-end-crash',
          componentId: 'deadEndPenalty'
        });
        return;
      }
      if(nxt.x < 0 || nxt.x >= COLS || nxt.y < 0 || nxt.y >= ROWS){
        handleSnakeDeath({
          title: 'Wall crash! üß±',
          subtitle: `Final length: ${snake.length}`,
          penalty: Number.isFinite(rlConfig.wallCrashPenalty) ? rlConfig.wallCrashPenalty : rlConfig.deathPenalty,
          outcome: 'wall-crash',
          componentId: 'wallCrashPenalty'
        });
        return;
      }
      if(loopDetected){
        persistentLoopCounter++;
      } else {
        persistentLoopCounter = 0;
      }
      if(rlTrainingEnabled && persistentLoopCounter >= LOOP_ESCAPE_LIMIT){
        const loopPenalty = typeof rlConfig.loopPenalty === 'number' ? rlConfig.loopPenalty : rlConfig.stepPenalty;
        const loopBreakdown = rlTrainingEnabled ? [{ id: 'loopPenalty', amount: loopPenalty }] : null;
        applyRlUpdate(loopPenalty, true, { breakdown: loopBreakdown });
        rlAgent.registerTerminal('stalled');
        clearInterval(loopHandle);
        gameRunning = false;
        finishRun(false);
        draw();
        showOverlay('Loop limit reached ‚Äì advancing episode', '', currentTheme?.game?.warning ?? '#fbbf24');
        scheduleAutoRestart(450, true);
        persistentLoopCounter = 0;
        return;
      }
      if(rlTrainingEnabled){
        if(endgamePlanThisMove){
          stepReward += rlConfig.endgamePlanReward;
          rewardBreakdown?.push({ id: 'endgamePlanReward', amount: rlConfig.endgamePlanReward });
        }
        if(compactModeJustActivated){
          stepReward += rlConfig.compactModeReward;
          rewardBreakdown?.push({ id: 'compactModeReward', amount: rlConfig.compactModeReward });
        } else if(compactMode && currentStrategy === 'Compact zig-zag'){
          const compactBonus = rlConfig.compactModeReward * 0.5;
          stepReward += compactBonus;
          rewardBreakdown?.push({ id: 'compactModeReward', amount: compactBonus });
        }
      }
      compactModeJustActivated = false;
      const ate = fruit && fruit.x >= 0 && nxt.x === fruit.x && nxt.y === fruit.y;
      const nextKey = `${nxt.x},${nxt.y}`;
      const tail = snake[snake.length - 1];
      const isTailStep = snake.length > 1 && nxt.x === tail.x && nxt.y === tail.y;
      if(snakeSet.has(nextKey) && !(isTailStep && !ate)){
        const forcedCrash = freeNeighborsBeforeMove === 0;
        handleSnakeDeath({
          title: forcedCrash ? 'Dead end! üîí' : 'Self crash! ‚ôªÔ∏è',
          subtitle: `Final length: ${snake.length}`,
          color: forcedCrash
            ? currentTheme?.game?.deadEnd ?? '#f97316'
            : currentTheme?.game?.danger ?? '#ef4444',
          penalty: forcedCrash
            ? (Number.isFinite(rlConfig.deadEndPenalty) ? rlConfig.deadEndPenalty : rlConfig.deathPenalty)
            : (Number.isFinite(rlConfig.selfCrashPenalty) ? rlConfig.selfCrashPenalty : rlConfig.deathPenalty),
          outcome: forcedCrash ? 'dead-end-crash' : 'self-crash',
          componentId: forcedCrash ? 'deadEndPenalty' : 'selfCrashPenalty'
        });
        return;
      }
      const atePosition = ate ? {x: fruit.x, y: fruit.y} : null;
      if(!ate){
        const removed = snake.pop();
        snakeSet.delete(`${removed.x},${removed.y}`);
      }
      snake.unshift({x: nxt.x, y: nxt.y});
      snakeSet.add(`${nxt.x},${nxt.y}`);
      if(ate){
        loopCountAdjust = 0;
        stepReward = rlConfig.fruitReward;
        rewardBreakdown = rlTrainingEnabled ? [{ id: 'fruitReward', amount: rlConfig.fruitReward }] : rewardBreakdown;
        applesEaten++;
        if(applesEaten > appleHighScore){
          appleHighScore = applesEaten;
        }
        updateAppleStats();
        if(snake.length === COLS * ROWS){
          if(rlTrainingEnabled){
            rlAgent.registerTerminal('win');
          }
          fruit = {x: -1, y: -1};
          stepReward = rlConfig.winBonus;
          rewardBreakdown = rlTrainingEnabled ? [{ id: 'winBonus', amount: rlConfig.winBonus }] : rewardBreakdown;
          const runDurationMs = startTime !== null ? performance.now() - startTime : lastElapsedMs;
          const brokeRecord = Number.isFinite(runDurationMs) && (bestTimeMs === null || runDurationMs < bestTimeMs);
          if(brokeRecord && rlTrainingEnabled){
            const recordBonus = Number.isFinite(rlConfig.bestTimeBonus) ? rlConfig.bestTimeBonus : 0;
            if(recordBonus !== 0){
              stepReward += recordBonus;
              rewardBreakdown?.push({ id: 'bestTimeBonus', amount: recordBonus });
            }
          }
          stepDone = true;
          completionMessage = '‚úÖ Banan klar! Ormen fyllde hela br√§det.';
          applyRlUpdate(stepReward, stepDone, { breakdown: rewardBreakdown });
          draw();
          clearInterval(loopHandle);
          gameRunning = false;
          finishRun(true);
          completedRounds++;
          updateCompletedRoundsDisplay();
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const winGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          winGradient.addColorStop(0, themeGame.head ?? '#667eea');
          winGradient.addColorStop(0.5, themeGame.loop ?? themeGame.headAccent ?? '#f093fb');
          winGradient.addColorStop(1, themeGame.headAccent ?? '#764ba2');
          ctx.fillStyle = winGradient;
          ctx.font = 'bold 48px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText("PERFECT! üèÜ", canvas.width/2, canvas.height/2);
          ctx.fillStyle = '#fff';
          ctx.font = '24px Inter, sans-serif';
          ctx.fillText("You filled the entire board!", canvas.width/2, canvas.height/2 + 50);
          scheduleAutoRestart();
          return;
        } else {
          fruit = spawnFruit();
          prevFruitDist = (fruit.x >= 0) ? Math.abs(snake[0].x - fruit.x) + Math.abs(snake[0].y - fruit.y) : Infinity;
          noProgressMoves = 0;
        }
        // Skip particle bursts to keep apple pickups smooth.
        resetRunTimeoutDeadline();
      }
      if(rlTrainingEnabled && !stepDone){
        if(enclosedEmptyBefore !== null){
          const enclosedEmptyAfter = countEnclosedEmptyCells(snake);
          const pocketDelta = enclosedEmptyBefore - enclosedEmptyAfter;
          if(pocketDelta !== 0){
            const pocketReward = pocketDelta * rlConfig.pocketFillReward;
            if(pocketReward !== 0){
              stepReward += pocketReward;
              rewardBreakdown?.push({ id: 'pocketFillReward', amount: pocketReward });
            }
          }
        }
        if(!ate){
          if(fruit && fruit.x >= 0 && Number.isFinite(fruitDistanceBefore)){
            const currentFruitDistance = Math.abs(snake[0].x - fruit.x) + Math.abs(snake[0].y - fruit.y);
            const distanceDelta = fruitDistanceBefore - currentFruitDistance;
            if(distanceDelta !== 0){
              const approachReward = distanceDelta * rlConfig.fruitApproachReward;
              if(approachReward !== 0){
                stepReward += approachReward;
                rewardBreakdown?.push({ id: 'fruitApproachReward', amount: approachReward });
              }
            }
          }
          const currentWallDistance = distanceFromNearestWall(snake[0]);
          const wallDelta = currentWallDistance - wallDistanceBefore;
          if(wallDelta !== 0){
            const wallReward = wallDelta * rlConfig.wallDistanceReward;
            if(wallReward !== 0){
              stepReward += wallReward;
              rewardBreakdown?.push({ id: 'wallDistanceReward', amount: wallReward });
            }
          }
        }
        const trapPenalty = typeof rlConfig.deadEndPenalty === 'number' ? rlConfig.deadEndPenalty : 0;
        if(trapPenalty){
          const upcomingSafeMoves = getSafeMovesForRL();
          const freeCellsRemaining = COLS * ROWS - snake.length;
          if(Array.isArray(upcomingSafeMoves) && freeCellsRemaining > 0){
            if(upcomingSafeMoves.length === 0){
              stepReward += trapPenalty;
              rewardBreakdown?.push({ id: 'deadEndPenalty', amount: trapPenalty });
            } else if(upcomingSafeMoves.length === 1 && freeCellsRemaining > 2){
              const onlyMove = upcomingSafeMoves[0];
              const upcomingTail = snake.length > 1 ? snake[snake.length - 1] : null;
              const isTailEscape = upcomingTail && !onlyMove.ate && onlyMove.x === upcomingTail.x && onlyMove.y === upcomingTail.y;
              if(!isTailEscape){
                const partialPenalty = trapPenalty * 0.5;
                stepReward += partialPenalty;
                rewardBreakdown?.push({ id: 'deadEndPenalty', amount: partialPenalty });
              }
            }
          }
        }
      }
      applyRlUpdate(stepReward, stepDone, { breakdown: rewardBreakdown });
      draw();
    }
    /* ===== SPEED CONTROLS & STARTUP ===== */
    document.getElementById('slowerBtn').onclick = () => changeSpeed(SPEED + SPEED_STEP);
    document.getElementById('fasterBtn').onclick = () => changeSpeed(SPEED - SPEED_STEP);
    function changeSpeed(v){
      v = Math.max(MIN_SPEED, Math.min(MAX_SPEED, v));
      if(v !== SPEED){
        SPEED = v;
        document.getElementById('speedDisplay').textContent = `Speed: ${SPEED}ms`;
        if(gameRunning) {
          clearInterval(loopHandle);
          loopHandle = setInterval(update, SPEED);
        }
      }
    }
    async function trainSnakeAgent(episodes = 10, options = {}){
      if(typeof episodes !== 'number' || episodes <= 0) throw new Error('Episodes must be a positive number.');
      const mergedOptions = {
        ...options,
        parallelSnakes: options.parallelSnakes ?? rlConfig.parallelSnakes,
        cols: options.cols ?? COLS,
        rows: options.rows ?? ROWS
      };
      return rlAgent.startTraining(episodes, mergedOptions);
    }
    window.trainSnakeAgent = trainSnakeAgent;
    window.rlAgent = rlAgent;
    /* ===== PRESET LOADING ===== */
    const presetButtons = document.querySelectorAll('.load-preset');
    presetButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        // flag to prevent dynamic recalculation when grid size changes
        window.loadingPreset = true;
        if (preset === 'small') {
          colsSlider.value = 10; rowsSlider.value = 10; updateGridSize();
          LOOP_STREAK_THRESHOLD = 1; loopThreshSlider.value = 1; document.getElementById('loopThreshValue').textContent = 1;
          NO_PROGRESS_THRESHOLD = 30; progThreshSlider.value = 30; document.getElementById('progThreshValue').textContent = 30;
          ENDGAME_THRESHOLD = 5; endgameSlider.value = 5; document.getElementById('endgameValue').textContent = 5;
          COMPACT_MODE_MAX_STEPS = 50; compactSlider.value = 50; document.getElementById('compactValue').textContent = 50;
          updateCompactProfile('cautious');
          changeSpeed(120);
        } else if (preset === 'balanced') {
          colsSlider.value = 20; rowsSlider.value = 20; updateGridSize();
          LOOP_STREAK_THRESHOLD = 3; loopThreshSlider.value = 3; document.getElementById('loopThreshValue').textContent = 3;
          NO_PROGRESS_THRESHOLD = 70; progThreshSlider.value = 70; document.getElementById('progThreshValue').textContent = 70;
          ENDGAME_THRESHOLD = 40; endgameSlider.value = 40; document.getElementById('endgameValue').textContent = 40;
          COMPACT_MODE_MAX_STEPS = 200; compactSlider.value = 200; document.getElementById('compactValue').textContent = 200;
          updateCompactProfile('balanced');
          changeSpeed(80);
        } else if (preset === 'ultra') {
          colsSlider.value = 30; rowsSlider.value = 30; updateGridSize();
          LOOP_STREAK_THRESHOLD = 5; loopThreshSlider.value = 5; document.getElementById('loopThreshValue').textContent = 5;
          NO_PROGRESS_THRESHOLD = 150; progThreshSlider.value = 150; document.getElementById('progThreshValue').textContent = 150;
          ENDGAME_THRESHOLD = 80; endgameSlider.value = 80; document.getElementById('endgameValue').textContent = 80;
          COMPACT_MODE_MAX_STEPS = 450; compactSlider.value = 450; document.getElementById('compactValue').textContent = 450;
          updateCompactProfile('risky');
          changeSpeed(40);
        }
        window.loadingPreset = false;
        restartGame();
      });
    });
    // initial start
    restartGame();
    document.getElementById('colsValue').textContent = COLS;
    document.getElementById('rowsValue').textContent = ROWS;
    document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
    updateCompactProfile(COMPACT_MODE_PROFILE);
  </script>

  <div id="helpOverlay" class="help-overlay" hidden>
    <div class="help-card" role="dialog" aria-modal="true" aria-labelledby="helpOverlayTitle">
      <h2 id="helpOverlayTitle">Keyboard shortcuts</h2>
      <ul>
        <li><kbd>?</kbd> <span>Toggle this help overlay</span></li>
        <li><kbd>Space</kbd> <span>Toggle manual / AI control</span></li>
        <li><kbd>WASD</kbd> / <kbd>Arrow keys</kbd> <span>Steer the snake in manual mode</span></li>
      </ul>
      <button type="button" id="helpCloseBtn" class="button">Got it</button>
    </div>
  </div>
</body>
</html>
