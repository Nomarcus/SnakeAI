<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake AI - Intelligent Snake Experience</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --accent: #f093fb;
      --success: #4ade80;
      --danger: #ef4444;
      --warning: #fbbf24;
      --dark: #1a1a2e;
      --darker: #0f0f23;
      --light: #eef2ff;
      --text: #e2e8f0;
      --glass: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.2);
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
      min-height: 100vh;
      color: var(--text);
      overflow-x: hidden;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
      opacity: 0.03;
      animation: rotate 60s linear infinite;
      z-index: -1;
    }

    @keyframes rotate {
      to { transform: rotate(360deg); }
    }

    /* Navigation */
    nav {
      background: var(--glass);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--glass-border);
      padding: 1rem 2rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .nav-container {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-size: 1.8rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .logo::before {
      content: 'üêç';
      font-size: 2rem;
      -webkit-text-fill-color: initial;
    }

    .nav-links {
      display: flex;
      gap: 2rem;
      list-style: none;
    }

    .nav-links a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      transition: all 0.3s;
      position: relative;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
    }

    .nav-links a:hover {
      color: var(--accent);
      background: var(--glass);
    }

    .nav-links a.active {
      color: var(--accent);
      background: var(--glass);
    }

    /* Page transitions */
    .page {
      display: none;
      animation: fadeIn 0.5s ease-in-out;
    }

    .page.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Main container */
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 3rem 2rem;
    }

    /* Hero section */
    .hero {
      text-align: center;
      margin-bottom: 3rem;
    }

    .hero h1 {
      font-size: 3.5rem;
      font-weight: 900;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, var(--light) 0%, var(--accent) 50%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient 3s ease-in-out infinite;
      background-size: 200%;
    }

    @keyframes gradient {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .hero p {
      font-size: 1.2rem;
      color: var(--text);
      opacity: 0.8;
      max-width: 600px;
      margin: 0 auto;
    }

    /* Game section */
    .game-wrapper {
      display: flex;
      gap: 3rem;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
    }

    .game-container {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 2rem;
      padding: 2rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }

    .game-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, var(--accent), var(--primary), var(--secondary));
      border-radius: 2rem;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .game-container:hover::before {
      opacity: 0.5;
    }

    #game {
      border-radius: 1rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s;
    }

    #game:hover {
      transform: scale(1.02);
    }

    /* Controls panel */
    .controls-panel {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      min-width: 350px;
      max-width: 400px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      max-height: 90vh;
      overflow-y: auto;
    }

    .controls-panel::-webkit-scrollbar {
      width: 8px;
    }

    .controls-panel::-webkit-scrollbar-track {
      background: var(--darker);
      border-radius: 4px;
    }

    .controls-panel::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 4px;
    }

    .controls-section {
      margin-bottom: 2rem;
    }

    .controls-section h3 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .controls-section h3::before {
      content: '‚ö°';
      font-size: 1.5rem;
    }

    /* Modern buttons */
    .button {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      position: relative;
      overflow: hidden;
    }

    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      transition: left 0.5s;
    }

    .button:hover::before {
      left: 100%;
    }

    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }

    .button:active {
      transform: translateY(0);
    }

    .button.danger {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
    }

    .button.danger:hover {
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.6);
    }

    /* Speed controls */
    .speed-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      justify-content: center;
      margin: 1rem 0;
    }

    .speed-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.2rem;
      padding: 0.8rem 1.2rem;
      min-width: 100px;
    }

    .speed-btn span {
      display: block;
    }

    .speed-display {
      background: var(--darker);
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      min-width: 140px;
      text-align: center;
      font-weight: 600;
      border: 1px solid var(--primary);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
    }

    /* Size controls */
    .size-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin: 1rem 0;
    }

    .size-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 8px;
      background: var(--darker);
      border-radius: 4px;
      outline: none;
      position: relative;
    }

    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
      transition: all 0.3s;
    }

    .size-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
    }

    /* Parameter controls */
    .param-control {
      margin-bottom: 1.5rem;
    }

    .param-control label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--text);
    }

    .param-control label span {
      color: var(--accent);
      font-weight: 700;
      min-width: 40px;
      text-align: right;
    }

    .param-control small {
      display: block;
      margin-top: 0.3rem;
      color: var(--text);
      opacity: 0.6;
      font-size: 0.8rem;
    }

    .param-control .size-slider {
      width: 100%;
    }

    /* Status display */
    .status-display {
      background: var(--darker);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-top: 1rem;
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .status-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--glass-border);
    }

    .status-item:last-child {
      border-bottom: none;
    }

    .status-label {
      color: var(--text);
      opacity: 0.8;
    }

    .status-value {
      font-weight: 600;
      color: var(--accent);
    }

    /* AI Status messages */
    #statusMessages {
      background: var(--darker);
      border-radius: 1rem;
      padding: 1rem;
      margin-top: 1rem;
      min-height: 120px;
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    #statusMessages p {
      margin: 0.3rem 0;
      font-size: 0.9rem;
      opacity: 0.9;
    }

    #strategyStatus {
      color: var(--accent);
      font-weight: 600;
      font-size: 1rem;
    }

    #hamStatus { color: #4ade80; }
    #loopStatus { color: #fbbf24; }
    #compactStatus { color: #f97316; }

    /* Info page */
    .info-content {
      max-width: 800px;
      margin: 0 auto;
    }

    .info-section {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .info-section h2 {
      color: var(--accent);
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }

    .info-section h3 {
      color: var(--primary);
      margin: 1.5rem 0 1rem;
    }

    .info-section p, .info-section li {
      line-height: 1.8;
      opacity: 0.9;
    }

    .info-section ul {
      list-style: none;
      padding-left: 0;
    }

    .info-section li {
      position: relative;
      padding-left: 2rem;
      margin-bottom: 0.5rem;
    }

    .info-section li::before {
      content: '‚Üí';
      position: absolute;
      left: 0;
      color: var(--accent);
      font-weight: bold;
    }

    /* Contact page */
    .contact-content {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }

    .contact-card {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 3rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .contact-card h2 {
      color: var(--accent);
      margin-bottom: 2rem;
      font-size: 2rem;
    }

    .contact-info {
      font-size: 1.2rem;
      margin: 2rem 0;
    }

    .contact-email {
      display: inline-block;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 1rem 2rem;
      border-radius: 2rem;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      margin-top: 1rem;
    }

    .contact-email:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }

    /* Combo preset styling */
    .combo-preset {
      background: var(--darker);
      padding: 1.5rem;
      border-radius: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--primary);
    }

    .combo-preset ul {
      margin-bottom: 1rem;
    }

    .combo-preset li {
      padding-left: 1.5rem;
      font-family: monospace;
      font-size: 1.1rem;
      color: var(--accent);
    }

    .load-preset {
      width: 100%;
      background: linear-gradient(135deg, var(--primary), var(--accent));
    }

    /* Responsive */
    @media (max-width: 768px) {
      .nav-container {
        flex-direction: column;
        gap: 1rem;
      }

      .hero h1 {
        font-size: 2.5rem;
      }

      .game-wrapper {
        flex-direction: column;
      }

      .controls-panel {
        width: 100%;
        max-width: none;
        max-height: none;
      }
    }
  </style>
</head>

<body>
  <!-- Navigation -->
  <nav>
    <div class="nav-container">
      <div class="logo">Snake AI</div>
      <ul class="nav-links">
        <li><a href="#" class="nav-link active" data-page="game">Game</a></li>
        <li><a href="#" class="nav-link" data-page="guide">Guide</a></li>
        <li><a href="#" class="nav-link" data-page="facit">Presets</a></li>
        <li><a href="#" class="nav-link" data-page="info">About</a></li>
        <li><a href="#" class="nav-link" data-page="contact">Contact</a></li>
      </ul>
    </div>
  </nav>

  <!-- Game Page -->
  <div id="game-page" class="page active">
    <div class="container">
      <div class="hero">
        <h1>Snake AI</h1>
        <p>Experience the perfect Snake AI algorithms</p>
		<p>Your goal is to find the best adjustments to complete the board</p>
		<p>If the snake get stuck in a lopp just restart</p>
      </div>

      <div class="game-wrapper">
        <div class="game-container">
          <canvas id="game" width="600" height="600"></canvas>
        </div>
        <div class="controls-panel">
          <div class="controls-section">
            <h3>Game Controls</h3>
            
            <div class="speed-controls">
              <button id="slowerBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">üêå</span>
                <span>Slower</span>
              </button>
              <div id="speedDisplay" class="speed-display">Speed: 150ms</div>
              <button id="fasterBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">‚ö°</span>
                <span>Faster</span>
              </button>
            </div>

            <div style="margin-top: 1rem;">
              <button id="restartBtn" class="button danger" style="width: 100%;">üîÑ Restart</button>
            </div>
          </div>

          <div class="controls-section">
            <h3>Grid Size</h3>
            <div class="param-control">
              <label>Columns (COLS): <span id="colsValue">10</span></label>
              <input type="range" id="colsSlider" class="size-slider" min="10" max="100" value="10" step="10">
            </div>
            <div class="param-control">
              <label>Rows (ROWS): <span id="rowsValue">10</span></label>
              <input type="range" id="rowsSlider" class="size-slider" min="10" max="100" value="10" step="10">
            </div>
            <small style="display: block; margin-top: -0.5rem; color: var(--warning); opacity: 0.8;">
              ‚ö° Changing grid size will restart the game
            </small>
          </div>

          <div class="controls-section">
            <h3>Canvas Size</h3>
            <div class="size-controls">
              <span>Small</span>
              <input type="range" id="sizeSlider" class="size-slider" min="300" max="800" value="400" step="50">
              <span>Large</span>
            </div>
          </div>

          <div class="controls-section">
            <h3>AI Parameters</h3>
            
            <div class="param-control">
              <label>Loop Streak Threshold: <span id="loopThreshValue">1</span></label>
              <input type="range" id="loopThreshSlider" class="size-slider" min="1" max="10" value="1" step="1">
              <small>Loops detected before ‚Üí Hamilton mode</small>
            </div>
            
            <div class="param-control">
              <label>No Progress Threshold: <span id="progThreshValue">50</span></label>
              <input type="range" id="progThreshSlider" class="size-slider" min="10" max="200" value="50" step="5">
              <small>Moves without progress ‚Üí Hamilton mode</small>
            </div>
            
            <div class="param-control">
              <label>Endgame Threshold: <span id="endgameValue">5</span></label>
              <input type="range" id="endgameSlider" class="size-slider" min="0" max="100" value="5" step="5">
              <small>Free cells for endgame mode</small>
            </div>
            
            <div class="param-control">
              <label>Compact Mode Steps: <span id="compactValue">100</span></label>
              <input type="range" id="compactSlider" class="size-slider" min="0" max="300" value="112" step="10">
              <small>Max steps in compact mode</small>
            </div>
          </div>
          <div class="controls-section">
            <h3>Game Status</h3>
            <div class="status-display">
              <div class="status-item">
                <span class="status-label">Length:</span>
                <span id="snakeLength" class="status-value">3</span>
              </div>
              <div class="status-item">
                <span class="status-label">Free cells:</span>
                <span id="freeCells" class="status-value">222</span>
              </div>
              <div class="status-item">
                <span class="status-label">Progress:</span>
                <span id="progress" class="status-value">1.3%</span>
              </div>
            </div>
          </div>

          <div class="controls-section">
            <h3>AI Status</h3>
            <div id="statusMessages">
              <p id="strategyStatus">Strategy: Initializing</p>
              <p id="hamStatus"></p>
              <p id="loopStatus"></p>
              <p id="compactStatus"></p>
              <p id="compactStepStatus"></p>
            </div>
          </div>
		  <div class="info-section" style="background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white;">
          <h2>üíæ Save Your Combination</h2>
          <p>Found the perfect combination? Share it with us!</p>
          <button id="saveComboBtn" class="button" style="background: white; color: var(--primary); margin-top: 1rem;">
            üì§ Save & Send Combination
          </button>
          <div id="savedCombo" style="display: none; margin-top: 1rem; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 0.5rem;">
            <p style="font-weight: bold;">Your combination:</p>
            <pre id="comboText" style="font-family: monospace; margin: 0.5rem 0;"></pre>
            <p style="font-size: 0.9rem; opacity: 0.8;">Copy and send to: nomarcus@hotmail.com</p>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Guide Page -->
  <div id="guide-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Parameter Guide</h1>
        <p>Learn to fine-tune the AI for optimal performance</p>
      </div>

      <div class="info-content">
        <div class="info-section">
          <h2>üéØ Quick Guide</h2>
          <p>Each parameter affects how cautious or aggressive the AI is. Find the balance between speed and safety!</p>
        </div>

        <div class="info-section">
          <h2>üìè Grid Size</h2>
          
          <h3>Columns & Rows (10-60)</h3>
          <p><strong>What it does:</strong> Determines the game size - number of cells horizontally and vertically.</p>
          <ul>
            <li><strong>Small grids (10x10):</strong> Fast games, AI must be very careful</li>
            <li><strong>Medium (20x20):</strong> Balanced gameplay, standard setting</li>
            <li><strong>Large (30x30):</strong> Long games requiring patience, AI can take more risks</li>
          </ul>
          <p><strong>Tip:</strong> Start with 10x10 to learn the parameters.</p>
        </div>

        <div class="info-section">
          <h2>ü§ñ AI Parameters</h2>
          
          <h3>1. Loop Streak Threshold (1-10)</h3>
          <p><strong>What it does:</strong> Number of times AI can loop before switching to safe Hamilton mode.</p>
          <ul>
            <li><strong>Low value (1-3):</strong> Quickly switches to safe mode, good for small grids</li>
            <li><strong>Medium (4-6):</strong> Balanced, allows some loops</li>
            <li><strong>High (7-10):</strong> Allows many loops, risky but faster</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase if snake gets stuck in Hamilton too often. Decrease if it dies in loops.</p>

          <h3>2. No Progress Threshold (10-200+)</h3>
          <p><strong>What it does:</strong> Number of moves without getting closer to fruit before AI gives up and goes safe.</p>
          <ul>
            <li><strong>Low value (10-50):</strong> Gives up quickly, very safe</li>
            <li><strong>Medium (50-100):</strong> Standard patience</li>
            <li><strong>High (100+):</strong> Persistent, keeps trying for a long time</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase for larger grids where navigation takes time. Decrease if snake "wanders" too much.</p>

          <h3>3. Endgame Threshold (10-100+)</h3>
          <p><strong>What it does:</strong> When there are fewer than X free cells left, endgame strategy activates.</p>
          <ul>
            <li><strong>Low value (10-30):</strong> Endgame only at the very end</li>
            <li><strong>Medium (40-60):</strong> Safer, activates earlier</li>
            <li><strong>High (70+):</strong> Very cautious, goes safe early</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase for harder/larger grids. Decrease for faster games on small grids.</p>

          <h3>4. Compact Mode Steps (50-300+)</h3>
          <p><strong>What it does:</strong> Max steps AI can use zig-zag pattern in tight spaces.</p>
          <ul>
            <li><strong>Low value (50-100):</strong> Short zig-zag, switches quickly</li>
            <li><strong>Medium (100-200):</strong> Standard length</li>
            <li><strong>High (200+):</strong> Long zig-zag sequences</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase for larger grids. Decrease if snake "vibrates" too much.</p>
        </div>

        <div class="info-section">
          <h2>‚ö° Optimization Strategy</h2>
          
          <h3>For fastest possible game:</h3>
          <ul>
            <li>Loop Threshold: 5-7</li>
            <li>No Progress: 80-120</li>
            <li>Endgame: 20-30</li>
            <li>Compact Steps: 150-200</li>
          </ul>

          <h3>For safest possible game:</h3>
          <ul>
            <li>Loop Threshold: 1-2</li>
            <li>No Progress: 30-50</li>
            <li>Endgame: 60-80</li>
            <li>Compact Steps: 50-100</li>
          </ul>

          <h3>Balanced (recommended):</h3>
          <ul>
            <li>Loop Threshold: 3-4</li>
            <li>No Progress: 50-80</li>
            <li>Endgame: 40-50</li>
            <li>Compact Steps: 100-150</li>
          </ul>
        </div>
        
      </div>
    </div>
  </div>

  <!-- Facit Page -->
  <div id="facit-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Presets - Proven Combinations</h1>
        <p>Test these optimized settings for different game types</p>
      </div>
     <div class="info-section">
          <h2>üêú Small Grid (10x10)</h2>
          <p><strong>Goal:</strong> Optimized for small, tight spaces</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 10x10</li>
              <li>Loop Threshold: 1</li>
              <li>No Progress: 50</li>
              <li>Endgame: 10</li>
              <li>Compact Steps: 100</li>
              <li>Speed: 150ms</li>
            </ul>
            <button class="button load-preset" data-preset="small">Load this</button>
          </div>
        </div>
            <div class="info-section">
          <h2>‚öñÔ∏è Balanced (20x20)</h2>
          <p><strong>Goal:</strong> Good balance between speed and safety</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 20x20</li>
              <li>Loop Threshold: 3</li>
              <li>No Progress: 70</li>
              <li>Endgame: 30</li>
              <li>Compact Steps: 200</li>
              <li>Speed: 75ms</li>
            </ul>
            <button class="button load-preset" data-preset="balanced">Load this</button>
          </div>
        </div>

   

        <div class="info-section">
          <h2>üéØ Ultra Challenge (30x30)</h2>
          <p><strong>Goal:</strong> For experts - maximum grid with aggressive settings</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 30x30</li>
              <li>Loop Threshold: 8</li>
              <li>No Progress: 200</li>
              <li>Endgame: 100</li>
              <li>Compact Steps: 450</li>
              <li>Speed: 10ms</li>
            </ul>
            <button class="button load-preset" data-preset="ultra">Load this</button>
          </div>
        </div>

        <div class="info-section" style="background: var(--glass); border: 2px solid var(--accent);">
          <h2>üí° Tips for Custom Combinations</h2>
          <ul>
            <li><strong>Start conservatively:</strong> Set low thresholds and increase gradually</li>
            <li><strong>Test in stages:</strong> Run 5-10 games before adjusting</li>
            <li><strong>Document:</strong> Write down what works for different grid sizes</li>
            <li><strong>Experiment:</strong> Try extreme values to understand the effect</li>
            <li><strong>Share:</strong> Send us your best combinations!</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- Info Page -->
  <div id="info-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>About Snake AI</h1>
        <p>A deep dive into the technology behind the intelligent game</p>
      </div>

      <div class="info-content">
        <div class="info-section">
          <h2>üß† AI Technology</h2>
          <p>Snake AI uses a sophisticated combination of algorithms to navigate efficiently:</p>
          
          <h3>Hamilton Cycle</h3>
          <p>A guaranteed path that visits every cell exactly once. This is used as a fallback when other strategies fail.</p>
          
          <h3>Adaptive Strategy</h3>
          <ul>
            <li>Greedy pathfinding for quick fruit collection</li>
            <li>Loop detection to avoid dead ends</li>
            <li>Compact mode for tight navigation</li>
            <li>Endgame optimization when the board fills up</li>
          </ul>

          <h3>Adjustable Parameters</h3>
          <ul>
            <li><strong>Loop Streak Threshold:</strong> How many times a loop must be detected before Hamilton mode activates</li>
            <li><strong>No Progress Threshold:</strong> Number of moves without progress before Hamilton mode is forced</li>
            <li><strong>Endgame Threshold:</strong> Number of free cells that triggers endgame strategy</li>
            <li><strong>Compact Mode Steps:</strong> Maximum steps in compact zig-zag mode</li>
          </ul>
        </div>
	

  


      </div>
    </div>
  </div>

  <!-- Contact Page -->
<div id="contact-page" class="page">
  <div class="container">
    <div class="hero">
      <h1>Contact Me</h1>
      <p>Have questions or feedback?</p>
    </div>

    <div class="contact-content">
      <div class="contact-card">
        <h2>üì¨ Get in Touch</h2>
        <p class="contact-info">
        </p>

        <a href="mailto:nomarcus@hotmail.com" class="contact-email">
          ‚úâÔ∏è nomarcus@hotmail.com
        </a>

        <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <p style="
            margin-top:2rem;
            font-size:.9rem;
            opacity:.7;
            text-align:center;
        ">
          Created by <strong>Marcus Petersson</strong> ¬∑ 2025-05-25
        </p>
        <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
      </div>
    </div>
  </div>
</div>


  <script>
    /* ===== KONFIGURATION ===== */
    let COLS = 10, ROWS = 10;
    let CELL = 60;
    let SPEED = 100;
    const DIRS = [ {dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0} ];
    const MAX_SPEED = 500, MIN_SPEED = 1, SPEED_STEP = 10;

    /* ===== DYNAMISKA TR√ñSKLAR ===== */
    let ENDGAME_THRESHOLD = 5;
    let MAX_LOOP_DETECTION = Math.max(8,(COLS+ROWS)/2|0);
    let WINDOW_SIZE = 0;
    let FILL_POCKET_LIMIT = COLS * 4;

    /* ===== CANVAS ===== */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    /* ===== AI-PARAMETRAR ===== */
    let LOOP_STREAK_THRESHOLD = 1;
    let NO_PROGRESS_THRESHOLD = 50;
    let COMPACT_MODE_MAX_STEPS = 100;

    /* ===== SPELSTATE ===== */
    let snake=[], snakeSet=new Set();
    let fruit, prevFruitDist=Infinity, noProgressMoves=0;
    let lastMoves=[], windowMoves=[], loopDetected=false, loopStreak=0,
        hamMode=false, compactMode=false, compactModeSteps=0,
        loopHandle=null, currentStrategy="Initializing";
    let gameRunning = false;

    /* ===== PAGE NAVIGATION ===== */
    const navLinks = document.querySelectorAll('.nav-link');
    const pages = document.querySelectorAll('.page');

    navLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetPage = link.dataset.page;
        
        // Update active states
        navLinks.forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        
        // Show target page
        pages.forEach(p => p.classList.remove('active'));
        document.getElementById(`${targetPage}-page`).classList.add('active');
      });
    });

    /* ===== SIZE CONTROL ===== */
    const sizeSlider = document.getElementById('sizeSlider');
    sizeSlider.addEventListener('input', (e) => {
      const size = parseInt(e.target.value);
      canvas.width = size;
      canvas.height = size;
      CELL = size / COLS;
      if (gameRunning) draw();
    });

    /* ===== GRID CONTROLS ===== */
    const colsSlider = document.getElementById('colsSlider');
    const rowsSlider = document.getElementById('rowsSlider');
    
    function updateGridSize() {
      const newCols = parseInt(colsSlider.value);
      const newRows = parseInt(rowsSlider.value);
      
      // Only update if actually changed
      if(newCols !== COLS || newRows !== ROWS) {
        COLS = newCols;
        ROWS = newRows;
        document.getElementById('colsValue').textContent = COLS;
        document.getElementById('rowsValue').textContent = ROWS;
        
        // Recalculate dependent values
        CELL = canvas.width / COLS;
        
        // Only auto-adjust if not loading a preset
        if(!window.loadingPreset) {
          ENDGAME_THRESHOLD = Math.min(40, Math.floor((COLS * ROWS) * 0.2));
          MAX_LOOP_DETECTION = Math.max(8, (COLS + ROWS) / 2 | 0);
          FILL_POCKET_LIMIT = COLS * 4;
          NO_PROGRESS_THRESHOLD = Math.max(30, (COLS * ROWS) / 6);
          COMPACT_MODE_MAX_STEPS = Math.floor((COLS * ROWS) / 2);
          
          // Update displayed values
          document.getElementById('progThreshValue').textContent = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
          
          // Update slider ranges based on grid size
          document.getElementById('progThreshSlider').max = Math.max(200, COLS * ROWS);
          document.getElementById('progThreshSlider').value = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactSlider').max = Math.max(300, COLS * ROWS);
          document.getElementById('compactSlider').value = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameSlider').max = Math.max(100, Math.floor((COLS * ROWS) * 0.4));
        }
        
        // Restart game with new grid
        restartGame();
      }
    }
    
    colsSlider.addEventListener('input', updateGridSize);
    rowsSlider.addEventListener('input', updateGridSize);

    /* ===== AI PARAMETER CONTROLS ===== */
    // Loop Threshold
    const loopThreshSlider = document.getElementById('loopThreshSlider');
    loopThreshSlider.addEventListener('input', (e) => {
      LOOP_STREAK_THRESHOLD = parseInt(e.target.value);
      document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    });

    // Progress Threshold
    const progThreshSlider = document.getElementById('progThreshSlider');
    progThreshSlider.addEventListener('input', (e) => {
      NO_PROGRESS_THRESHOLD = parseInt(e.target.value);
      document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    });

    // Endgame Threshold
    const endgameSlider = document.getElementById('endgameSlider');
    endgameSlider.addEventListener('input', (e) => {
      ENDGAME_THRESHOLD = parseInt(e.target.value);
      document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    });

    // Compact Mode Steps
    const compactSlider = document.getElementById('compactSlider');
    compactSlider.addEventListener('input', (e) => {
      COMPACT_MODE_MAX_STEPS = parseInt(e.target.value);
      document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
    });

    /* ===== RESTART FUNCTION ===== */
    function restartGame() {
      // Reset game state
      snake = [];
      snakeSet = new Set();
      const sx = Math.floor(COLS/2), sy = Math.floor(ROWS/2);
      
      // Create initial snake (adjust size based on grid)
      if(COLS >= 5) {
        snake.push({x:sx-2,y:sy},{x:sx-1,y:sy},{x:sx,y:sy});
      } else if(COLS >= 3) {
        snake.push({x:sx-1,y:sy},{x:sx,y:sy});
      } else {
        snake.push({x:sx,y:sy});
      }
      
      snake.reverse();
      snake.forEach(p => snakeSet.add(`${p.x},${p.y}`));
      
      // Rebuild Hamilton path
      HAM = buildHamilton();
      
      // Reset variables
      prevFruitDist = Infinity;
      noProgressMoves = 0;
      lastMoves = [];
      windowMoves = [];
      loopDetected = false;
      loopStreak = 0;
      hamMode = false;
      compactMode = false;
      compactModeSteps = 0;
      currentStrategy = "Initializing";
      
      // Spawn new fruit
      fruit = spawnFruit();
      if(fruit.x>=0) prevFruitDist = Math.abs(snake[0].x-fruit.x)+Math.abs(snake[0].y-fruit.y);
      
      // Clear and restart game loop
      if(loopHandle) clearInterval(loopHandle);
      gameRunning = true;
      draw();
      loopHandle = setInterval(update, SPEED);
    }

    document.getElementById('restartBtn').addEventListener('click', restartGame);

    /* ===== HAMILTON-SLINGA ===== */
    function buildHamilton(){
      const path=[]; let dir=1;
      for(let y=0;y<ROWS;y++){
        if(dir>0){
          for(let x=0;x<COLS;x++) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        }else{
          for(let x=COLS-1;x>=0;x--) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        }
        dir=-dir;
      }
      return path;
    }
    let HAM = buildHamilton();
    const idxOf = p => HAM.findIndex(q=>q.x===p.x&&q.y===p.y);
    const hamNext = p => {const i=idxOf(p); return i<0?null:HAM[(i+1)%HAM.length];};

    /* ===== HJ√ÑLPFUNKTIONER ===== */
    function spawnFruit(){
      const free=[]; for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)
        if(!snakeSet.has(`${x},${y}`)) free.push({x,y});
      return free.length ? free[(Math.random()*free.length)|0] : {x:-1,y:-1};
    }
    
    function isFruitAccessible(head){
      if(!fruit||fruit.x<0) return false;
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTail=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTail) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    
    function bfsWithAlternatives(sx,sy,gx,gy,allowTail,preferRandom=false){
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const prev=Array.from({length:ROWS},()=>Array(COLS).fill(null));
      let Q=[{x:sx,y:sy}]; vis[sy][sx]=true;
      while(Q.length){
        if(preferRandom) Q.sort(()=>Math.random()-0.5);
        const {x,y}=Q.shift();
        if(x===gx&&y===gy) break;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=allowTail&&snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; prev[ny][nx]={x,y}; Q.push({x:nx,y:ny});
        }
      }
      if(!vis[gy][gx]) return null;
      const path=[]; for(let cx=gx,cy=gy;!(cx===sx&&cy===sy);){
        path.unshift({x:cx,y:cy}); const p=prev[cy][cx]; if(!p) return null; cx=p.x; cy=p.y;
      }
      return path;
    }
    
    function canReachTailFrom(head,body){
      if(!body||body.length<2) return true;
      const tail=body[body.length-1];
      if(head.x===tail.x&&head.y===tail.y) return true;
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===tail.x&&y===tail.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy, key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          if(blocked.has(key)&&!(nx===tail.x&&ny===tail.y)) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    
    const floodSize=(sx,sy,body)=>{
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const startKey=`${sx},${sy}`;
      if(sx<0||sx>=COLS||sy<0||sy>=ROWS||blocked.has(startKey)) return 0;
      const vis=new Set([startKey]); const Q=[{x:sx,y:sy}]; let cnt=1;
      while(Q.length){
        const {x,y}=Q.shift();
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy, key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis.has(key)||blocked.has(key)) continue;
          vis.add(key); cnt++; Q.push({x:nx,y:ny});
        }
      }
      return cnt;
    };
    
    function getMinStepsToFruit(){
      if(!fruit||fruit.x<0) return Infinity;
      const head=snake[0];
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const dist=Array.from({length:ROWS},()=>Array(COLS).fill(Infinity));
      const Q=[{x:head.x,y:head.y}];
      vis[head.y][head.x]=true; dist[head.y][head.x]=0;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return dist[y][x];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; dist[ny][nx]=dist[y][x]+1; Q.push({x:nx,y:ny});
        }
      }
      return Infinity;
    }
    
    const getDistancesFromTail=()=>{
      const dmap=Array.from({length:ROWS},()=>Array(COLS).fill(-1));
      if(snake.length<2) return dmap;
      const tail=snake[snake.length-1];
      const Q=[{x:tail.x,y:tail.y,dist:0}]; dmap[tail.y][tail.x]=0;
      const blocked=new Set(snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
      let idx=0; while(idx<Q.length){
        const {x,y,dist}=Q[idx++];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          if(dmap[ny][nx]>=0) continue;
          if(blocked.has(`${nx},${ny}`)) continue;
          dmap[ny][nx]=dist+1; Q.push({x:nx,y:ny,dist:dist+1});
        }
      }
      return dmap;
    };
    
    function detectLoop(){
      if(lastMoves.length<MAX_LOOP_DETECTION) return false;
      const recent=lastMoves.slice(-MAX_LOOP_DETECTION);
      const unique=new Set(recent.map(p=>`${p.x},${p.y}`)).size;
      return unique<=MAX_LOOP_DETECTION/2;
    }
    
    function calculateZigZagPath(){
      const head=snake[0];
      let lastDx=0,lastDy=0;
      if(lastMoves.length){
        const ph=lastMoves[lastMoves.length-1]; lastDx=head.x-ph.x; lastDy=head.y-ph.y;
      }
      const moves=[];
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`, isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const ate=fruit&&fruit.x>=0&&nx===fruit.x&&ny===fruit.y;
        const sim=ate?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        let prio=0;
        if((d.dx&&lastDy)||(d.dy&&lastDx)) prio=1;
        else if(d.dx===lastDx&&d.dy===lastDy) prio=2;
        else if(d.dx===-lastDx&&d.dy===-lastDy) prio=-1;
        moves.push({x:nx,y:ny,priority:prio});
      }
      if(!moves.length) return null;
      moves.sort((a,b)=>b.priority-a.priority);
      return {x:moves[0].x,y:moves[0].y};
    }
    
    function getBackToHamilton(head){
      const currentIdx=idxOf(head);
      if(currentIdx!==-1) return null;
      let best=null, minDist=Infinity;
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`;
        const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        const idx=idxOf({x:nx,y:ny});
        if(idx!==-1){
          const dist=Math.min(Math.abs(idx-currentIdx),HAM.length-Math.abs(idx-currentIdx));
          if(dist<minDist){minDist=dist; best={x:nx,y:ny};}
        }
      }
      return best;
    }
    
    function isFruitInPocket(){
      if(!fruit||fruit.x<0) return false;
      let blocked=0;
      for(const d of DIRS){
        const nx=fruit.x+d.dx, ny=fruit.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) blocked++;
        else if(snakeSet.has(`${nx},${ny}`)) blocked++;
      }
      const steps=getMinStepsToFruit();
      return blocked>=3 || (blocked>=2 && steps>(COLS+ROWS)/2);
    }
    
    function fillSmallestPocket(){
      const head=snake[0];
      const freeCells=[], vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const blocked=new Set(snake.map(p=>`${p.x},${p.y}`));
      for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
        if(vis[y][x]||blocked.has(`${x},${y}`)) continue;
        const pocket=[], Q=[{x,y}]; vis[y][x]=true;
        while(Q.length){
          const {x:cx,y:cy}=Q.shift(); pocket.push({x:cx,y:cy});
          for(const d of DIRS){
            const nx=cx+d.dx, ny=cy+d.dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]||blocked.has(`${nx},${ny}`)) continue;
            vis[ny][nx]=true; Q.push({x:nx,y:ny});
          }
        }
        freeCells.push(pocket);
      }
      freeCells.sort((a,b)=>a.length-b.length);
      for(const pocket of freeCells){
        if(!pocket.length) continue;
        const target=pocket[0];
        const path=bfsWithAlternatives(head.x,head.y,target.x,target.y,true,true);
        if(path&&path.length){
          const nxt=path[0];
          const sim=[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)) return nxt;
        }
      }
      return null;
    }

    /* ===== GET NEXT ===== */
    function getNext(){
      HAM = buildHamilton();
      const head=snake[0];

      windowMoves.push(`${head.x},${head.y}`);
      if(windowMoves.length>WINDOW_SIZE) windowMoves.shift();

      lastMoves.push({x:head.x,y:head.y});
      if(lastMoves.length>MAX_LOOP_DETECTION) lastMoves.shift();

      const freeCells=COLS*ROWS - snake.length;
      const isEndgame=freeCells<=ENDGAME_THRESHOLD;

      if(!hamMode && freeCells>ENDGAME_THRESHOLD){
        const uniq=new Set(windowMoves).size;
        if(uniq<WINDOW_SIZE/2){
          hamMode=true; loopStreak=0; noProgressMoves=0;
          currentStrategy="Forcing Hamilton (Stagnation)";
        }
      }

      if(freeCells<=1){
        const nxt=hamNext(head);
        if(nxt){
          const isTail=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
          if(!snakeSet.has(`${nxt.x},${nxt.y}`)||isTail){
            currentStrategy="Final Hamilton"; return nxt;
          }
        }
      }

      if(isEndgame){
        const back=getBackToHamilton(head);
        if(back){currentStrategy="Returning to Hamilton"; return back;}
        const nxt=hamNext(head);
        if(nxt){
          const key=`${nxt.x},${nxt.y}`;
          const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
          const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if((!snakeSet.has(key)||isTailStep)&&canReachTailFrom(nxt,sim)){
            currentStrategy="Endgame Hamilton"; return nxt;
          }
        }
      }

      if(fruit&&fruit.x>=0){
        const d=Math.abs(head.x-fruit.x)+Math.abs(head.y-fruit.y);
        if(d<prevFruitDist){prevFruitDist=d; noProgressMoves=0;}
        else noProgressMoves++;
      }else{prevFruitDist=Infinity; noProgressMoves=0;}

      if(!hamMode && noProgressMoves>=NO_PROGRESS_THRESHOLD){
        hamMode=true; loopStreak=0; noProgressMoves=0;
        currentStrategy="Forcing Hamilton (No progress)";
      }

      if(hamMode){
        const nxt=hamNext(head);
        if(nxt){
          const key=`${nxt.x},${nxt.y}`;
          const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
          const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if((!snakeSet.has(key)||isTailStep)&&canReachTailFrom(nxt,sim)){
            currentStrategy="Hamilton cycle"; return nxt;
          }
        }
        hamMode=false;
      }

      loopDetected=detectLoop();
      loopStreak=loopDetected?loopStreak+1:0;
      if(!hamMode && loopStreak>=LOOP_STREAK_THRESHOLD){
        hamMode=true; loopStreak=0; loopDetected=false;
        currentStrategy="Forcing Hamilton (Loop)";
      }

      if(loopDetected && snake.length>=2){
        if (freeCells <= FILL_POCKET_LIMIT) {
          const fillMove = fillSmallestPocket();
          if(fillMove){currentStrategy="Filling smallest pocket"; return fillMove;}
        }
        const dmap=getDistancesFromTail();
        let best=null,bestDist=-1;
        for(const d of DIRS){
          const nx=head.x+d.dx, ny=head.y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
          const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
          if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
          const dist=dmap[ny][nx];
          if(dist>bestDist){bestDist=dist; best={x:nx,y:ny};}
        }
        if(best){currentStrategy="Loop break (Longest)"; return best;}
      }

      const fruitAcc=isFruitAccessible(head);
      if(fruitAcc && freeCells>15){
        let choices=[],minD=Infinity;
        for(const d of DIRS){
          const nx=head.x+d.dx, ny=head.y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
          const nd=Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y);
          if(nd>minD) continue;
          const sim=(nx===fruit.x&&ny===fruit.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
          if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
          if(nd<minD){minD=nd; choices=[{x:nx,y:ny}];}
          else if(nd===minD){choices.push({x:nx,y:ny});}
        }
        if(choices.length){currentStrategy="Greedy to fruit"; return choices[(Math.random()*choices.length)|0];}
      }

      const inPocket=isFruitInPocket();
      if(!compactMode && (inPocket||loopDetected) && freeCells>15){
        compactMode=true; compactModeSteps=0;
      }
      if(compactMode){
        const zig=calculateZigZagPath();
        if(zig){compactModeSteps++; currentStrategy="Compact zig-zag"; return zig;}
        else compactMode=false;
      }

      if(fruitAcc && freeCells>1){
        const path=bfsWithAlternatives(head.x,head.y,fruit.x,fruit.y,false,loopDetected);
        if(path&&path.length){
          const nxt=path[0];
          const sim=(nxt.x===fruit.x&&nxt.y===fruit.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)){currentStrategy="BFS to fruit"; return nxt;}
        }
      }

      let bestScore=-Infinity,bestMoves=[];
      const tailPos=snake.length>1?snake[snake.length-1]:null;
      const randomFactor=loopDetected?Math.random()*5:0;
      const avoidFactor=loopDetected?0.5:1;
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
        const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        const freeAfter=floodSize(nx,ny,sim);
        if(freeAfter<COLS*ROWS-sim.length) continue;
        let score=0;
        if(fruit&&fruit.x>=0&&freeCells>Math.max(6, COLS-2)){
          score+=(COLS+ROWS-(Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y)))*2*avoidFactor;
        }
        if(isEndgame&&tailPos&&nx===tailPos.x&&ny===tailPos.y) score+=10000;
        score+=Math.min(nx,ny,COLS-1-nx,ROWS-1-ny);
        score+=randomFactor;
        score+=freeAfter*2;
        if(score>bestScore){bestScore=score; bestMoves=[{x:nx,y:ny}];}
        else if(score===bestScore){bestMoves.push({x:nx,y:ny});}
      }
      if(bestMoves.length){currentStrategy="Heuristic"; return bestMoves[(Math.random()*bestMoves.length)|0];}

      const tail=snake.length>1?snake[snake.length-1]:head;
      const path=bfsWithAlternatives(head.x,head.y,tail.x,tail.y,true,loopDetected);
      if(path&&path.length){
        const nxt=path[0];
        const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
        if(canReachTailFrom(nxt,sim)){currentStrategy="BFS to tail"; return nxt;}
      }

      currentStrategy="No safe move!";
      return null;
    }

    /* ===== RENDER ===== */
    function draw(){
      // Clear canvas with gradient
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#1a1a2e');
      gradient.addColorStop(1, '#0f0f23');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid effect
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      for(let i = 0; i <= COLS; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL, 0);
        ctx.lineTo(i * CELL, canvas.height);
        ctx.stroke();
      }
      for(let i = 0; i <= ROWS; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * CELL);
        ctx.lineTo(canvas.width, i * CELL);
        ctx.stroke();
      }

      // Draw fruit with glow effect
      if(fruit && fruit.x >= 0){
        // Glow
        const glowGradient = ctx.createRadialGradient(
          fruit.x * CELL + CELL/2, fruit.y * CELL + CELL/2, 0,
          fruit.x * CELL + CELL/2, fruit.y * CELL + CELL/2, CELL
        );
        glowGradient.addColorStop(0, 'rgba(240, 147, 251, 0.6)');
        glowGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGradient;
        ctx.fillRect(fruit.x * CELL, fruit.y * CELL, CELL, CELL);

        // Fruit body
        const fruitGradient = ctx.createRadialGradient(
          fruit.x * CELL + CELL/2, fruit.y * CELL + CELL/2, 0,
          fruit.x * CELL + CELL/2, fruit.y * CELL + CELL/2, CELL/2.5
        );
        fruitGradient.addColorStop(0, '#ff6b9d');
        fruitGradient.addColorStop(1, '#c44569');
        ctx.fillStyle = fruitGradient;
        ctx.beginPath();
        ctx.arc(fruit.x * CELL + CELL/2, fruit.y * CELL + CELL/2, CELL/2.5, 0, 2 * Math.PI);
        ctx.fill();

        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.beginPath();
        ctx.arc(fruit.x * CELL + CELL/2.5, fruit.y * CELL + CELL/2.5, CELL/6, 0, 2 * Math.PI);
        ctx.fill();
      }

      // Draw snake with 2.5D effect
      const headColor = hamMode ? '#4ade80' : compactMode ? '#f97316' : loopDetected ? '#fbbf24' : '#667eea';
      
      snake.forEach((p, i) => {
        const isHead = i === 0;
        const size = CELL * 0.95;
        const offset = (CELL - size) / 2;
        const x = p.x * CELL + offset;
        const y = p.y * CELL + offset;

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(x + 2, y + 2, size, size);

        // Main body gradient
        const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
        if(isHead) {
          gradient.addColorStop(0, headColor);
          gradient.addColorStop(1, isHead && hamMode ? '#22c55e' : isHead && compactMode ? '#ea580c' : isHead && loopDetected ? '#f59e0b' : '#764ba2');
        } else {
          const t = i / (snake.length - 1);
          const r = Math.round(102 + (138 - 102) * t);
          const g = Math.round(126 + (75 - 126) * t);
          const b = Math.round(234 + (162 - 234) * t);
          gradient.addColorStop(0, `rgb(${r}, ${g}, ${b})`);
          gradient.addColorStop(1, `rgb(${r - 30}, ${g - 30}, ${b - 30})`);
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, size, size);

        // 3D highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(x, y, size, size/3);

        // Eyes for head
        if(isHead) {
          ctx.fillStyle = '#fff';
          let eyeX1, eyeY1, eyeX2, eyeY2;
          
          if(snake.length > 1) {
            const dx = p.x - snake[1].x;
            const dy = p.y - snake[1].y;
            
            if(dx === 1) { // right
              eyeX1 = x + size - size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size - size/4;
            } else if(dx === -1) { // left
              eyeX1 = x + size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size/4;
              eyeY2 = y + size - size/4;
            } else if(dy === 1) { // down
              eyeX1 = x + size/4;
              eyeY1 = y + size - size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size - size/4;
            } else { // up
              eyeX1 = x + size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size/4;
            }
            
            ctx.beginPath();
            ctx.arc(eyeX1, eyeY1, size/10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(eyeX2, eyeY2, size/10, 0, 2 * Math.PI);
            ctx.fill();
            
            // Pupils
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(eyeX1, eyeY1, size/20, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(eyeX2, eyeY2, size/20, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
      });

      // Update status displays
      document.getElementById('strategyStatus').textContent = `Strategy: ${currentStrategy}`;
      document.getElementById('hamStatus').textContent = hamMode ? "Hamilton active" : "";
      document.getElementById('loopStatus').textContent = loopDetected ? `Loop detected! (${loopStreak})` : "";
      document.getElementById('compactStatus').textContent = compactMode ? "Compact mode active" : "";
      document.getElementById('compactStepStatus').textContent = compactMode ? `Step ${compactModeSteps}/${COMPACT_MODE_MAX_STEPS}` : "";
      
      // Update game stats
      const freeCells = COLS * ROWS - snake.length;
      document.getElementById('snakeLength').textContent = snake.length;
      document.getElementById('freeCells').textContent = freeCells;
      document.getElementById('progress').textContent = ((snake.length / (COLS * ROWS)) * 100).toFixed(1) + '%';
    }

    /* ===== UPDATE ===== */
    function update(){
      if(!snake.length){ 
        clearInterval(loopHandle); 
        gameRunning = false;
        return; 
      }
      
      const nxt = getNext();
      if(!nxt){
        clearInterval(loopHandle); 
        gameRunning = false;
        draw();
        
        // Game over overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(snake.length === COLS * ROWS ? "PERFECT! üéâ" : "Game Over", canvas.width/2, canvas.height/2);
        
        ctx.font = '20px Inter, sans-serif';
        ctx.fillText(`Final length: ${snake.length}`, canvas.width/2, canvas.height/2 + 40);
        return;
      }
      
      if(nxt.x < 0 || nxt.x >= COLS || nxt.y < 0 || nxt.y >= ROWS){
        clearInterval(loopHandle);
        gameRunning = false;
        draw();
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText("Crash! üí•", canvas.width/2, canvas.height/2);
        return;
      }
      
      const ate = fruit && fruit.x >= 0 && nxt.x === fruit.x && nxt.y === fruit.y;
      if(!ate){
        const tail = snake.pop();
        snakeSet.delete(`${tail.x},${tail.y}`);
      }
      
      snake.unshift({x: nxt.x, y: nxt.y});
      snakeSet.add(`${nxt.x},${nxt.y}`);
      
      if(ate){
        if(snake.length === COLS * ROWS){
          fruit = {x: -1, y: -1};
          draw();
          clearInterval(loopHandle);
          gameRunning = false;
          
          // Victory screen
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          gradient.addColorStop(0, '#667eea');
          gradient.addColorStop(0.5, '#f093fb');
          gradient.addColorStop(1, '#764ba2');
          
          ctx.fillStyle = gradient;
          ctx.font = 'bold 48px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText("PERFECT! üèÜ", canvas.width/2, canvas.height/2);
          
          ctx.fillStyle = '#fff';
          ctx.font = '24px Inter, sans-serif';
          ctx.fillText("You filled the entire board!", canvas.width/2, canvas.height/2 + 50);     //ctx.fillText("Du fyllde hela spelplanen!", canvas.width/2, canvas.height/2 + 50);
          return;
        } else {
          fruit = spawnFruit();
          prevFruitDist = (fruit.x >= 0) ? Math.abs(snake[0].x - fruit.x) + Math.abs(snake[0].y - fruit.y) : Infinity;
          noProgressMoves = 0;
        }
      }
      
      draw();
    }

    /* ===== KONTROLLER & START ===== */
    document.getElementById('slowerBtn').onclick = () => changeSpeed(SPEED + SPEED_STEP);
    document.getElementById('fasterBtn').onclick = () => changeSpeed(SPEED - SPEED_STEP);
    
    function changeSpeed(v){
      v = Math.max(MIN_SPEED, Math.min(MAX_SPEED, v));
      if(v !== SPEED){
        SPEED = v;
        document.getElementById('speedDisplay').textContent = `Speed: ${SPEED}ms`;
        if(gameRunning) {
          clearInterval(loopHandle);
          loopHandle = setInterval(update, SPEED);
        }
      }
    }

    // Start game
    restartGame();

    // Initialize displayed values
    document.getElementById('colsValue').textContent = COLS;
    document.getElementById('rowsValue').textContent = ROWS;
    document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;

    // Save combination functionality
    const saveComboBtn = document.getElementById('saveComboBtn');
    if(saveComboBtn) {
      saveComboBtn.addEventListener('click', () => {
        const combo = {
          grid: `${COLS}x${ROWS}`,
          loop_threshold: LOOP_STREAK_THRESHOLD,
          no_progress: NO_PROGRESS_THRESHOLD,
          endgame: ENDGAME_THRESHOLD,
          compact_steps: COMPACT_MODE_MAX_STEPS,
          speed: SPEED,
          date: new Date().toLocaleDateString('en-US'),
          time: new Date().toLocaleTimeString('en-US')
        };
        
        const comboText = `Snake AI Pro - My Combination
========================
Grid: ${combo.grid}
Loop Threshold: ${combo.loop_threshold}
No Progress: ${combo.no_progress}
Endgame: ${combo.endgame}
Compact Steps: ${combo.compact_steps}
Speed: ${combo.speed}ms
Date: ${combo.date} ${combo.time}`;
        
        document.getElementById('comboText').textContent = comboText;
        document.getElementById('savedCombo').style.display = 'block';
        
        // Copy to clipboard
        navigator.clipboard.writeText(comboText).then(() => {
          saveComboBtn.textContent = '‚úÖ Copied to clipboard!';
          setTimeout(() => {
            saveComboBtn.textContent = 'üì§ Save & Send Combination';
          }, 3000);
        });
      });
    }

    // Load preset functionality
    const presetButtons = document.querySelectorAll('.load-preset');
    const presets = {
      speedrun: { cols: 15, rows: 15, loop: 5, progress: 80, endgame: 30, compact: 150, speed: 50 },
      safe: { cols: 15, rows: 15, loop: 1, progress: 40, endgame: 60, compact: 80, speed: 100 },
      balanced: { cols: 20, rows: 20, loop: 3, progress: 70, endgame: 50, compact: 200, speed: 75 },
      small: { cols: 10, rows: 10, loop: 1, progress: 50, endgame: 10, compact: 100, speed: 150 },
      large: { cols: 25, rows: 25, loop: 6, progress: 150, endgame: 20, compact: 300, speed: 25 },
      ultra: { cols: 30, rows: 30, loop: 8, progress: 200, endgame: 40, compact: 450, speed: 10 }
    };

    presetButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const presetName = btn.dataset.preset;
        const preset = presets[presetName];
        
        if(preset) {
          // Set flag to prevent auto-adjustment
          window.loadingPreset = true;
          
          // Update sliders
          document.getElementById('colsSlider').value = preset.cols;
          document.getElementById('rowsSlider').value = preset.rows;
          document.getElementById('loopThreshSlider').value = preset.loop;
          document.getElementById('progThreshSlider').value = preset.progress;
          document.getElementById('endgameSlider').value = preset.endgame;
          document.getElementById('compactSlider').value = preset.compact;
          
          // Update values
          COLS = preset.cols;
          ROWS = preset.rows;
          LOOP_STREAK_THRESHOLD = preset.loop;
          NO_PROGRESS_THRESHOLD = preset.progress;
          ENDGAME_THRESHOLD = preset.endgame;
          COMPACT_MODE_MAX_STEPS = preset.compact;
          SPEED = preset.speed;
          
          // Update displays
          document.getElementById('colsValue').textContent = COLS;
          document.getElementById('rowsValue').textContent = ROWS;
          document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
          document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
          document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
          document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
          document.getElementById('speedDisplay').textContent = `Hastighet: ${SPEED}ms`;
          
          // Recalculate grid-dependent values
          CELL = canvas.width / COLS;
          MAX_LOOP_DETECTION = Math.max(8, (COLS + ROWS) / 2 | 0);
          FILL_POCKET_LIMIT = COLS * 4;
          
          // Restart game
          restartGame();
          
          // Clear flag
          window.loadingPreset = false;
          
          // Switch to game page
          navLinks.forEach(l => l.classList.remove('active'));
          document.querySelector('[data-page="game"]').classList.add('active');
          pages.forEach(p => p.classList.remove('active'));
          document.getElementById('game-page').classList.add('active');
          
          // Flash button
          btn.textContent = '‚úÖ Loaded!';
          setTimeout(() => {
            btn.textContent = 'Load this';
          }, 2000);
        }
      });
    });
  </script>
</body>
</html>












