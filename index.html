

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Simulation - Intelligent Snake Experience</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --accent: #f093fb;
      --success: #4ade80;
      --danger: #ef4444;
      --warning: #fbbf24;
      --dark: #1a1a2e;
      --darker: #0f0f23;
      --light: #eef2ff;
      --text: #e2e8f0;
      --glass: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.2);
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
      min-height: 100vh;
      color: var(--text);
      overflow-x: hidden;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
      opacity: 0.03;
      animation: rotate 60s linear infinite;
      z-index: -1;
    }
    @keyframes rotate {
      to { transform: rotate(360deg); }
    }
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    /* Navigation */
    nav {
      background: var(--glass);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--glass-border);
      padding: 1rem 2rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }
    .nav-container {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .logo {
      font-size: 1.8rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .logo::before {
      content: 'üêç';
      font-size: 2rem;
      -webkit-text-fill-color: initial;
    }
    .nav-links {
      display: flex;
      gap: 2rem;
      list-style: none;
    }
    .nav-links a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      transition: all 0.3s;
      position: relative;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
    }
    .nav-links a:hover {
      color: var(--accent);
      background: var(--glass);
    }
    .nav-links a.active {
      color: var(--accent);
      background: var(--glass);
    }
    /* Page transitions */
    .page {
      display: none;
      animation: fadeIn 0.5s ease-in-out;
    }
    .page.active {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* Main container */
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 3rem 2rem;
    }
    /* Hero section */
    .hero {
      text-align: center;
      margin-bottom: 3rem;
    }
    .hero h1 {
      font-size: 3.5rem;
      font-weight: 900;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, var(--light) 0%, var(--accent) 50%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient 3s ease-in-out infinite;
      background-size: 200%;
    }
    @keyframes gradient {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    .hero p {
      font-size: 1.2rem;
      color: var(--text);
      opacity: 0.8;
      max-width: 600px;
      margin: 0 auto;
    }
    /* Game section */
    .game-wrapper {
      display: flex;
      gap: 3rem;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
    }
    .game-container {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 2rem;
      padding: 2rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }
    .game-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, var(--accent), var(--primary), var(--secondary));
      border-radius: 2rem;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .game-container:hover::before {
      opacity: 0.5;
    }
    #game {
      border-radius: 1rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s;
    }
    #game:hover {
      transform: scale(1.02);
    }
    /* Controls panel */
    .controls-panel {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      min-width: 380px;
      max-width: 550px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      max-height: 90vh;
      overflow-y: auto;
    }
    .controls-panel::-webkit-scrollbar {
      width: 8px;
    }
    .controls-panel::-webkit-scrollbar-track {
      background: var(--darker);
      border-radius: 4px;
    }
    .controls-panel::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 4px;
    }
    .controls-section {
      margin-bottom: 2rem;
    }
    .controls-section h3 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .controls-section h3::before {
      content: '‚ö°';
      font-size: 1.5rem;
    }
    .section-title-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    .section-title-row h3 {
      margin-bottom: 0;
    }
    .collapse-toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      transition: color 0.2s ease, background 0.2s ease;
    }
    .collapse-toggle:hover,
    .collapse-toggle:focus-visible {
      color: var(--accent);
      background: rgba(255, 255, 255, 0.08);
      outline: none;
    }
    .collapse-toggle .chevron {
      display: inline-block;
      transition: transform 0.2s ease;
    }
    .collapsible-section.collapsed .collapse-toggle .chevron {
      transform: rotate(-90deg);
    }
    .collapsible-section.collapsed .collapsible-content {
      display: none;
    }
    .collapsible-content[hidden] {
      display: none;
    }
    .collapsible-section.collapsed {
      margin-bottom: 1.5rem;
    }
    .rl-config-section fieldset {
      margin: 0;
    }
    /* Modern buttons */
    .button {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      position: relative;
      overflow: hidden;
    }
    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      transition: left 0.5s;
    }
    .button:hover::before {
      left: 100%;
    }
    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    .button:active {
      transform: translateY(0);
    }
    .button.toggle-active {
      background: linear-gradient(135deg, var(--success) 0%, var(--accent) 100%);
      box-shadow: 0 8px 25px rgba(74, 222, 128, 0.45);
    }
    .button.warning {
      background: linear-gradient(135deg, var(--warning) 0%, #f59e0b 100%);
      color: #1f2937;
      box-shadow: 0 4px 15px rgba(251, 191, 36, 0.45);
    }
    .button.warning:hover {
      box-shadow: 0 6px 20px rgba(251, 191, 36, 0.6);
    }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-top: 0.5rem;
    }
    .button-row .button {
      flex: 1 1 180px;
      min-width: 0;
    }
    .manual-hint {
      font-size: 0.85rem;
      margin-top: 0.5rem;
      color: var(--light);
      opacity: 0.7;
      text-align: center;
    }
    .episode-history-card {
      margin-top: 1.25rem;
      padding: 1.1rem;
      border-radius: 1rem;
      border: 1px solid var(--glass-border);
      background: rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(12px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
    }
    .episode-history-heading {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .episode-history-heading h4 {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .episode-history-heading small {
      color: var(--text);
      opacity: 0.6;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .episode-history-grid-header,
    .episode-history-row {
      display: grid;
      grid-template-columns: 0.7fr 1fr 1fr 0.8fr 1fr 1fr;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.82rem;
    }
    .episode-history-grid-header {
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.65;
      margin-bottom: 0.35rem;
    }
    .episode-history-rows {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      max-height: 220px;
      overflow-y: auto;
      padding-right: 0.25rem;
    }
    .episode-history-rows::-webkit-scrollbar {
      width: 6px;
    }
    .episode-history-rows::-webkit-scrollbar-track {
      background: transparent;
    }
    .episode-history-rows::-webkit-scrollbar-thumb {
      background: rgba(240, 147, 251, 0.35);
      border-radius: 999px;
    }
    .reward-impact-card {
      margin-top: 1.25rem;
      padding: 1rem 1.1rem;
      border-radius: 1rem;
      border: 1px solid var(--glass-border);
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      box-shadow: inset 0 0 0 1px rgba(102, 126, 234, 0.08);
    }
    .reward-impact-card h4 {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .section-title-row.compact {
      margin-bottom: 0.6rem;
    }
    .reward-impact-table {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      margin-top: 0.5rem;
      overflow-x: auto;
    }
    .reward-impact-table::-webkit-scrollbar {
      height: 6px;
    }
    .reward-impact-table::-webkit-scrollbar-thumb {
      background: rgba(102, 126, 234, 0.4);
      border-radius: 999px;
    }
    .reward-impact-row {
      display: grid;
      grid-template-columns: 1.6fr 0.9fr 0.9fr 0.9fr 1fr;
      gap: 0.4rem;
      align-items: center;
      padding: 0.45rem 0.6rem;
      border-radius: 0.75rem;
      background: rgba(15, 15, 35, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 0.82rem;
      min-width: 520px;
    }
    .reward-impact-row span:last-child {
      justify-self: flex-end;
    }
    .reward-impact-row.reward-impact-header {
      background: transparent;
      border: none;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      opacity: 0.65;
      padding-bottom: 0;
    }
    .reward-impact-rows {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }
    .reward-impact-row.impact-top {
      border-color: rgba(240, 147, 251, 0.45);
      box-shadow: 0 0 0 1px rgba(240, 147, 251, 0.25);
      background: rgba(102, 126, 234, 0.15);
    }
    .reward-impact-empty {
      text-align: center;
      font-size: 0.85rem;
      opacity: 0.75;
      padding: 0.5rem 0;
    }
    .trend {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      font-weight: 600;
    }
    .trend-up {
      color: var(--success);
    }
    .trend-down {
      color: var(--danger);
    }
    .trend-flat {
      opacity: 0.6;
    }
    .reward-impact-summary {
      margin-top: 0.75rem;
      font-size: 0.8rem;
    }
    .episode-history-row {
      background: rgba(255, 255, 255, 0.035);
      border-radius: 0.8rem;
      padding: 0.5rem 0.75rem;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
    }
    .episode-history-row span {
      white-space: nowrap;
    }
    .episode-history-empty {
      font-size: 0.82rem;
      color: var(--text);
      opacity: 0.65;
      text-align: center;
      padding: 0.75rem 0.25rem;
    }
    .rl-fieldset {
      margin-top: 1.5rem;
      border: 1px solid var(--glass-border);
      border-radius: 1.2rem;
      padding: 1.5rem;
      background: rgba(15, 15, 35, 0.7);
      transition: opacity 0.3s ease;
    }
    .rl-fieldset legend {
      padding: 0 0.6rem;
      font-weight: 700;
      color: var(--accent);
      font-size: 1.1rem;
    }
    .rl-fieldset.inactive {
      opacity: 0.45;
    }
    .rl-grid {
      display: grid;
      gap: 1rem;
    }
    @media (min-width: 480px) {
      .rl-grid.two-col {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
    .number-input {
      width: 100%;
      padding: 0.6rem 0.8rem;
      border-radius: 0.75rem;
      border: 1px solid var(--glass-border);
      background: var(--glass);
      color: var(--text);
      font-weight: 500;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .number-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(240, 147, 251, 0.25);
    }
    .button.danger {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
    }
    .button.danger:hover {
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.6);
    }
    /* Speed controls */
    .speed-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      justify-content: center;
      margin: 1rem 0;
    }
    .speed-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.2rem;
      padding: 0.8rem 1.2rem;
      min-width: 100px;
    }
    .speed-btn span {
      display: block;
    }
    .speed-display {
      background: var(--darker);
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      min-width: 140px;
      text-align: center;
      font-weight: 600;
      border: 1px solid var(--primary);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
    }
    /* Size controls */
    .size-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin: 1rem 0;
    }
    .size-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 8px;
      background: var(--darker);
      border-radius: 4px;
      outline: none;
      position: relative;
    }
    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
      transition: all 0.3s;
    }
    .size-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
    }
    .select-control {
      width: 100%;
      padding: 0.6rem 0.8rem;
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 0.75rem;
      color: var(--text);
      font-weight: 500;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .select-control:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(240, 147, 251, 0.25);
    }
    .select-control option {
      background: var(--dark);
      color: var(--text);
    }
    /* Parameter controls */
    .param-control {
      margin-bottom: 1.5rem;
    }
    .param-control label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--text);
    }
    .param-control label span {
      color: var(--accent);
      font-weight: 700;
      min-width: 40px;
      text-align: right;
    }
    .param-control small {
      display: block;
      margin-top: 0.3rem;
      color: var(--text);
      opacity: 0.6;
      font-size: 0.8rem;
    }
    .param-control .size-slider {
      width: 100%;
    }
    /* Status display */
    .status-display {
      background: var(--darker);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-top: 1rem;
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    .status-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--glass-border);
    }
    .status-item:last-child {
      border-bottom: none;
    }
    .status-label {
      color: var(--text);
      opacity: 0.8;
    }
    .status-value {
      font-weight: 600;
      color: var(--accent);
    }
    /* AI Status messages */
    #statusMessages {
      background: var(--darker);
      border-radius: 1rem;
      padding: 1rem;
      margin-top: 1rem;
      min-height: 120px;
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    #statusMessages p {
      margin: 0.3rem 0;
      font-size: 0.9rem;
      opacity: 0.9;
    }
    #strategyStatus {
      color: var(--accent);
      font-weight: 600;
      font-size: 1rem;
    }
    .status-explanation {
      color: var(--text);
      opacity: 0.85;
      line-height: 1.4;
    }
    #hamStatus { color: #4ade80; }
    #loopStatus { color: #fbbf24; }
    #compactStatus { color: #f97316; }
    /* Info page */
    .info-content {
      max-width: 800px;
      margin: 0 auto;
    }
    .info-section {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .info-section h2 {
      color: var(--accent);
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }
    .info-section h3 {
      color: var(--primary);
      margin: 1.5rem 0 1rem;
    }
    .info-section p, .info-section li {
      line-height: 1.8;
      opacity: 0.9;
    }
    .info-section ul {
      list-style: none;
      padding-left: 0;
    }
    .info-section li {
      position: relative;
      padding-left: 2rem;
      margin-bottom: 0.5rem;
    }
    .info-section li::before {
      content: '‚Üí';
      position: absolute;
      left: 0;
      color: var(--accent);
      font-weight: bold;
    }
    /* Contact page */
    .contact-content {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }
    .contact-card {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 3rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .contact-card h2 {
      color: var(--accent);
      margin-bottom: 2rem;
      font-size: 2rem;
    }
    .contact-info {
      font-size: 1.2rem;
      margin: 2rem 0;
    }
    .contact-email {
      display: inline-block;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 1rem 2rem;
      border-radius: 2rem;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      margin-top: 1rem;
    }
    .contact-email:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    /* Combo preset styling */
    .combo-preset {
      background: var(--darker);
      padding: 1.5rem;
      border-radius: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--primary);
    }
    .combo-preset ul {
      margin-bottom: 1rem;
    }
    .combo-preset li {
      padding-left: 1.5rem;
      font-family: monospace;
      font-size: 1.1rem;
      color: var(--accent);
    }
    .load-preset {
      width: 100%;
      background: linear-gradient(135deg, var(--primary), var(--accent));
    }
    /* Responsive */
    @media (max-width: 768px) {
      .nav-container {
        flex-direction: column;
        gap: 1rem;
      }
      .hero h1 {
        font-size: 2.5rem;
      }
      .game-wrapper {
        flex-direction: column;
      }
      .controls-panel {
        width: 100%;
        max-width: none;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav>
    <div class="nav-container">
      <div class="logo">Snake Simulation</div>
      <ul class="nav-links">
        <li><a href="#" class="nav-link active" data-page="game">Game</a></li>
        <li><a href="#" class="nav-link" data-page="guide">Guide</a></li>
        <li><a href="#" class="nav-link" data-page="ai">AI Handbook</a></li>
        <li><a href="#" class="nav-link" data-page="facit">Presets</a></li>
        <li><a href="#" class="nav-link" data-page="contact">Contact</a></li>
      </ul>
    </div>
  </nav>
  <!-- Game Page -->
  <div id="game-page" class="page active">
    <div class="container">
      <div class="hero">
        <h1>Snake Simulation</h1>
          <p>Your goal is to find the best adjustments to complete the board</p>
          <p>Adjust Grid size for longer simulations</p>
      </div>
      <div class="game-wrapper">
        <div class="game-container">
          <canvas id="game" width="600" height="600"></canvas>
        </div>
        <div class="controls-panel">
          <div class="controls-section">
            <h3>Game Controls</h3>
            <div class="speed-controls">
              <button id="slowerBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">üêå</span>
                <span>Slower</span>
              </button>
              <div id="speedDisplay" class="speed-display">Speed: 100ms</div>
              <button id="fasterBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">‚ö°</span>
                <span>Faster</span>
              </button>
            </div>
            <div style="margin-top: 1rem;">
              <button id="restartBtn" class="button danger" style="width: 100%;">üîÑ Restart</button>
            </div>
            <div style="margin-top: 0.8rem;">
              <button id="manualToggle" class="button" style="width: 100%;">üïπÔ∏è Try Manual Play</button>
              <p id="manualHint" class="manual-hint">Manual mode off ‚Äì AI is playing automatically.</p>
            </div>
            <div style="margin-top: 0.8rem;">
              <button id="safetyNetToggle" class="button toggle-active" style="width: 100%;">üõ°Ô∏è Safety Net: ON</button>
              <p id="safetyNetHint" class="manual-hint">Safety net algorithms are active.</p>
            </div>
          </div>
          <div class="controls-section" style="margin-top: 1.5rem;">
            <h3>ML / RL Training</h3>
            <button id="rlToggle" class="button" style="width: 100%;">ü§ñ Enable Reinforcement Learning</button>
            <p id="rlHint" class="manual-hint">Reinforcement learning is currently disabled.</p>
          </div>
          <div class="controls-section rl-config-section collapsible-section">
            <div class="section-title-row">
              <h3>Fine-tune RL</h3>
              <button id="rlPanelToggle" class="collapse-toggle" type="button" aria-expanded="true" aria-controls="rlParamContent" title="Show or hide reinforcement learning fine-tuning settings">
                <span class="chevron">‚ñæ</span>
                <span class="collapse-label">Hide settings</span>
              </button>
            </div>
            <div id="rlParamContent" class="collapsible-content">
              <fieldset id="rlParamFieldset" class="rl-fieldset inactive" disabled>
                <legend class="visually-hidden">Fine-tune RL</legend>
                <p class="manual-hint" style="margin-bottom: 1rem;">Turn on RL to unlock reward tuning and hyperparameters.</p>
                <div class="param-control">
                  <label>Step Penalty: <span id="rlStepPenaltyValue">-0.05</span></label>
                  <input type="range" id="rlStepPenalty" class="size-slider" min="-0.5" max="0" step="0.01" value="-0.05">
                  <small>Negative reward every move ‚Äì increasing the penalty forces shorter routes.</small>
                </div>
                <div class="param-control">
                  <label>Fruit Reward: <span id="rlFruitRewardValue">5</span></label>
                  <input type="range" id="rlFruitReward" class="size-slider" min="0" max="20" step="0.5" value="5">
                  <small>Positive reward when fruit is eaten. Raise it to prioritise fast growth.</small>
                </div>
                <div class="param-control">
                  <label>Win Bonus: <span id="rlWinBonusValue">15</span></label>
                  <input type="range" id="rlWinBonus" class="size-slider" min="0" max="40" step="1" value="15">
                  <small>Extra reward for filling the entire board.</small>
                </div>
                <div class="param-control">
                  <label>Endgame Plan Reward: <span id="rlEndgameRewardValue">1.5</span></label>
                  <input type="range" id="rlEndgameReward" class="size-slider" min="0" max="5" step="0.1" value="1.5">
                  <small>Bonus when the snake commits to the Hamilton endgame plan.</small>
                </div>
                <div class="param-control">
                  <label>Compact Mode Reward: <span id="rlCompactRewardValue">1.0</span></label>
                  <input type="range" id="rlCompactReward" class="size-slider" min="0" max="5" step="0.1" value="1">
                  <small>Encourages entering and sustaining compact manoeuvres when space is tight.</small>
                </div>
                <div class="param-control">
                  <label>Crash Penalty: <span id="rlDeathPenaltyValue">-5</span></label>
                  <input type="range" id="rlDeathPenalty" class="size-slider" min="-50" max="0" step="1" value="-5">
                  <small>Negative reward on collision. Lower values make the agent more risk-aware.</small>
                </div>
                <div class="param-control">
                  <label>Dead-end Penalty: <span id="rlDeadEndPenaltyValue">-4.0</span></label>
                  <input type="range" id="rlDeadEndPenalty" class="size-slider" min="-20" max="0" step="0.5" value="-4">
                  <small>Penalty applied when the snake traps itself with no safe exits.</small>
                </div>
                <div class="param-control">
                  <label>Loop Stall Penalty: <span id="rlLoopPenaltyValue">-2</span></label>
                  <input type="range" id="rlLoopPenalty" class="size-slider" min="-20" max="0" step="0.5" value="-2">
                  <small>Penalty applied when an episode is terminated for a persistent loop.</small>
                </div>
                <div class="rl-grid two-col">
                  <div class="param-control">
                    <label>Learning rate Œ±: <span id="rlAlphaValue">0.20</span></label>
                    <input type="number" id="rlAlpha" class="number-input" min="0.01" max="1" step="0.01" value="0.2">
                    <small>How fast the Q-table updates. Higher values react quickly but can be unstable.</small>
                  </div>
                  <div class="param-control">
                    <label>Discount Œ≥: <span id="rlGammaValue">0.90</span></label>
                    <input type="number" id="rlGamma" class="number-input" min="0" max="0.99" step="0.01" value="0.9">
                    <small>How much future rewards are valued. Higher values favour long-term planning.</small>
                  </div>
                  <div class="param-control">
                    <label>Start Œµ: <span id="rlEpsilonStartValue">0.30</span></label>
                    <input type="number" id="rlEpsilonStart" class="number-input" min="0" max="1" step="0.01" value="0.3">
                    <small>Exploration at the beginning of training. Higher values = more random moves.</small>
                  </div>
                  <div class="param-control">
                    <label>Min Œµ: <span id="rlEpsilonMinValue">0.05</span></label>
                    <input type="number" id="rlEpsilonMin" class="number-input" min="0" max="0.5" step="0.01" value="0.05">
                    <small>Lowest exploration after long training.</small>
                  </div>
                  <div class="param-control">
                    <label>Œµ decay: <span id="rlEpsilonDecayValue">0.995</span></label>
                    <input type="number" id="rlEpsilonDecay" class="number-input" min="0.8" max="0.999" step="0.001" value="0.995">
                    <small>How quickly exploration shrinks each episode.</small>
                  </div>
                </div>
                <div class="param-control">
                  <label>Training Episodes: <span id="rlEpisodesValue">1</span></label>
                  <input type="number" id="rlEpisodes" class="number-input" min="1" max="100" step="1" value="1">
                  <small>Run multiple consecutive games before returning to manual control.</small>
                </div>
                <div class="param-control">
                  <label>Reward Scaling: <span id="rlRewardScaleValue">1.0</span></label>
                  <input type="range" id="rlRewardScale" class="size-slider" min="0.1" max="2" step="0.1" value="1">
                  <small>Multiply all rewards (except crash penalty). Fine-tune how aggressive the agent becomes.</small>
                </div>
                <div class="param-control">
                  <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <input type="checkbox" id="autoRestartToggle" style="width: 18px; height: 18px;">
                    <span>Auto restart after every episode (wins or crashes keep training rolling).</span>
                  </label>
                  <p id="rlLiveMetrics" class="manual-hint" style="margin-bottom: 1rem;">Live metrics will appear here once RL starts.</p>
                  <div class="param-control">
                    <label>Training data &amp; AI settings</label>
                    <div class="button-row">
                      <button type="button" id="rlExportButton" class="button">üíæ Export</button>
                      <button type="button" id="rlImportButton" class="button">üìÇ Import</button>
                    </div>
                    <small>Backup the Q-table, rewards, and AI configuration ‚Äî or load a previous session.</small>
                    <input type="file" id="rlImportFile" accept="application/json" class="visually-hidden">
                  </div>
                  <div class="reward-impact-card collapsible-section" id="rewardImpactSection">
                    <div class="section-title-row compact">
                      <h4>üéØ Reward impact monitor</h4>
                      <button id="rewardImpactToggle" class="collapse-toggle" type="button" aria-expanded="false" aria-controls="rewardImpactContent" title="Show or hide reward impact breakdown">
                        <span class="chevron">‚ñæ</span>
                        <span class="collapse-label">Show breakdown</span>
                      </button>
                    </div>
                    <div id="rewardImpactContent" class="collapsible-content" hidden aria-hidden="true">
                      <p class="manual-hint" id="rewardImpactIntro">See which rewards and penalties shape RL training the most. Updates after each completed episode.</p>
                      <div class="reward-impact-table">
                        <div class="reward-impact-row reward-impact-header">
                          <span>Component</span>
                          <span>Last</span>
                          <span>Average</span>
                          <span>Share</span>
                          <span>Trend</span>
                        </div>
                        <div id="rlRewardImpactRows" class="reward-impact-rows">
                          <p class="reward-impact-empty">Enable RL to start tracking reward impact.</p>
                        </div>
                      </div>
                      <p id="rlRewardImpactSummary" class="manual-hint reward-impact-summary">Waiting for RL training to begin.</p>
                    </div>
                  </div>
                  <div class="episode-history-card">
                    <div class="episode-history-heading">
                      <h4>üìä Episode tracker</h4>
                      <small>Tracks last 10 RL runs</small>
                    </div>
                    <div class="episode-history-grid-header">
                      <span>Episode</span>
                      <span>Reward</span>
                      <span>Avg reward</span>
                      <span>Deaths (ep/avg)</span>
                      <span>Duration</span>
                      <span>Avg duration</span>
                    </div>
                    <div id="rlEpisodeHistoryRows" class="episode-history-rows">
                      <p class="episode-history-empty">Enable RL to start logging episodes.</p>
                    </div>
                  </div>
                  <button type="button" id="rlResetLearning" class="button" style="width: 100%;">üîÅ Reset RL learning</button>
                  <p class="manual-hint">Clears the Q-table, stats, and sets Œµ back to its starting value.</p>
                </div>
              </fieldset>
            </div>
          </div>
          <div class="controls-section collapsible-section" id="gridSizeSection">
            <div class="section-title-row">
              <h3>Grid Size</h3>
              <button id="gridSizeToggle" class="collapse-toggle" type="button" aria-expanded="true" aria-controls="gridSizeContent" title="Show or hide grid size settings">
                <span class="chevron">‚ñæ</span>
                <span class="collapse-label">Hide settings</span>
              </button>
            </div>
            <div id="gridSizeContent" class="collapsible-content">
              <div class="param-control">
                <label>Columns (COLS): <span id="colsValue">20</span></label>
                <input type="range" id="colsSlider" class="size-slider" min="10" max="100" value="20" step="5">
              </div>
              <div class="param-control">
                <label>Rows (ROWS): <span id="rowsValue">20</span></label>
                <input type="range" id="rowsSlider" class="size-slider" min="10" max="100" value="20" step="5">
              </div>
              <small style="display: block; margin-top: -0.5rem; color: var(--warning); opacity: 0.8;">
                ‚ö°Changing grid size will restart the game
              </small>
            </div>
          </div>
          <div class="controls-section collapsible-section" id="canvasSizeSection">
            <div class="section-title-row">
              <h3>Canvas Size</h3>
              <button id="canvasSizeToggle" class="collapse-toggle" type="button" aria-expanded="true" aria-controls="canvasSizeContent" title="Show or hide canvas size settings">
                <span class="chevron">‚ñæ</span>
                <span class="collapse-label">Hide settings</span>
              </button>
            </div>
            <div id="canvasSizeContent" class="collapsible-content">
              <div class="size-controls">
                <span>Small</span>
                <input type="range" id="sizeSlider" class="size-slider" min="300" max="800" value="400" step="50">
                <span>Large</span>
              </div>
            </div>
          </div>
          <div class="controls-section collapsible-section" id="aiParamsSection">
            <div class="section-title-row">
              <h3>AI Parameters</h3>
              <button id="aiParamsToggle" class="collapse-toggle" type="button" aria-expanded="true" aria-controls="aiParamsContent" title="Show or hide AI parameter settings">
                <span class="chevron">‚ñæ</span>
                <span class="collapse-label">Hide settings</span>
              </button>
            </div>
            <div id="aiParamsContent" class="collapsible-content">
              <div class="param-control">
                <label>Endgame Threshold: <span id="endgameValue">20</span></label>
                <input type="range" id="endgameSlider" class="size-slider" min="0" max="100" value="20" step="5">
                <small>Free cells for endgame mode</small>
              </div>
              <div class="param-control">
                <label>Loop Streak Threshold: <span id="loopThreshValue">3</span></label>
                <input type="range" id="loopThreshSlider" class="size-slider" min="1" max="10" value="3" step="1">
                <small>Loops detected before ‚Üí Hamilton mode</small>
              </div>
              <div class="param-control">
                <label>No Progress Threshold: <span id="progThreshValue">70</span></label>
                <input type="range" id="progThreshSlider" class="size-slider" min="10" max="200" value="70" step="5">
                <small>Moves without progress ‚Üí Hamilton mode</small>
              </div>
              <div class="param-control">
                <label for="compactProfile">Compact Mode Style</label>
                <select id="compactProfile" class="select-control">
                  <option value="cautious">Extremely cautious</option>
                  <option value="balanced" selected>Balanced (current)</option>
                  <option value="risky">Extremely daring</option>
                </select>
                <small id="compactProfileHint">Default behaviour that reacts to pockets or loops.</small>
              </div>
              <div class="param-control">
                <label>Compact Mode Steps: <span id="compactValue">200</span></label>
                <input type="range" id="compactSlider" class="size-slider" min="0" max="300" value="200" step="10">
                <small>Max steps in compact mode</small>
              </div>
            </div>
          </div>
          <div class="controls-section collapsible-section" id="gameStatusSection">
            <div class="section-title-row">
              <h3>Game Status</h3>
              <button id="gameStatusToggle" class="collapse-toggle" type="button" aria-expanded="true" aria-controls="gameStatusContent" title="Show or hide live game status">
                <span class="chevron">‚ñæ</span>
                <span class="collapse-label">Hide status</span>
              </button>
            </div>
            <div id="gameStatusContent" class="collapsible-content">
              <div class="status-display">
                <div class="status-item">
                  <span class="status-label">Length:</span>
                  <span id="snakeLength" class="status-value">3</span>
                </div>
                <div class="status-item">
                  <span class="status-label">Free cells:</span>
                  <span id="freeCells" class="status-value">222</span>
                </div>
                <div class="status-item">
                  <span class="status-label">Progress:</span>
                  <span id="progress" class="status-value">1.3%</span>
                </div>
                <div class="status-item">
                  <span class="status-label">Elapsed:</span>
                  <span id="elapsedTime" class="status-value">00:00.0</span>
                </div>
                <div class="status-item">
                  <span class="status-label">Best time:</span>
                  <span id="bestTime" class="status-value">--</span>
                </div>
                <div class="status-item">
                  <span class="status-label">Completed:</span>
                  <span id="completedRounds" class="status-value">0</span>
                </div>
              </div>
            </div>
          </div>
          <div class="controls-section collapsible-section" id="aiStatusSection">
            <div class="section-title-row">
              <h3>AI Status</h3>
              <button id="aiStatusToggle" class="collapse-toggle" type="button" aria-expanded="true" aria-controls="aiStatusContent" title="Show or hide AI status updates">
                <span class="chevron">‚ñæ</span>
                <span class="collapse-label">Hide status</span>
              </button>
            </div>
            <div id="aiStatusContent" class="collapsible-content">
              <div id="statusMessages">
                <p id="strategyStatus">Strategy: Initializing</p>
                <p id="strategyExplanation" class="status-explanation"></p>
                <p id="hamStatus"></p>
                <p id="loopStatus"></p>
                <p id="compactStatus"></p>
                <p id="compactStepStatus"></p>
                <p id="rlStatus"></p>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>
  <!-- Guide Page -->
  <div id="guide-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Parameter Guide</h1>
        <p>Learn to fine-tune the AI for optimal performance</p>
      </div>
      <div class="info-content">
        <div class="info-section">
          <h2>üéØ Quick Guide</h2>
          <p>Each parameter affects how cautious or aggressive the AI is. Start by adjusting <strong>Endgame Threshold</strong>, as it has the biggest impact on whether the snake plays safely or takes risks. Find the balance between speed and safety!</p>
        </div>
        <div class="info-section">
          <h2>üìè Grid Size</h2>
          <h3>Columns &amp; Rows (10-60)</h3>
          <p><strong>What it does:</strong> Determines the game size - number of cells horizontally and vertically.</p>
          <ul>
            <li><strong>Small grids (10x10):</strong> Fast games, AI must be very careful</li>
            <li><strong>Medium (20x20):</strong> Balanced gameplay, standard setting</li>
            <li><strong>Large (30x30):</strong> Long games requiring patience, AI can take more risks</li>
          </ul>
          <p><strong>Tip:</strong> Start with 10x10 to learn the parameters.</p>
        </div>
        <div class="info-section">
          <h2>ü§ñ AI Parameters</h2>
          <!-- Endgame parameter first -->
          <h3>1. Endgame Threshold (5-100+)</h3>
          <p><strong>Why it matters most:</strong> This setting determines when the AI abandons risky fruit-hunting and switches to a safe Hamilton cycle. A lower value means the AI will stay aggressive until there are very few free cells left; a higher value makes it switch earlier.</p>
          <p><strong>What it does:</strong> When the number of free cells remaining drops below this threshold, the AI enters "endgame" mode. In endgame it follows a pre‚Äëbuilt Hamilton cycle to avoid trapping itself and ensure it can eventually fill the board.</p>
          <ul>
            <li><strong>Low value (10-30):</strong> Endgame only at the very end ‚Äì faster but riskier on tight grids</li>
            <li><strong>Medium (40-60):</strong> Safer and suitable for medium grids</li>
            <li><strong>High (70+):</strong> Very cautious ‚Äì ideal for large boards or when you want maximum safety</li>
          </ul>
          <p><strong>When to adjust:</strong> On small grids, keep this low so the AI grabs fruit until the last moments. For bigger boards, increase it so the snake enters endgame earlier and follows a safe route.</p>
          
          <h3>2. Loop Streak Threshold (1-10)</h3>
          <p><strong>What it does:</strong> Number of times the AI can detect a looping pattern before forcing a switch to the safe Hamilton mode. A loop happens when the snake keeps revisiting the same area.</p>
          <ul>
            <li><strong>Low value (1-3):</strong> Quickly switches to safe mode, good for small grids or when loops are deadly</li>
            <li><strong>Medium (4-6):</strong> Balanced, allows some loops</li>
            <li><strong>High (7-10):</strong> Allows many loops, risky but faster on open boards</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase if the snake gets stuck in Hamilton too often. Decrease if it dies while looping.</p>
          
          <h3>3. No Progress Threshold (10-200+)</h3>
          <p><strong>What it does:</strong> Number of moves without getting closer to the fruit before the AI gives up and goes safe. This helps avoid wasting time when fruit is inaccessible.</p>
          <ul>
            <li><strong>Low value (10-50):</strong> Gives up quickly, very safe but slower on large boards</li>
            <li><strong>Medium (50-100):</strong> Standard patience</li>
            <li><strong>High (100+):</strong> Persistent, keeps trying for a long time</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase for larger grids where navigation takes time. Decrease if the snake "wanders" too much without making progress.</p>
          
          <h3>4. Compact Mode Steps (50-300+)</h3>
          <p><strong>What it does:</strong> Maximum number of steps the AI can spend in compact zig‚Äëzag mode when the fruit is trapped in a small pocket. This helps it navigate tight spaces without colliding.</p>
          <ul>
            <li><strong>Low value (50-100):</strong> Short zig‚Äëzag, switches quickly back to other strategies</li>
            <li><strong>Medium (100-200):</strong> Standard length</li>
            <li><strong>High (200+):</strong> Long zig‚Äëzag sequences ‚Äì useful on large boards</li>
          </ul>
          <p><strong>When to adjust:</strong> Increase for larger grids. Decrease if the snake seems to "vibrate" too much in one area.</p>
          <h3>Compact Mode Styles</h3>
          <ul>
            <li><strong>Extremely cautious:</strong> Waits for tight pockets and repeated loops before using zig-zag.</li>
            <li><strong>Balanced:</strong> Original behaviour ‚Äì reacts to pockets or clear loops.</li>
            <li><strong>Extremely daring:</strong> Jumps in early to untangle loops or hard-to-reach fruit.</li>
          </ul>
          <p><strong>Tip:</strong> Pick the cautious style on small boards where every cell matters, and the daring style on large boards for faster recovery.</p>
        </div>
        <div class="info-section">
          <h2>‚ö° Optimization Strategy</h2>
          <h3>For fastest possible game:</h3>
          <ul>
            <li>Loop Threshold: 5-7</li>
            <li>No Progress: 80-120</li>
            <li>Endgame: 5-30</li>
            <li>Compact Steps: 150-200</li>
          </ul>
          <h3>For safest possible game:</h3>
          <ul>
            <li>Loop Threshold: 1-2</li>
            <li>No Progress: 30-50</li>
            <li>Endgame: 60-80</li>
            <li>Compact Steps: 50-100</li>
          </ul>
          <h3>Balanced (recommended):</h3>
          <ul>
            <li>Loop Threshold: 3-4</li>
            <li>No Progress: 50-80</li>
            <li>Endgame: 40-50</li>
            <li>Compact Steps: 100-150</li>
          </ul>
        </div>
        <!-- Detailed algorithm explanations moved from About -->
        <div class="info-section">
          <h2>üîç Algorithm Overview</h2>
          <h3>Hamilton Cycle</h3>
          <p>The Hamilton cycle is a pre‚Äëcomputed path that visits every cell on the board exactly once. Following this path guarantees that the snake never crosses its own body. This path acts as a safety net when other strategies fail or when the board is nearly full. In endgame mode the AI follows the Hamilton cycle to fill the remaining cells without dying.</p>
          <h3>Greedy Pathfinding</h3>
          <p>When there is plenty of open space, the AI uses a greedy approach: it picks moves that reduce the Manhattan distance to the fruit. This allows quick fruit collection. However, greedy movement is only used if it keeps the snake‚Äôs tail reachable. Before each greedy move, the AI checks that it can still eventually reach the tail so it doesn‚Äôt trap itself.</p>
          <h3>Loop Detection</h3>
          <p>If the snake moves in circles without making progress, the AI identifies this as a loop. After a certain number of loops (controlled by the Loop Streak Threshold) it forces a switch to the Hamilton cycle. Breaking loops prevents the snake from wasting time or creating dead ends.</p>
          <h3>Compact Mode</h3>
          <p>When the fruit appears in a confined area or is surrounded by the snake‚Äôs body, the AI enters compact mode. In this mode the snake performs a zig‚Äëzag pattern to efficiently fill small pockets of space and avoid cutting itself off. The maximum steps spent in this mode are controlled by the Compact Mode Steps parameter.</p>
          <h3>Endgame Strategy</h3>
          <p>As the board fills up, the risk of collision increases. Once the number of free cells falls below the endgame threshold, the AI commits to the Hamilton cycle. This ensures the snake can reach every remaining cell and eventually achieve a perfect game.</p>
        </div>
      </div>
    </div>
  </div>
  <!-- AI Handbook Page -->
  <div id="ai-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>AI Handbook</h1>
        <p>Understand how the smart pieces work together: classic algorithms, heuristic AI, and reinforcement learning.</p>
      </div>
      <div class="info-content">
        <div class="info-section">
          <h2>ü§î What do ML, RL, and classic algorithms mean?</h2>
          <h3>Machine Learning (ML)</h3>
          <p>Machine learning is the umbrella for techniques where a model learns from data. In Snake we use ML when the agent collects experience from games and adjusts its behaviour based on the outcome. Reinforcement learning (RL) is a specialised branch of ML.</p>
          <h3>Reinforcement Learning (RL)</h3>
          <p>In reinforcement learning the agent tries different moves, receives <em>rewards</em> or <em>penalties</em>, and updates an internal table (a Q-table) that describes how good each action is in a given situation. Over time the agent learns to maximise the expected reward.</p>
          <h3>Classic algorithms (rules / heuristics)</h3>
          <p>Alongside ML we rely on handcrafted algorithms such as the Hamilton cycle, BFS search, and compact zig-zag movements. These deterministic rules always behave the same way in the same situation and work without any learning.</p>
        </div>
        <div class="info-section">
          <h2>üîó How the parts work together</h2>
          <ul>
            <li><strong>Baseline safety via algorithms:</strong> The Hamilton cycle and BFS guarantee that the snake always has a safe route when the board gets tight.</li>
            <li><strong>Heuristic switches:</strong> Loop and compact modes analyse the situation and hand over to safe patterns when needed.</li>
            <li><strong>RL on top:</strong> When RL is enabled the agent chooses between the safe moves. It searches for the option that leads to the highest long-term reward by updating the Q-table.</li>
            <li><strong>Result:</strong> You combine the stability of algorithms with the flexibility of ML. The agent experiments with new paths but falls back to the safety net when necessary.</li>
          </ul>
          <p>An episode starts when the game begins and ends when the snake crashes or fills the entire board. After each episode the exploration rate (Œµ) is updated according to your settings.</p>
        </div>
        <div class="info-section">
          <h2>üßÆ The reward system</h2>
          <p>When RL is active every move becomes a learning opportunity. You can shape how attractive different outcomes are:</p>
          <ul>
            <li><strong>Step penalty:</strong> A small negative value per move so the agent does not stall.</li>
            <li><strong>Fruit reward:</strong> Positive reward when fruit is eaten ‚Äì controls how aggressively the agent hunts fruit.</li>
            <li><strong>Win bonus:</strong> Extra reward for filling the whole board, rewarding long-term survival.</li>
            <li><strong>Crash penalty:</strong> A large negative value on collision to avoid self-destructing plays.</li>
            <li><strong>Dead-end penalty:</strong> Punishes moves that leave no safe escape so the agent learns to avoid cul-de-sacs.</li>
          </ul>
          <p>Press <strong>"Reset RL learning"</strong> to start over with the current reward values.</p>
        </div>
        <div class="info-section">
          <h2>‚öôÔ∏è RL hyperparameters</h2>
          <ul>
            <li><strong>Learning rate (Œ±):</strong> Controls how fast Q-values update. A high Œ± learns faster but can be unstable.</li>
            <li><strong>Discount (Œ≥):</strong> Determines how much future rewards matter. A high Œ≥ makes the agent more long-term.</li>
            <li><strong>Exploration (Œµ):</strong> Governs how often the agent tries new moves. Over time Œµ decays toward Min-Œµ.</li>
          </ul>
          <p>Tweak a parameter and play a few rounds. Track progress in the <strong>AI Status</strong> panel where you can see the current Œµ, episode count, and average reward.</p>
        </div>
        <div class="info-section">
          <h2>üß≠ Recommended strategies</h2>
          <ul>
            <li><strong>Fast start:</strong> High start Œµ (0.5‚Äì0.7) and a slightly harsher step penalty to encourage exploration.</li>
            <li><strong>Fine-tuning:</strong> Lower Œ± to 0.1 and Œµ-decay to 0.998 once the agent has a behaviour you like.</li>
            <li><strong>Risk control:</strong> Combine a strong crash penalty with a high fruit reward to balance safety and aggression.</li>
          </ul>
          <p>You can always switch back to the heuristic AI by turning off RL ‚Äì then only the handcrafted algorithms are used.</p>
        </div>
      </div>
    </div>
  </div>
  <!-- Facit Page (Presets) -->
  <div id="facit-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Presets - Proven Combinations</h1>
        <p>Test these optimized settings for different game types</p>
      </div>
     <div class="info-section">
          <h2>üêú Small Grid (10x10)</h2>
          <p><strong>Goal:</strong> Optimized for small, tight spaces</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 10x10</li>
              <li>Loop Threshold: 1</li>
              <li>No Progress: 30</li>
              <li>Endgame: 5</li>
              <li>Compact Steps: 50</li>
              <li>Speed: 120ms</li>
            </ul>
            <button class="button load-preset" data-preset="small">Load this</button>
          </div>
        </div>
        <div class="info-section">
          <h2>‚öñÔ∏è Balanced (20x20)</h2>
          <p><strong>Goal:</strong> Good balance between speed and safety</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 20x20</li>
              <li>Loop Threshold: 3</li>
              <li>No Progress: 70</li>
              <li>Endgame: 40</li>
              <li>Compact Steps: 200</li>
              <li>Speed: 80ms</li>
            </ul>
            <button class="button load-preset" data-preset="balanced">Load this</button>
          </div>
        </div>
        <div class="info-section">
          <h2>üéØ Ultra Challenge (30x30)</h2>
          <p><strong>Goal:</strong> For experts ‚Äì maximum grid with aggressive settings</p>
          <div class="combo-preset">
            <ul>
              <li>Grid: 30x30</li>
              <li>Loop Threshold: 5</li>
              <li>No Progress: 150</li>
              <li>Endgame: 80</li>
              <li>Compact Steps: 450</li>
              <li>Speed: 40ms</li>
            </ul>
            <button class="button load-preset" data-preset="ultra">Load this</button>
          </div>
        </div>
        <div class="info-section" style="background: var(--glass); border: 2px solid var(--accent);">
          <h2>üí° Tips for Custom Combinations</h2>
          <ul>
            <li><strong>Start conservatively:</strong> Set low thresholds and increase gradually</li>
            <li><strong>Test in stages:</strong> Run 5-10 games before adjusting</li>
            <li><strong>Document:</strong> Write down what works for different grid sizes</li>
            <li><strong>Experiment:</strong> Try extreme values to understand the effect</li>
            <li><strong>Share:</strong> Send us your best combinations!</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  <!-- Contact Page -->
  <div id="contact-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Contact Me</h1>
        <p>Have questions or feedback?</p>
      </div>
      <div class="contact-content">
        <div class="contact-card">
          <h2>üì¨ Get in Touch</h2>
          <p class="contact-info"></p>
          <a href="mailto:nomarcus@hotmail.com" class="contact-email">‚úâÔ∏è nomarcus@hotmail.com</a>
          <p style="margin-top:2rem;font-size:.9rem;opacity:.7;text-align:center;">
            Last change by <strong>Marcus Petersson</strong> ¬∑ 2025-09-08
          </p>
        </div>
      </div>
    </div>
  </div>
  <!-- Embedded updated JS logic -->
  <script>
    /* ===== KONFIGURATION ===== */
    let COLS = 20, ROWS = 20;
    let CELL = 30;
    let SPEED = 100;
    const DIRS = [ {dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0} ];
    const DIR_TO_INDEX = DIRS.reduce((acc, dir, idx) => {
      acc[`${dir.dx},${dir.dy}`] = idx;
      return acc;
    }, {});
    const MAX_SPEED = 500, MIN_SPEED = 1, SPEED_STEP = 10;
    let manualMode = false;
    let manualDirection = {dx: 1, dy: 0};
    let pendingManualDirection = null;
    let eatParticles = [];
    let safetyNetEnabled = true;
    let rlTrainingEnabled = false;
    let rlPendingChoice = null;
    let rlEpisodeActive = false;
    let autoRestartEnabled = false;
    let startTime = null;
    let elapsedTimerHandle = null;
    let lastElapsedMs = 0;
    let bestTimeMs = null;
    let lastObservedReward = 0;
    const RL_REWARD_COMPONENTS = [
      { id: 'stepPenalty', label: 'Step penalty' },
      { id: 'fruitReward', label: 'Fruit reward' },
      { id: 'winBonus', label: 'Win bonus' },
      { id: 'endgamePlanReward', label: 'Endgame plan bonus' },
      { id: 'compactModeReward', label: 'Compact mode bonus' },
      { id: 'deadEndPenalty', label: 'Dead-end penalty' },
      { id: 'deathPenalty', label: 'Crash penalty' },
      { id: 'loopPenalty', label: 'Loop stall penalty' }
    ];
    const RL_REWARD_COMPONENT_MAP = RL_REWARD_COMPONENTS.reduce((acc, entry) => {
      acc[entry.id] = entry;
      return acc;
    }, {});
    function createEmptyRewardImpactSnapshot(){
      return RL_REWARD_COMPONENTS.reduce((acc, entry) => {
        acc[entry.id] = 0;
        return acc;
      }, {});
    }
    const rlRewardImpactStats = {
      components: RL_REWARD_COMPONENTS.reduce((acc, entry) => {
        acc[entry.id] = { label: entry.label, total: 0, last: 0, prev: 0 };
        return acc;
      }, {}),
      episodes: 0,
      lastTotal: 0,
      prevTotal: 0
    };
    let rlRewardEpisodeAccumulator = createEmptyRewardImpactSnapshot();
    const BASE_TIMEOUT_PER_CELL_MS = 150;
    const MIN_RUN_TIMEOUT_MS = 30000;
    const MAX_RUN_TIMEOUT_MS = 120000;
    let runTimeoutMs = 0;
    let runTimeoutDeadline = null;
    let completedRounds = 0;
    const rlConfig = {
      stepPenalty: -0.05,
      fruitReward: 5,
      winBonus: 15,
      deathPenalty: -5,
      deadEndPenalty: -4,
      endgamePlanReward: 1.5,
      compactModeReward: 1,
      loopPenalty: -2,
      alpha: 0.2,
      gamma: 0.9,
      epsilonStart: 0.3,
      epsilonMin: 0.05,
      epsilonDecay: 0.995,
      rewardScale: 1,
      trainingEpisodes: 1
    };
    /* ===== DYNAMIC THRESHOLDS ===== */
    // Initialize endgame threshold; dynamic updates will override when grid changes
    let ENDGAME_THRESHOLD = 20;
    let MAX_LOOP_DETECTION = Math.max(8,(COLS+ROWS)/2|0);
    let WINDOW_SIZE = Math.max(10, COLS + ROWS);
    let FILL_POCKET_LIMIT = COLS * 4;
    let LOOP_ESCAPE_LIMIT = Math.max(40, Math.floor((COLS * ROWS) / 2));
    /* ===== CANVAS ===== */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let lastRender = performance.now();
    /* ===== AI PARAMETERS ===== */
    let LOOP_STREAK_THRESHOLD = 1;
    let NO_PROGRESS_THRESHOLD = 70;
    let COMPACT_MODE_MAX_STEPS = 200;
    let COMPACT_MODE_PROFILE = 'balanced';
    const COMPACT_MODE_PROFILES = {
      cautious: {
        label: 'Extremely cautious',
        hint: 'Activates only when the fruit is tightly boxed in and the loop is confirmed.',
        minFreeCells: 8,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: true,
        minLoopStreak: 2,
        allowCrowding: false
      },
      balanced: {
        label: 'Balanced (current)',
        hint: 'Original behaviour ‚Äì reacts to pockets or detected loops.',
        minFreeCells: 15,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: false,
        minLoopStreak: 1,
        allowCrowding: false
      },
      risky: {
        label: 'Extremely daring',
        hint: 'Jumps in early even at the slightest sign of congestion or awkward fruit.',
        minFreeCells: 0,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: false,
        minLoopStreak: 0,
        allowCrowding: true
      }
    };
    let loopCountAdjust = 0;
    const rlAgent = createReinforcementAgent(rlConfig);
    let rlBatchActive = false;
    let rlBatchEpisodesRemaining = 0;
    let rlBatchPlannedEpisodes = 1;
    let rlHintOverride = null;
    /* ===== GAME STATE ===== */
    let snake=[], snakeSet=new Set();
    let fruit, prevFruitDist=Infinity, noProgressMoves=0;
    let lastMoves=[], windowMoves=[], loopDetected=false, loopStreak=0,
        hamMode=false, compactMode=false, compactModeSteps=0,
        loopHandle=null, currentStrategy="Initializing";
    let compactModeJustActivated = false;
    let endgamePlanThisMove = false;
    let persistentLoopCounter = 0;
    let gameRunning = false;
    let autoRestartTimer = null;
    const STRATEGY_DESCRIPTIONS = {
      "Initializing": "Setting up a safe opening path before committing to a plan.",
      "Forcing Hamilton (Stagnation)": "Switching to the safety cycle because movement became repetitive.",
      "Forcing Hamilton (No progress)": "Entering the Hamilton cycle after too many moves without reaching fruit.",
      "Forcing Hamilton (Immediate Loop)": "Breaking a dangerous loop by following the Hamilton safety route.",
      "Final Hamilton": "Finishing the board by following the final Hamilton path.",
      "Returning to Hamilton": "Navigating back to the Hamilton cycle to stay safe.",
      "Endgame Hamilton": "Sticking to the Hamilton cycle while space is limited.",
      "Hamilton cycle": "Calmly marching along the Hamilton cycle for guaranteed coverage.",
      "Filling smallest pocket": "Closing a small empty pocket before it becomes a trap.",
      "Loop break (Longest)": "Taking the longest safe option to break a repeating loop.",
      "Greedy to fruit": "Charging directly for the fruit while it looks safe.",
      "Compact zig-zag": "Compressing the body with tight zig-zags to clear space.",
      "BFS to fruit": "Calculating the safest shortest path to the fruit.",
      "BFS to tail": "Using breadth-first search to reconnect with the tail safely.",
      "Heuristic": "Balancing fruit hunting with safety heuristics.",
      "No safe move!": "No safe moves remain ‚Äì preparing for impact.",
      "Unsafe chase": "Chasing the fruit without the usual safety checks.",
      "Unsafe roam": "Moving freely ‚Äì expect risky behaviour.",
      "Unsafe random": "Taking a random step with no safety guarantees."
    };
    function getStrategyExplanation(strategy) {
      return STRATEGY_DESCRIPTIONS[strategy] || "Assessing the board and adapting to the current situation.";
    }
    function createReinforcementAgent(config = {}){
      let alpha = typeof config.alpha === 'number' ? config.alpha : 0.2;
      let gamma = typeof config.gamma === 'number' ? config.gamma : 0.9;
      let epsilon = typeof config.epsilonStart === 'number' ? config.epsilonStart : 0.3;
      let epsilonMin = typeof config.epsilonMin === 'number' ? config.epsilonMin : 0.05;
      let epsilonDecay = typeof config.epsilonDecay === 'number' ? config.epsilonDecay : 0.995;
      const qTable = new Map();
      let episodes = 0;
      let episodeReward = 0;
      let totalReward = 0;
      let lastEpisodeReward = 0;
      let episodeStartTime = null;
      let lastEpisodeDuration = 0;
      let totalEpisodeDuration = 0;
      let currentEpisodeDeaths = 0;
      let lastEpisodeDeaths = 0;
      let totalEpisodeDeaths = 0;
      let totalOutcomes = 0;
      let completedEpisodes = 0;
      const outcomeCounts = Object.create(null);
      const stateKey = state => state.join('|');
      const ensureState = key => {
        if(!qTable.has(key)){
          qTable.set(key, Array(DIRS.length).fill(0));
        }
      };
      const nowMs = () => (typeof performance !== 'undefined' && typeof performance.now === 'function')
        ? performance.now()
        : Date.now();
      const applyHyperparameters = values => {
        if(values && typeof values === 'object'){
          if(typeof values.alpha === 'number'){
            alpha = values.alpha;
            config.alpha = values.alpha;
          }
          if(typeof values.gamma === 'number'){
            gamma = values.gamma;
            config.gamma = values.gamma;
          }
          if(typeof values.epsilonMin === 'number'){
            epsilonMin = values.epsilonMin;
            config.epsilonMin = values.epsilonMin;
          }
          if(typeof values.epsilonDecay === 'number'){
            epsilonDecay = values.epsilonDecay;
            config.epsilonDecay = values.epsilonDecay;
          }
          if(typeof values.epsilonStart === 'number'){
            config.epsilonStart = values.epsilonStart;
          }
        }
      };
      return {
        decide(state, safeMoves){
          if(!safeMoves || !safeMoves.length) return null;
          const key = stateKey(state);
          ensureState(key);
          let actionIdx;
          if(Math.random() < epsilon){
            const choice = safeMoves[(Math.random()*safeMoves.length)|0];
            actionIdx = choice.dirIndex;
          } else {
            const values = qTable.get(key);
            let best = -Infinity;
            let bestIndices = [];
            for(const move of safeMoves){
              const value = values[move.dirIndex];
              if(value > best){
                best = value;
                bestIndices = [move.dirIndex];
              } else if(value === best){
                bestIndices.push(move.dirIndex);
              }
            }
            if(bestIndices.length){
              actionIdx = bestIndices[(Math.random()*bestIndices.length)|0];
            } else {
              actionIdx = safeMoves[(Math.random()*safeMoves.length)|0].dirIndex;
            }
          }
          return { stateKey: key, actionIdx };
        },
        learn(prevKey, actionIdx, reward, nextState, done){
          ensureState(prevKey);
          const values = qTable.get(prevKey);
          let target = reward;
          if(!done && nextState){
            const nextKey = stateKey(nextState);
            ensureState(nextKey);
            const nextValues = qTable.get(nextKey);
            const maxNext = Math.max(...nextValues);
            target += gamma * maxNext;
          }
          values[actionIdx] += alpha * (target - values[actionIdx]);
          episodeReward += reward;
        },
        startEpisode(){
          episodeReward = 0;
          episodeStartTime = nowMs();
          currentEpisodeDeaths = 0;
        },
        endEpisode(){
          const finishedAt = nowMs();
          const duration = episodeStartTime ? finishedAt - episodeStartTime : 0;
          if(duration > 0){
            lastEpisodeDuration = duration;
            totalEpisodeDuration += duration;
          } else {
            lastEpisodeDuration = 0;
          }
          episodeStartTime = null;
          totalReward += episodeReward;
          lastEpisodeReward = episodeReward;
          lastEpisodeDeaths = currentEpisodeDeaths;
          totalEpisodeDeaths += currentEpisodeDeaths;
          episodes++;
          epsilon = Math.max(epsilon * epsilonDecay, epsilonMin);
          episodeReward = 0;
          currentEpisodeDeaths = 0;
        },
        registerTerminal(outcome){
          if(typeof outcome !== 'string') return;
          const key = outcome.trim().toLowerCase();
          if(!key) return;
          if(key === 'loss' || key === 'timeout'){
            currentEpisodeDeaths += 1;
          } else if(key === 'win'){
            completedEpisodes += 1;
          }
          outcomeCounts[key] = (outcomeCounts[key] || 0) + 1;
          totalOutcomes++;
        },
        setHyperparameters(values){
          applyHyperparameters(values);
        },
        resetEpsilon(value){
          const next = typeof value === 'number' ? value : config.epsilonStart;
          if(typeof next === 'number' && !Number.isNaN(next)){
            epsilon = next;
            config.epsilonStart = next;
          }
        },
        exportData(){
          const serializedTable = [];
          qTable.forEach((values, key) => {
            serializedTable.push([key, values.map(v => Number.isFinite(v) ? v : 0)]);
          });
          return {
            version: 1,
            hyperparameters: {
              alpha,
              gamma,
              epsilon,
              epsilonMin,
              epsilonDecay,
              epsilonStart: config.epsilonStart
            },
            stats: {
              episodes,
              episodeReward,
              totalReward,
              lastEpisodeReward,
              lastEpisodeDuration,
              totalEpisodeDuration,
              currentEpisodeDeaths,
              lastEpisodeDeaths,
              totalEpisodeDeaths,
              totalOutcomes,
              completedEpisodes
            },
            outcomes: { ...outcomeCounts },
            qTable: serializedTable
          };
        },
        importData(snapshot = {}){
          if(!snapshot || typeof snapshot !== 'object') return false;
          qTable.clear();
          const tableData = Array.isArray(snapshot.qTable) ? snapshot.qTable : [];
          for(const entry of tableData){
            if(!Array.isArray(entry) || entry.length < 2) continue;
            const [key, rawValues] = entry;
            if(typeof key !== 'string' || !Array.isArray(rawValues)) continue;
            const normalized = rawValues.map(v => Number.isFinite(v) ? v : 0);
            while(normalized.length < DIRS.length){
              normalized.push(0);
            }
            if(normalized.length > DIRS.length){
              normalized.length = DIRS.length;
            }
            qTable.set(key, normalized);
          }
          const hyper = snapshot.hyperparameters || {};
          applyHyperparameters(hyper);
          if(typeof hyper.epsilon === 'number' && !Number.isNaN(hyper.epsilon)){
            epsilon = hyper.epsilon;
          } else if(typeof config.epsilonStart === 'number' && !Number.isNaN(config.epsilonStart)){
            epsilon = config.epsilonStart;
          }
          const stats = snapshot.stats || {};
          if(Number.isFinite(stats.episodes)) episodes = stats.episodes;
          if(Number.isFinite(stats.episodeReward)) episodeReward = stats.episodeReward;
          if(Number.isFinite(stats.totalReward)) totalReward = stats.totalReward;
          if(Number.isFinite(stats.lastEpisodeReward)) lastEpisodeReward = stats.lastEpisodeReward;
          if(Number.isFinite(stats.lastEpisodeDuration)) lastEpisodeDuration = stats.lastEpisodeDuration;
          if(Number.isFinite(stats.totalEpisodeDuration)) totalEpisodeDuration = stats.totalEpisodeDuration;
          if(Number.isFinite(stats.currentEpisodeDeaths)) currentEpisodeDeaths = stats.currentEpisodeDeaths;
          if(Number.isFinite(stats.lastEpisodeDeaths)) lastEpisodeDeaths = stats.lastEpisodeDeaths;
          if(Number.isFinite(stats.totalEpisodeDeaths)) totalEpisodeDeaths = stats.totalEpisodeDeaths;
          if(Number.isFinite(stats.totalOutcomes)) totalOutcomes = stats.totalOutcomes;
          if(Number.isFinite(stats.completedEpisodes)) completedEpisodes = stats.completedEpisodes;
          for(const key in outcomeCounts){
            if(Object.prototype.hasOwnProperty.call(outcomeCounts, key)){
              delete outcomeCounts[key];
            }
          }
          if(snapshot.outcomes && typeof snapshot.outcomes === 'object'){
            for(const key of Object.keys(snapshot.outcomes)){
              const value = snapshot.outcomes[key];
              if(Number.isFinite(value)){
                outcomeCounts[key] = value;
              }
            }
          }
          episodeStartTime = null;
          return true;
        },
        resetLearning(){
          qTable.clear();
          episodes = 0;
          episodeReward = 0;
          totalReward = 0;
          lastEpisodeReward = 0;
          episodeStartTime = null;
          lastEpisodeDuration = 0;
          totalEpisodeDuration = 0;
          currentEpisodeDeaths = 0;
          lastEpisodeDeaths = 0;
          totalEpisodeDeaths = 0;
          totalOutcomes = 0;
          completedEpisodes = 0;
          for(const key in outcomeCounts){
            if(Object.prototype.hasOwnProperty.call(outcomeCounts, key)){
              delete outcomeCounts[key];
            }
          }
          applyHyperparameters(config);
          this.resetEpsilon(config.epsilonStart);
        },
        getStats(){
          return {
            epsilon,
            episodes,
            lastEpisodeReward,
            averageReward: episodes ? totalReward / episodes : 0,
            lastEpisodeDuration,
            averageEpisodeDuration: episodes ? totalEpisodeDuration / episodes : 0,
            lastEpisodeDeaths,
            averageDeaths: episodes ? totalEpisodeDeaths / episodes : 0,
            completedEpisodes,
            alpha,
            gamma,
            epsilonMin,
            epsilonDecay,
            stateCount: qTable.size,
            outcomes: { ...outcomeCounts },
            totalOutcomes
          };
        }
      };
    }
    /* ===== PAGE NAVIGATION ===== */
    const navLinks = document.querySelectorAll('.nav-link');
    const pages = document.querySelectorAll('.page');
    navLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetPage = link.dataset.page;
        navLinks.forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        pages.forEach(p => p.classList.remove('active'));
        document.getElementById(`${targetPage}-page`).classList.add('active');
      });
    });
    const manualToggleBtn = document.getElementById('manualToggle');
    const manualHint = document.getElementById('manualHint');
    const safetyNetToggleBtn = document.getElementById('safetyNetToggle');
    const safetyNetHint = document.getElementById('safetyNetHint');
    const rlToggleBtn = document.getElementById('rlToggle');
    const rlHint = document.getElementById('rlHint');
    const rlParamFieldset = document.getElementById('rlParamFieldset');
    const rlResetButton = document.getElementById('rlResetLearning');
    const autoRestartToggle = document.getElementById('autoRestartToggle');
    const rlLiveMetricsEl = document.getElementById('rlLiveMetrics');
    const rlEpisodeHistoryRows = document.getElementById('rlEpisodeHistoryRows');
    const rlPanelToggleBtn = document.getElementById('rlPanelToggle');
    const rlExportButton = document.getElementById('rlExportButton');
    const rlImportButton = document.getElementById('rlImportButton');
    const rlImportFileInput = document.getElementById('rlImportFile');
    const rewardImpactSectionEl = document.getElementById('rewardImpactSection');
    const rewardImpactToggleBtn = document.getElementById('rewardImpactToggle');
    const rewardImpactContentEl = document.getElementById('rewardImpactContent');
    const rlConfigSectionEl = document.querySelector('.rl-config-section');
    const rlParamContentEl = document.getElementById('rlParamContent');
    const gridSizeSectionEl = document.getElementById('gridSizeSection');
    const gridSizeToggleBtn = document.getElementById('gridSizeToggle');
    const gridSizeContentEl = document.getElementById('gridSizeContent');
    const canvasSizeSectionEl = document.getElementById('canvasSizeSection');
    const canvasSizeToggleBtn = document.getElementById('canvasSizeToggle');
    const canvasSizeContentEl = document.getElementById('canvasSizeContent');
    const aiParamsSectionEl = document.getElementById('aiParamsSection');
    const aiParamsToggleBtn = document.getElementById('aiParamsToggle');
    const aiParamsContentEl = document.getElementById('aiParamsContent');
    const gameStatusSectionEl = document.getElementById('gameStatusSection');
    const gameStatusToggleBtn = document.getElementById('gameStatusToggle');
    const gameStatusContentEl = document.getElementById('gameStatusContent');
    const aiStatusSectionEl = document.getElementById('aiStatusSection');
    const aiStatusToggleBtn = document.getElementById('aiStatusToggle');
    const aiStatusContentEl = document.getElementById('aiStatusContent');
    const RL_CONTROL_BINDINGS = [
      { id: 'rlStepPenalty', valueId: 'rlStepPenaltyValue', key: 'stepPenalty', parser: parseFloat, format: v => v.toFixed(2) },
      { id: 'rlFruitReward', valueId: 'rlFruitRewardValue', key: 'fruitReward', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlWinBonus', valueId: 'rlWinBonusValue', key: 'winBonus', parser: parseFloat, format: v => v.toFixed(0) },
      { id: 'rlEndgameReward', valueId: 'rlEndgameRewardValue', key: 'endgamePlanReward', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlCompactReward', valueId: 'rlCompactRewardValue', key: 'compactModeReward', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlDeathPenalty', valueId: 'rlDeathPenaltyValue', key: 'deathPenalty', parser: parseFloat, format: v => v.toFixed(0) },
      { id: 'rlDeadEndPenalty', valueId: 'rlDeadEndPenaltyValue', key: 'deadEndPenalty', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlLoopPenalty', valueId: 'rlLoopPenaltyValue', key: 'loopPenalty', parser: parseFloat, format: v => v.toFixed(1) },
      { id: 'rlAlpha', valueId: 'rlAlphaValue', key: 'alpha', parser: parseFloat, format: v => v.toFixed(2), onChange: v => rlAgent.setHyperparameters({ alpha: v }) },
      { id: 'rlGamma', valueId: 'rlGammaValue', key: 'gamma', parser: parseFloat, format: v => v.toFixed(2), onChange: v => rlAgent.setHyperparameters({ gamma: v }) },
      { id: 'rlEpsilonStart', valueId: 'rlEpsilonStartValue', key: 'epsilonStart', parser: parseFloat, format: v => v.toFixed(2), onChange: v => { rlAgent.setHyperparameters({ epsilonStart: v }); rlAgent.resetEpsilon(v); } },
      { id: 'rlEpsilonMin', valueId: 'rlEpsilonMinValue', key: 'epsilonMin', parser: parseFloat, format: v => v.toFixed(2), onChange: v => rlAgent.setHyperparameters({ epsilonMin: v }) },
      { id: 'rlEpsilonDecay', valueId: 'rlEpsilonDecayValue', key: 'epsilonDecay', parser: parseFloat, format: v => v.toFixed(3), onChange: v => rlAgent.setHyperparameters({ epsilonDecay: v }) },
      { id: 'rlEpisodes', valueId: 'rlEpisodesValue', key: 'trainingEpisodes', parser: value => {
        const parsed = Number(value);
        if(Number.isNaN(parsed)) return 1;
        return Math.max(1, Math.round(parsed));
      }, format: v => Math.round(v), onChange: v => {
        if(rlTrainingEnabled && !autoRestartEnabled){
          rlBatchPlannedEpisodes = Math.max(1, Math.round(v));
          if(rlBatchPlannedEpisodes > 1){
            rlBatchActive = true;
            rlBatchEpisodesRemaining = rlBatchPlannedEpisodes - 1;
          } else {
            rlBatchActive = false;
            rlBatchEpisodesRemaining = 0;
          }
        }
      } },
      { id: 'rlRewardScale', valueId: 'rlRewardScaleValue', key: 'rewardScale', parser: parseFloat, format: v => v.toFixed(1) }
    ];
    const MAX_EPISODE_HISTORY = 10;
    const rlEpisodeLog = [];
    function formatRewardValue(value){
      return Number.isFinite(value) ? value.toFixed(2) : '--';
    }
    function formatRewardChange(value){
      if(!Number.isFinite(value)) return '--';
      const rounded = value.toFixed(2);
      if(value > 0) return `+${rounded}`;
      if(value === 0) return '0.00';
      return rounded;
    }
    function formatImpactTrend(diff){
      if(!Number.isFinite(diff) || Math.abs(diff) < 0.01){
        return '<span class="trend trend-flat">‚Äî</span>';
      }
      const directionClass = diff > 0 ? 'trend-up' : 'trend-down';
      const arrow = diff > 0 ? '‚ñ≤' : '‚ñº';
      return `<span class="trend ${directionClass}">${arrow} ${formatRewardChange(diff)}</span>`;
    }
    function normalizeRewardBreakdown(entries, reward, effectiveReward, scaleApplied, scaleValue){
      if(!Array.isArray(entries) || !entries.length) return [];
      const sanitized = entries
        .map(entry => ({ id: entry?.id, amount: Number(entry?.amount) }))
        .filter(entry => entry.id && RL_REWARD_COMPONENT_MAP[entry.id] && Number.isFinite(entry.amount));
      if(!sanitized.length) return [];
      let factor = 1;
      if(scaleApplied && Number.isFinite(scaleValue) && scaleValue !== 1){
        if(Number.isFinite(reward) && Math.abs(reward) > 1e-9){
          factor = effectiveReward / reward;
        } else if(Number.isFinite(effectiveReward)){
          factor = scaleValue;
        }
      }
      if(factor !== 1){
        return sanitized.map(entry => ({ id: entry.id, amount: entry.amount * factor }));
      }
      return sanitized;
    }
    function recordRewardBreakdown(entries){
      if(!Array.isArray(entries) || !entries.length) return;
      entries.forEach(entry => {
        if(!(entry.id in rlRewardEpisodeAccumulator)) return;
        const value = Number(entry.amount);
        if(!Number.isFinite(value)) return;
        rlRewardEpisodeAccumulator[entry.id] += value;
      });
    }
    function resetRewardImpactEpisode(){
      rlRewardEpisodeAccumulator = createEmptyRewardImpactSnapshot();
    }
    function resetRewardImpactStats(){
      RL_REWARD_COMPONENTS.forEach(entry => {
        rlRewardImpactStats.components[entry.id] = {
          label: entry.label,
          total: 0,
          last: 0,
          prev: 0
        };
      });
      rlRewardImpactStats.episodes = 0;
      rlRewardImpactStats.prevTotal = 0;
      rlRewardImpactStats.lastTotal = 0;
      resetRewardImpactEpisode();
      updateRewardImpactUI();
    }
    function finalizeRewardImpactEpisode(){
      rlRewardImpactStats.episodes += 1;
      let episodeTotal = 0;
      RL_REWARD_COMPONENTS.forEach(entry => {
        const stats = rlRewardImpactStats.components[entry.id];
        const amount = rlRewardEpisodeAccumulator[entry.id] ?? 0;
        stats.prev = stats.last;
        stats.last = amount;
        stats.total += amount;
        episodeTotal += amount;
      });
      rlRewardImpactStats.prevTotal = rlRewardImpactStats.lastTotal;
      rlRewardImpactStats.lastTotal = episodeTotal;
      resetRewardImpactEpisode();
      updateRewardImpactUI();
    }
    function updateRewardImpactUI(){
      const rowsContainer = document.getElementById('rlRewardImpactRows');
      const summaryEl = document.getElementById('rlRewardImpactSummary');
      if(!rowsContainer) return;
      if(rlRewardImpactStats.episodes === 0){
        const message = rlTrainingEnabled
          ? 'Play an RL episode to populate impact data.'
          : 'Enable RL to start tracking reward impact.';
        rowsContainer.innerHTML = `<p class="reward-impact-empty">${message}</p>`;
        if(summaryEl){
          summaryEl.textContent = rlTrainingEnabled
            ? 'Waiting for the first RL episode to complete.'
            : 'Reward impact stats will appear once RL training is active.';
        }
        return;
      }
      const rowsData = RL_REWARD_COMPONENTS.map(entry => {
        const stats = rlRewardImpactStats.components[entry.id];
        const average = rlRewardImpactStats.episodes > 0
          ? stats.total / rlRewardImpactStats.episodes
          : 0;
        return {
          id: entry.id,
          label: entry.label,
          last: stats.last,
          avg: average,
          diff: stats.last - stats.prev
        };
      });
      const totalAbsAvg = rowsData.reduce((sum, row) => sum + Math.abs(row.avg), 0);
      const maxShare = rowsData.reduce((max, row) => {
        const share = totalAbsAvg > 0 ? Math.abs(row.avg) / totalAbsAvg : 0;
        return Math.max(max, share);
      }, 0);
      const rowsHtml = rowsData.map(row => {
        const share = totalAbsAvg > 0 ? Math.abs(row.avg) / totalAbsAvg : 0;
        const shareText = `${Math.round(share * 100)}%`;
        const classes = ['reward-impact-row'];
        if(maxShare > 0 && Math.abs(share - maxShare) < 1e-6){
          classes.push('impact-top');
        }
        return `
          <div class="${classes.join(' ')}">
            <span>${row.label}</span>
            <span>${formatRewardValue(row.last)}</span>
            <span>${formatRewardValue(row.avg)}</span>
            <span>${shareText}</span>
            <span>${formatImpactTrend(row.diff)}</span>
          </div>
        `;
      }).join('');
      rowsContainer.innerHTML = rowsHtml;
      if(summaryEl){
        const summaryParts = [
          `Episodes tracked: ${rlRewardImpactStats.episodes}`,
          `Last total: ${formatRewardValue(rlRewardImpactStats.lastTotal)}`
        ];
        if(rlRewardImpactStats.episodes > 1){
          const delta = rlRewardImpactStats.lastTotal - rlRewardImpactStats.prevTotal;
          summaryParts.push(`Œî vs prev: ${formatRewardChange(delta)}`);
        }
        if(rlEpisodeActive){
          summaryParts.push('Current episode running‚Ä¶');
        }
        summaryEl.textContent = summaryParts.join(' ¬∑ ');
      }
    }
    function formatEpisodeDuration(ms){
      if(!Number.isFinite(ms) || ms <= 0){
        return '--';
      }
      if(ms >= 60000){
        const minutes = Math.floor(ms / 60000);
        const seconds = ((ms % 60000) / 1000).toFixed(minutes >= 10 ? 0 : 1);
        return minutes ? `${minutes}m ${seconds}s` : `${seconds}s`;
      }
      return `${(ms / 1000).toFixed(2)}s`;
    }
    function formatDeathSummary(deaths, avgDeaths){
      const deathCount = Number.isFinite(deaths) ? deaths : 0;
      const avgText = Number.isFinite(avgDeaths) ? avgDeaths.toFixed(2) : '--';
      return `${deathCount} (${avgText})`;
    }
    function renderRlEpisodeHistory(){
      if(!rlEpisodeHistoryRows) return;
      if(!rlEpisodeLog.length){
        const message = rlTrainingEnabled
          ? 'No completed RL episodes yet.'
          : 'Enable RL to start logging episodes.';
        rlEpisodeHistoryRows.innerHTML = `<p class="episode-history-empty">${message}</p>`;
        return;
      }
      const rowsHtml = rlEpisodeLog.map(entry => `
        <div class="episode-history-row">
          <span>#${entry.episode}</span>
          <span>${formatRewardValue(entry.reward)}</span>
          <span>${formatRewardValue(entry.avgReward)}</span>
          <span>${formatDeathSummary(entry.deaths, entry.avgDeaths)}</span>
          <span>${formatEpisodeDuration(entry.duration)}</span>
          <span>${formatEpisodeDuration(entry.avgDuration)}</span>
        </div>
      `).join('');
      rlEpisodeHistoryRows.innerHTML = rowsHtml;
    }
    function recordRlEpisodeSnapshot(){
      const stats = rlAgent.getStats();
      if(!Number.isFinite(stats.episodes) || stats.episodes <= 0) return;
      rlEpisodeLog.unshift({
        episode: stats.episodes,
        reward: stats.lastEpisodeReward,
        avgReward: stats.averageReward,
        deaths: stats.lastEpisodeDeaths,
        avgDeaths: stats.averageDeaths,
        duration: stats.lastEpisodeDuration,
        avgDuration: stats.averageEpisodeDuration
      });
      if(rlEpisodeLog.length > MAX_EPISODE_HISTORY){
        rlEpisodeLog.length = MAX_EPISODE_HISTORY;
      }
      renderRlEpisodeHistory();
    }
    function sanitizeTrainingEpisodes(value){
      if(!Number.isFinite(value)) return 1;
      return Math.max(1, Math.round(value));
    }
    function resetRlBatchProgress(){
      rlBatchPlannedEpisodes = sanitizeTrainingEpisodes(rlConfig.trainingEpisodes);
      rlBatchActive = false;
      rlBatchEpisodesRemaining = 0;
    }
    function configureRlBatchForSession(){
      rlBatchPlannedEpisodes = sanitizeTrainingEpisodes(rlConfig.trainingEpisodes);
      if(!autoRestartEnabled && rlBatchPlannedEpisodes > 1){
        rlBatchActive = true;
        rlBatchEpisodesRemaining = rlBatchPlannedEpisodes - 1;
      } else {
        rlBatchActive = false;
        rlBatchEpisodesRemaining = 0;
      }
    }
    function cancelScheduledAutoRestart(){
      if(autoRestartTimer){
        clearTimeout(autoRestartTimer);
        autoRestartTimer = null;
      }
    }
    function handleRlEpisodeCompletion(){
      if(!rlTrainingEnabled || !rlBatchActive) return null;
      if(rlBatchEpisodesRemaining > 0){
        rlBatchEpisodesRemaining--;
        const completed = rlBatchPlannedEpisodes - (rlBatchEpisodesRemaining + 1);
        scheduleAutoRestart(450, true);
        return {
          trainingDisabled: false,
          message: `Batch training ${completed}/${rlBatchPlannedEpisodes} complete ‚Äì restarting‚Ä¶`
        };
      }
      const total = rlBatchPlannedEpisodes;
      cancelScheduledAutoRestart();
      rlTrainingEnabled = false;
      rlEpisodeActive = false;
      rlPendingChoice = null;
      resetRlBatchProgress();
      return {
        trainingDisabled: true,
        message: `Completed ${total} RL episodes ‚Äì training paused.`
      };
    }
    function setupCollapsibleSection(sectionEl, buttonEl, contentEl, options = {}){
      if(!sectionEl || !buttonEl || !contentEl) return null;
      const {
        collapsed = false,
        expandedLabel = 'Hide settings',
        collapsedLabel = 'Show settings'
      } = options;
      let isCollapsed = !!collapsed;
      const labelEl = buttonEl.querySelector('.collapse-label');
      function sync(){
        sectionEl.classList.toggle('collapsed', isCollapsed);
        buttonEl.setAttribute('aria-expanded', String(!isCollapsed));
        if(labelEl){
          labelEl.textContent = isCollapsed ? collapsedLabel : expandedLabel;
        }
        contentEl.hidden = isCollapsed;
        contentEl.setAttribute('aria-hidden', String(isCollapsed));
      }
      buttonEl.addEventListener('click', () => {
        isCollapsed = !isCollapsed;
        sync();
      });
      sync();
      return {
        setCollapsed(value){
          isCollapsed = !!value;
          sync();
        },
        isCollapsed(){
          return isCollapsed;
        }
      };
    }
    setupCollapsibleSection(
      rlConfigSectionEl,
      rlPanelToggleBtn,
      rlParamContentEl,
      { expandedLabel: 'Hide settings', collapsedLabel: 'Show settings' }
    );
    setupCollapsibleSection(
      rewardImpactSectionEl,
      rewardImpactToggleBtn,
      rewardImpactContentEl,
      { collapsed: true, expandedLabel: 'Hide breakdown', collapsedLabel: 'Show breakdown' }
    );
    setupCollapsibleSection(gridSizeSectionEl, gridSizeToggleBtn, gridSizeContentEl);
    setupCollapsibleSection(canvasSizeSectionEl, canvasSizeToggleBtn, canvasSizeContentEl);
    setupCollapsibleSection(aiParamsSectionEl, aiParamsToggleBtn, aiParamsContentEl);
    setupCollapsibleSection(
      gameStatusSectionEl,
      gameStatusToggleBtn,
      gameStatusContentEl,
      { expandedLabel: 'Hide status', collapsedLabel: 'Show status' }
    );
    setupCollapsibleSection(
      aiStatusSectionEl,
      aiStatusToggleBtn,
      aiStatusContentEl,
      { expandedLabel: 'Hide status', collapsedLabel: 'Show status' }
    );
    updateRewardImpactUI();
    const elapsedTimeEl = document.getElementById('elapsedTime');
    const bestTimeEl = document.getElementById('bestTime');
    const completedRoundsEl = document.getElementById('completedRounds');
    function formatTime(ms){
      if(!Number.isFinite(ms) || ms < 0) return '00:00.0';
      const totalSeconds = ms / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const tenths = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 10);
      return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${tenths}`;
    }
    function updateElapsedTimeDisplay(ms = 0){
      if(elapsedTimeEl){
        elapsedTimeEl.textContent = formatTime(ms);
      }
    }
    function updateCompletedRoundsDisplay(){
      if(completedRoundsEl){
        completedRoundsEl.textContent = completedRounds;
      }
    }
    function computeRunTimeout(){
      const area = COLS * ROWS;
      const estimated = area * BASE_TIMEOUT_PER_CELL_MS;
      return Math.max(MIN_RUN_TIMEOUT_MS, Math.min(MAX_RUN_TIMEOUT_MS, estimated));
    }
    function resetRunTimeoutDeadline(){
      const now = performance.now();
      runTimeoutDeadline = now + runTimeoutMs;
    }
    function updateBestTimeDisplay(){
      if(bestTimeEl){
        bestTimeEl.textContent = bestTimeMs != null ? formatTime(bestTimeMs) : '--';
      }
    }
    function cancelRunTimer(){
      if(elapsedTimerHandle){
        clearInterval(elapsedTimerHandle);
        elapsedTimerHandle = null;
      }
      startTime = null;
      lastElapsedMs = 0;
      updateElapsedTimeDisplay(0);
    }
    function startRunTimer(){
      cancelRunTimer();
      startTime = performance.now();
      elapsedTimerHandle = setInterval(() => {
        if(!gameRunning || startTime === null) return;
        lastElapsedMs = performance.now() - startTime;
        updateElapsedTimeDisplay(lastElapsedMs);
      }, 200);
    }
    function finishRun(won = false){
      if(startTime !== null){
        lastElapsedMs = performance.now() - startTime;
      }
      if(elapsedTimerHandle){
        clearInterval(elapsedTimerHandle);
        elapsedTimerHandle = null;
      }
      if(lastElapsedMs > 0){
        updateElapsedTimeDisplay(lastElapsedMs);
        if(won && (bestTimeMs === null || lastElapsedMs < bestTimeMs)){
          bestTimeMs = lastElapsedMs;
          updateBestTimeDisplay();
        }
      }
      startTime = null;
      runTimeoutDeadline = null;
    }
    updateElapsedTimeDisplay(0);
    updateBestTimeDisplay();
    runTimeoutMs = computeRunTimeout();
    updateCompletedRoundsDisplay();
    const KEY_TO_DIR = {
      'arrowup': {dx: 0, dy: -1},
      'w': {dx: 0, dy: -1},
      'arrowdown': {dx: 0, dy: 1},
      's': {dx: 0, dy: 1},
      'arrowleft': {dx: -1, dy: 0},
      'a': {dx: -1, dy: 0},
      'arrowright': {dx: 1, dy: 0},
      'd': {dx: 1, dy: 0}
    };
    function updateManualUI(){
      if(!manualToggleBtn || !manualHint) return;
      if(manualMode){
        manualToggleBtn.classList.add('toggle-active');
        manualToggleBtn.textContent = 'üß† Return to AI';
        manualHint.textContent = 'Manual mode active! Use arrow keys or WASD to steer the snake.';
      } else {
        manualToggleBtn.classList.remove('toggle-active');
        manualToggleBtn.textContent = 'üïπÔ∏è Try Manual Play';
        manualHint.textContent = 'Manual mode off ‚Äì AI is playing automatically.';
      }
    }
    function updateSafetyNetUI(){
      if(!safetyNetToggleBtn) return;
      if(safetyNetEnabled){
        safetyNetToggleBtn.classList.add('toggle-active');
        safetyNetToggleBtn.classList.remove('warning');
        safetyNetToggleBtn.textContent = 'üõ°Ô∏è Safety Net: ON';
        safetyNetToggleBtn.setAttribute('aria-pressed', 'true');
        if(safetyNetHint){
          safetyNetHint.textContent = 'Safety net algorithms are active.';
        }
      } else {
        safetyNetToggleBtn.classList.remove('toggle-active');
        safetyNetToggleBtn.classList.add('warning');
        safetyNetToggleBtn.textContent = '‚ö†Ô∏è Safety Net: OFF';
        safetyNetToggleBtn.setAttribute('aria-pressed', 'false');
        if(safetyNetHint){
          safetyNetHint.textContent = 'Safety net disabled ‚Äì the snake is on its own.';
        }
      }
    }
    function setSafetyNet(enabled){
      const next = !!enabled;
      const changed = next !== safetyNetEnabled;
      safetyNetEnabled = next;
      if(!safetyNetEnabled){
        hamMode = false;
        compactMode = false;
        compactModeSteps = 0;
        loopDetected = false;
        loopStreak = 0;
        loopCountAdjust = 0;
        noProgressMoves = 0;
        prevFruitDist = Infinity;
        persistentLoopCounter = 0;
        windowMoves = [];
        lastMoves = [];
        endgamePlanThisMove = false;
        currentStrategy = 'Unsafe roam';
      } else if(changed){
        currentStrategy = 'Initializing';
      }
      updateSafetyNetUI();
      updateRlStatus();
      draw();
    }
    function setInitialManualDirection(){
      if(snake.length > 1){
        manualDirection = {
          dx: snake[0].x - snake[1].x,
          dy: snake[0].y - snake[1].y
        };
      } else {
        manualDirection = {dx: 1, dy: 0};
      }
      pendingManualDirection = null;
    }
    function setManualDirection(dx, dy){
      const current = pendingManualDirection || manualDirection;
      if(current.dx === -dx && current.dy === -dy) return;
      pendingManualDirection = {dx, dy};
    }
    function toggleManualMode(){
      manualMode = !manualMode;
      if(manualMode){
        setInitialManualDirection();
        currentStrategy = 'Manual control';
      } else {
        pendingManualDirection = null;
      }
      updateManualUI();
    }
    function updateRlToggleUI(){
      if(!rlToggleBtn || !rlHint) return;
      if(rlTrainingEnabled){
        rlToggleBtn.classList.add('toggle-active');
        rlToggleBtn.textContent = 'ü§ñ RL Training On';
        const stats = rlAgent.getStats();
        rlHint.textContent = `RL is learning live ‚Äì episodes: ${stats.episodes}`;
      } else {
        rlToggleBtn.classList.remove('toggle-active');
        rlToggleBtn.textContent = 'ü§ñ Enable Reinforcement Learning';
        rlHint.textContent = 'Reinforcement learning is currently disabled.';
      }
      if(rlParamFieldset){
        rlParamFieldset.disabled = !rlTrainingEnabled;
        rlParamFieldset.classList.toggle('inactive', !rlTrainingEnabled);
      }
      if(autoRestartToggle){
        autoRestartToggle.checked = autoRestartEnabled;
        autoRestartToggle.disabled = !rlTrainingEnabled;
      }
      updateRlLiveMetrics();
      renderRlEpisodeHistory();
      updateRewardImpactUI();
    }
    function getManualNext(){
      const direction = pendingManualDirection || manualDirection;
      manualDirection = direction;
      pendingManualDirection = null;
      const head = snake[0];
      const next = {x: head.x + direction.dx, y: head.y + direction.dy};
      currentStrategy = 'Manual control';
      hamMode = false;
      loopDetected = false;
      compactMode = false;
      compactModeSteps = 0;
      return next;
    }
    function getCurrentDirection(){
      if(snake.length > 1){
        const dx = snake[0].x - snake[1].x;
        const dy = snake[0].y - snake[1].y;
        if(dx !== 0 || dy !== 0){
          return {dx: Math.sign(dx), dy: Math.sign(dy)};
        }
      }
      if(lastMoves.length > 1){
        const head = lastMoves[lastMoves.length - 1];
        const prev = lastMoves[lastMoves.length - 2];
        const dx = head.x - prev.x;
        const dy = head.y - prev.y;
        if(dx !== 0 || dy !== 0){
          return {dx: Math.sign(dx), dy: Math.sign(dy)};
        }
      }
      return {dx: 1, dy: 0};
    }
    function getDirIndex(dir){
      const key = `${dir.dx},${dir.dy}`;
      if(Object.prototype.hasOwnProperty.call(DIR_TO_INDEX, key)){
        return DIR_TO_INDEX[key];
      }
      return DIR_TO_INDEX['1,0'];
    }
    function getSafeMovesForRL(){
      const head = snake[0];
      if(!head) return [];
      const safeMoves = [];
      const tail = snake.length > 1 ? snake[snake.length - 1] : null;
      for(let i = 0; i < DIRS.length; i++){
        const d = DIRS[i];
        const nx = head.x + d.dx;
        const ny = head.y + d.dy;
        if(nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
        const key = `${nx},${ny}`;
        const ate = fruit && fruit.x === nx && fruit.y === ny;
        const isTailStep = tail && nx === tail.x && ny === tail.y;
        if(snakeSet.has(key) && !(isTailStep && !ate)) continue;
        if(safetyNetEnabled){
          const simulated = ate
            ? [{x: nx, y: ny}, ...snake]
            : [{x: nx, y: ny}, ...snake.slice(0, -1)];
          if(!canReachTailFrom({x: nx, y: ny}, simulated)) continue;
        }
        safeMoves.push({x: nx, y: ny, dirIndex: i, ate});
      }
      return safeMoves;
    }
    function isMoveLethal(move){
      return move?.outOfBounds || move?.hitsBody;
    }
    function pickViableMove(preferred, moves){
      if(!moves || !moves.length) return null;
      const preferredMatch = preferred
        ? moves.find(move => move.dirIndex === preferred.dirIndex)
        : null;
      if(preferredMatch && !isMoveLethal(preferredMatch)){
        return preferredMatch;
      }
      const safeOptions = moves.filter(move => !isMoveLethal(move));
      if(safeOptions.length){
        return safeOptions[(Math.random() * safeOptions.length) | 0];
      }
      return preferredMatch || moves[(Math.random() * moves.length) | 0];
    }
    function getAllMovesForRL(){
      const head = snake[0];
      if(!head) return [];
      const moves = [];
      const tail = snake.length > 1 ? snake[snake.length - 1] : null;
      for(let i = 0; i < DIRS.length; i++){
        const d = DIRS[i];
        const nx = head.x + d.dx;
        const ny = head.y + d.dy;
        const ate = fruit && fruit.x === nx && fruit.y === ny;
        const isTailStep = tail && nx === tail.x && ny === tail.y;
        const hitsBody = snakeSet.has(`${nx},${ny}`) && !(isTailStep && !ate);
        moves.push({
          x: nx,
          y: ny,
          dirIndex: i,
          ate,
          outOfBounds: nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS,
          hitsBody
        });
      }
      return moves;
    }
    function pickUnsafeMove(){
      const head = snake[0];
      if(!head) return null;
      const moves = getAllMovesForRL();
      if(!moves.length) return null;
      const safeMoves = moves.filter(move => !isMoveLethal(move));
      const currentDist = fruit && fruit.x >= 0
        ? Math.abs(head.x - fruit.x) + Math.abs(head.y - fruit.y)
        : Infinity;
      let best = null;
      const candidates = safeMoves.length ? safeMoves : moves;
      for(const move of candidates){
        let score = 0;
        if(move.ate) score += 50;
        if(!move.outOfBounds) score += 20; else score -= 15;
        if(!move.hitsBody) score += 15; else score -= 10;
        if(fruit && fruit.x >= 0){
          const dist = Math.abs(move.x - fruit.x) + Math.abs(move.y - fruit.y);
          score += (currentDist - dist) * 5;
        }
        score += Math.random();
        move.score = score;
        if(!best || score > best.score){
          best = move;
        }
      }
      if(best){
        return {x: best.x, y: best.y};
      }
      const fallback = pickViableMove(null, moves);
      if(fallback){
        return {x: fallback.x, y: fallback.y};
      }
      return null;
    }
    function buildRlObservation(safeMoves){
      const head = snake[0];
      if(!head) return ['empty'];
      const direction = getCurrentDirection();
      const safeSet = new Set((safeMoves || []).map(m => m.dirIndex));
      const frontDir = getDirIndex(direction);
      const leftDir = getDirIndex({dx: direction.dy, dy: -direction.dx});
      const rightDir = getDirIndex({dx: -direction.dy, dy: direction.dx});
      const frontDanger = safeSet.has(frontDir) ? 0 : 1;
      const leftDanger = safeSet.has(leftDir) ? 0 : 1;
      const rightDanger = safeSet.has(rightDir) ? 0 : 1;
      const fruitDX = fruit && fruit.x >= 0 ? Math.sign(fruit.x - head.x) : 0;
      const fruitDY = fruit && fruit.y >= 0 ? Math.sign(fruit.y - head.y) : 0;
      const freeCells = COLS * ROWS - snake.length;
      const freeBucket = Math.min(3, Math.floor(freeCells / Math.max(1, Math.floor((COLS * ROWS) / 4))));
      return [
        frontDanger,
        leftDanger,
        rightDanger,
        fruitDX,
        fruitDY,
        direction.dx,
        direction.dy,
        freeBucket,
        hamMode ? 1 : 0
      ];
    }
    function updateRlLiveMetrics(reward){
      if(!rlLiveMetricsEl) return;
      if(!rlTrainingEnabled){
        rlLiveMetricsEl.textContent = 'RL disabled ‚Äì live metrics paused.';
        return;
      }
      if(typeof reward === 'number' && !Number.isNaN(reward)){
        lastObservedReward = reward;
      }
      const stats = rlAgent.getStats();
      const rewardText = Number.isFinite(lastObservedReward) ? lastObservedReward.toFixed(2) : '0.00';
      const lastEpisodeText = Number.isFinite(stats.lastEpisodeReward) ? stats.lastEpisodeReward.toFixed(2) : '0.00';
      const avgText = Number.isFinite(stats.averageReward) ? stats.averageReward.toFixed(2) : '0.00';
      const episodesText = Number.isFinite(stats.episodes) ? stats.episodes : 0;
      const winsText = Number.isFinite(stats.completedEpisodes) ? stats.completedEpisodes : 0;
      const stateCountText = Number.isFinite(stats.stateCount) ? stats.stateCount.toLocaleString() : '0';
      const epsilonText = Number.isFinite(stats.epsilon) ? stats.epsilon.toFixed(3) : '--';
      const epsilonMinText = Number.isFinite(stats.epsilonMin) ? stats.epsilonMin.toFixed(2) : '--';
      const epsilonDecayText = Number.isFinite(stats.epsilonDecay) ? stats.epsilonDecay.toFixed(3) : '--';
      const alphaText = Number.isFinite(stats.alpha) ? stats.alpha.toFixed(2) : '--';
      const gammaText = Number.isFinite(stats.gamma) ? stats.gamma.toFixed(2) : '--';
      const lastDurationText = formatEpisodeDuration(stats.lastEpisodeDuration);
      const avgDurationText = formatEpisodeDuration(stats.averageEpisodeDuration);
      const lineOne = `Live: reward=${rewardText} ¬∑ last episode=${lastEpisodeText} ¬∑ avg=${avgText}`;
      const lastDeathsText = Number.isFinite(stats.lastEpisodeDeaths) ? stats.lastEpisodeDeaths : 0;
      const avgDeathsText = Number.isFinite(stats.averageDeaths) ? stats.averageDeaths.toFixed(2) : '0.00';
      const lineTwo = `episodes=${episodesText} ¬∑ wins=${winsText} ¬∑ states=${stateCountText} ¬∑ deaths last=${lastDeathsText} (avg=${avgDeathsText}) ¬∑ time last=${lastDurationText} ¬∑ avg=${avgDurationText}`;
      const lineThree = `Œµ=${epsilonText} (min=${epsilonMinText}, decay=${epsilonDecayText}) ¬∑ Œ±=${alphaText} ¬∑ Œ≥=${gammaText}`;
      rlLiveMetricsEl.innerHTML = `${lineOne}<br>${lineTwo}<br>${lineThree}`;
    }
    function applyRlUpdate(reward, done, options = {}){
      if(!rlTrainingEnabled){
        rlPendingChoice = null;
        return;
      }
      const shouldScale = !options.skipScaling && typeof reward === 'number' && Number.isFinite(reward);
      const scale = Number.isFinite(rlConfig.rewardScale) ? rlConfig.rewardScale : 1;
      const effectiveReward = shouldScale && scale !== 1 ? reward * scale : reward;
      const breakdownEntries = normalizeRewardBreakdown(
        options.breakdown,
        reward,
        effectiveReward,
        shouldScale && scale !== 1,
        scale
      );
      if(breakdownEntries.length){
        recordRewardBreakdown(breakdownEntries);
      }
      let episodeJustEnded = false;
      if(rlPendingChoice){
        const nextState = done ? null : buildRlObservation(getSafeMovesForRL());
        rlAgent.learn(rlPendingChoice.stateKey, rlPendingChoice.actionIdx, effectiveReward, nextState, done);
        if(done && rlEpisodeActive){
          rlAgent.endEpisode();
          rlEpisodeActive = false;
          episodeJustEnded = true;
        }
        rlPendingChoice = null;
      } else if(done && rlTrainingEnabled && rlEpisodeActive){
        rlAgent.endEpisode();
        rlEpisodeActive = false;
        episodeJustEnded = true;
      }
      let completionInfo = null;
      if(episodeJustEnded){
        recordRlEpisodeSnapshot();
        completionInfo = handleRlEpisodeCompletion();
        finalizeRewardImpactEpisode();
      }
      if(completionInfo?.trainingDisabled){
        rlHintOverride = completionInfo.message ?? rlHintOverride;
        updateRlToggleUI();
      }
      updateRlStatus();
      updateRlLiveMetrics(effectiveReward);
      if(!completionInfo?.trainingDisabled && completionInfo?.message && rlHint){
        rlHint.textContent = completionInfo.message;
      }
    }
    function updateRlStatus(){
      const rlStatusEl = document.getElementById('rlStatus');
      if(!rlStatusEl) return;
      if(!rlTrainingEnabled){
        rlStatusEl.textContent = 'RL disabled ‚Äì using handcrafted strategies only.';
        if(rlHint){
          rlHint.textContent = rlHintOverride ?? 'Reinforcement learning is currently disabled.';
        }
        updateRlLiveMetrics();
        return;
      }
      const stats = rlAgent.getStats();
      const epsilonText = Number.isFinite(stats.epsilon) ? stats.epsilon.toFixed(3) : '--';
      const episodesText = Number.isFinite(stats.episodes) ? stats.episodes : 0;
      const lastRewardText = formatRewardValue(stats.lastEpisodeReward);
      const avgRewardText = formatRewardValue(stats.averageReward);
      const lastDurationText = formatEpisodeDuration(stats.lastEpisodeDuration);
      const avgDurationText = formatEpisodeDuration(stats.averageEpisodeDuration);
      const lastDeathsText = Number.isFinite(stats.lastEpisodeDeaths) ? stats.lastEpisodeDeaths : 0;
      const avgDeathsText = Number.isFinite(stats.averageDeaths) ? stats.averageDeaths.toFixed(2) : '0.00';
      const winsText = Number.isFinite(stats.completedEpisodes) ? stats.completedEpisodes : 0;
      rlStatusEl.textContent = `RL training active ¬∑ Œµ=${epsilonText} ¬∑ episodes=${episodesText} ¬∑ wins=${winsText} ¬∑ last=${lastRewardText} ¬∑ avg=${avgRewardText} ¬∑ deaths last=${lastDeathsText} (avg=${avgDeathsText}) ¬∑ time last=${lastDurationText} (avg=${avgDurationText})`;
      if(rlHint){
        rlHint.textContent = rlHintOverride ?? `RL is learning live ‚Äì episodes: ${stats.episodes}`;
      }
      updateRlLiveMetrics();
    }
    function setupRlControls(){
      RL_CONTROL_BINDINGS.forEach(binding => {
        const input = document.getElementById(binding.id);
        const valueEl = document.getElementById(binding.valueId);
        if(!input || !valueEl) return;
        const applyValue = raw => {
          if(Number.isNaN(raw)) return;
          rlConfig[binding.key] = raw;
          if(input){
            input.value = raw;
          }
          valueEl.textContent = typeof binding.format === 'function' ? binding.format(raw) : raw;
          if(typeof binding.onChange === 'function'){
            binding.onChange(raw);
          }
          updateRlStatus();
        };
        const initial = binding.parser(input.value);
        applyValue(initial);
        input.addEventListener('input', event => {
          const parsed = binding.parser(event.target.value);
          applyValue(parsed);
        });
      });
      rlResetButton?.addEventListener('click', () => {
        rlAgent.resetLearning();
        lastObservedReward = 0;
        rlEpisodeLog.length = 0;
        rlHintOverride = null;
        updateRlStatus();
        updateRlLiveMetrics(0);
        renderRlEpisodeHistory();
        resetRewardImpactStats();
        if(rlHint){
          rlHint.textContent = 'RL reset ‚Äì start a new training run to collect data.';
        }
      });
    }
    function applyRlConfigValues(values){
      if(!values || typeof values !== 'object') return;
      RL_CONTROL_BINDINGS.forEach(binding => {
        if(!(binding.key in values)) return;
        const target = values[binding.key];
        if(typeof target !== 'number' || Number.isNaN(target)) return;
        const input = document.getElementById(binding.id);
        if(!input) return;
        input.value = target;
        input.dispatchEvent(new Event('input', { bubbles: true }));
      });
    }
    function spawnEatEffect(cellX, cellY){
      const originX = cellX * CELL + CELL / 2;
      const originY = cellY * CELL + CELL / 2;
      const count = Math.max(14, Math.floor(CELL / 2));
      for(let i = 0; i < count; i++){
        const angle = Math.random() * Math.PI * 2;
        const speed = (Math.random() * 0.6 + 0.2) * CELL / 8;
        const lifetime = 1.2 + Math.random() * 0.6;
        eatParticles.push({
          x: originX,
          y: originY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: lifetime,
          maxLife: lifetime,
          size: CELL * (0.15 + Math.random() * 0.15),
          hue: 200 + Math.random() * 40
        });
      }
    }
    function updateParticles(delta){
      const decay = delta / 1000;
      eatParticles = eatParticles.filter(p => {
        p.life -= decay;
        if(p.life <= 0) return false;
        p.x += p.vx * (delta / (1000 / 60));
        p.y += p.vy * (delta / (1000 / 60));
        p.vx *= 0.98;
        p.vy *= 0.98;
        return true;
      });
    }
    manualToggleBtn?.addEventListener('click', toggleManualMode);
    safetyNetToggleBtn?.addEventListener('click', () => setSafetyNet(!safetyNetEnabled));
    document.addEventListener('keydown', (event) => {
      if(!manualMode) return;
      const dir = KEY_TO_DIR[event.key.toLowerCase()];
      if(!dir) return;
      setManualDirection(dir.dx, dir.dy);
      event.preventDefault();
    });
    autoRestartToggle?.addEventListener('change', (event) => {
      autoRestartEnabled = !!event.target.checked;
      if(autoRestartEnabled){
        resetRlBatchProgress();
      } else if(rlTrainingEnabled){
        configureRlBatchForSession();
        if(rlBatchActive && rlHint){
          rlHint.textContent = `Batch training ${rlBatchPlannedEpisodes} episodes ‚Äì episode 1 in progress.`;
        }
      }
    });
    updateManualUI();
    updateSafetyNetUI();
    rlToggleBtn?.addEventListener('click', () => {
      rlTrainingEnabled = !rlTrainingEnabled;
      if(rlTrainingEnabled){
        rlHintOverride = null;
        manualMode = false;
        updateManualUI();
        rlPendingChoice = null;
        configureRlBatchForSession();
        rlAgent.resetEpsilon(rlConfig.epsilonStart);
        rlAgent.startEpisode();
        rlEpisodeActive = true;
        resetRewardImpactEpisode();
      } else {
        if(rlEpisodeActive){
          rlAgent.endEpisode();
        }
        rlEpisodeActive = false;
        rlPendingChoice = null;
        rlHintOverride = null;
        cancelScheduledAutoRestart();
        resetRlBatchProgress();
        resetRewardImpactEpisode();
      }
      updateRlToggleUI();
      updateRlStatus();
      if(rlTrainingEnabled && rlBatchActive && rlHint){
        rlHint.textContent = `Batch training ${rlBatchPlannedEpisodes} episodes ‚Äì episode 1 in progress.`;
      }
      updateRewardImpactUI();
    });
    updateRlToggleUI();
    updateRlStatus();
    setupRlControls();
    rlExportButton?.addEventListener('click', () => {
      downloadTrainingSnapshot(createTrainingSnapshot());
      if(rlHint){
        rlHint.textContent = 'Training snapshot downloaded to your device.';
      }
    });
    rlImportButton?.addEventListener('click', () => {
      rlImportFileInput?.click();
    });
    rlImportFileInput?.addEventListener('change', handleTrainingImport);
    /* ===== SIZE CONTROL ===== */
    const sizeSlider = document.getElementById('sizeSlider');
    sizeSlider.addEventListener('input', (e) => {
      const size = parseInt(e.target.value);
      canvas.width = size;
      canvas.height = size;
      CELL = size / COLS;
      if (gameRunning) draw();
    });
    /* ===== GRID CONTROLS ===== */
    const colsSlider = document.getElementById('colsSlider');
    const rowsSlider = document.getElementById('rowsSlider');
    function updateGridSize(newSize) {
      const targetSize = typeof newSize === 'number' ? newSize : parseInt(colsSlider.value);
      if (Number.isNaN(targetSize)) return;
      const targetValue = String(targetSize);
      if (colsSlider.value !== targetValue) colsSlider.value = targetValue;
      if (rowsSlider.value !== targetValue) rowsSlider.value = targetValue;
      if (targetSize !== COLS || targetSize !== ROWS) {
        COLS = targetSize;
        ROWS = targetSize;
        document.getElementById('colsValue').textContent = COLS;
        document.getElementById('rowsValue').textContent = ROWS;
        CELL = canvas.width / COLS;
        // When not loading a preset, update dynamic thresholds based on grid size
        if (!window.loadingPreset) {
          ENDGAME_THRESHOLD = Math.min(40, Math.floor((COLS * ROWS) * 0.2));
          MAX_LOOP_DETECTION = Math.max(8, (COLS + ROWS) / 2 | 0);
          FILL_POCKET_LIMIT = COLS * 4;
          WINDOW_SIZE = Math.max(10, COLS + ROWS);
          LOOP_ESCAPE_LIMIT = Math.max(40, Math.floor((COLS * ROWS) / 2));
          NO_PROGRESS_THRESHOLD = Math.max(30, (COLS * ROWS) / 6);
          COMPACT_MODE_MAX_STEPS = Math.floor((COLS * ROWS) / 2);
          document.getElementById('progThreshValue').textContent = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
          document.getElementById('progThreshSlider').max = Math.max(200, COLS * ROWS);
          document.getElementById('progThreshSlider').value = Math.floor(NO_PROGRESS_THRESHOLD);
          document.getElementById('compactSlider').max = Math.max(300, COLS * ROWS);
          document.getElementById('compactSlider').value = COMPACT_MODE_MAX_STEPS;
          document.getElementById('endgameSlider').max = Math.max(100, Math.floor((COLS * ROWS) * 0.4));
        }
        restartGame();
      }
    }
    function handleGridInput(event) {
      const value = parseInt(event.target.value);
      if (Number.isNaN(value)) return;
      updateGridSize(value);
    }
    colsSlider.addEventListener('input', handleGridInput);
    rowsSlider.addEventListener('input', handleGridInput);
    /* ===== AI PARAMETER CONTROLS ===== */
    const loopThreshSlider = document.getElementById('loopThreshSlider');
    loopThreshSlider.addEventListener('input', (e) => {
      LOOP_STREAK_THRESHOLD = parseInt(e.target.value);
      document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    });
    const progThreshSlider = document.getElementById('progThreshSlider');
    progThreshSlider.addEventListener('input', (e) => {
      NO_PROGRESS_THRESHOLD = parseInt(e.target.value);
      document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    });
    const endgameSlider = document.getElementById('endgameSlider');
    endgameSlider.addEventListener('input', (e) => {
      ENDGAME_THRESHOLD = parseInt(e.target.value);
      document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    });
    const compactSlider = document.getElementById('compactSlider');
    compactSlider.addEventListener('input', (e) => {
      COMPACT_MODE_MAX_STEPS = parseInt(e.target.value);
      document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
    });
    const compactProfileSelect = document.getElementById('compactProfile');
    const compactProfileHint = document.getElementById('compactProfileHint');
    function updateCompactProfile(profileKey){
      if(!COMPACT_MODE_PROFILES[profileKey]) profileKey = 'balanced';
      COMPACT_MODE_PROFILE = profileKey;
      if(compactProfileSelect && compactProfileSelect.value !== profileKey){
        compactProfileSelect.value = profileKey;
      }
      if(compactProfileHint){
        compactProfileHint.textContent = COMPACT_MODE_PROFILES[profileKey].hint;
      }
    }
    compactProfileSelect?.addEventListener('change', (e) => {
      updateCompactProfile(e.target.value);
    });
    function gatherAiSettings(){
      const rlConfigCopy = {};
      Object.keys(rlConfig).forEach(key => {
        const value = rlConfig[key];
        rlConfigCopy[key] = typeof value === 'number' ? Number(value) : value;
      });
      return {
        grid: {
          cols: COLS,
          rows: ROWS,
          canvasSize: canvas.width
        },
        thresholds: {
          loopStreak: LOOP_STREAK_THRESHOLD,
          noProgress: NO_PROGRESS_THRESHOLD,
          endgame: ENDGAME_THRESHOLD,
          compactSteps: COMPACT_MODE_MAX_STEPS
        },
        compactProfile: COMPACT_MODE_PROFILE,
        speed: SPEED,
        safetyNetEnabled,
        autoRestartEnabled,
        rlConfig: rlConfigCopy,
        toggles: {
          rlTrainingEnabled,
          manualMode
        }
      };
    }
    function applyAiSettings(settings){
      if(!settings || typeof settings !== 'object') return;
      const { grid, thresholds, compactProfile, speed, safetyNetEnabled: safetyFlag, autoRestartEnabled: autoFlag, rlConfig: rlValues, toggles } = settings;
      if(grid && typeof grid === 'object'){
        const targetCols = Number.isFinite(grid.cols) ? Math.max(5, Math.round(grid.cols)) : null;
        const targetRows = Number.isFinite(grid.rows) ? Math.max(5, Math.round(grid.rows)) : targetCols;
        const canvasSize = Number.isFinite(grid.canvasSize) ? Math.max(100, Math.round(grid.canvasSize)) : null;
        if(targetCols){
          window.loadingPreset = true;
          colsSlider.value = targetCols;
          rowsSlider.value = targetRows || targetCols;
          updateGridSize(targetCols);
          window.loadingPreset = false;
        }
        if(canvasSize){
          sizeSlider.value = canvasSize;
          canvas.width = canvasSize;
          canvas.height = canvasSize;
          CELL = canvas.width / COLS;
        }
      }
      if(thresholds && typeof thresholds === 'object'){
        if(Number.isFinite(thresholds.loopStreak)){
          LOOP_STREAK_THRESHOLD = Math.max(0, Math.round(thresholds.loopStreak));
          loopThreshSlider.value = LOOP_STREAK_THRESHOLD;
          document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
        }
        if(Number.isFinite(thresholds.noProgress)){
          NO_PROGRESS_THRESHOLD = Math.max(0, Math.round(thresholds.noProgress));
          progThreshSlider.value = NO_PROGRESS_THRESHOLD;
          document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
        }
        if(Number.isFinite(thresholds.endgame)){
          ENDGAME_THRESHOLD = Math.max(0, Math.round(thresholds.endgame));
          endgameSlider.value = ENDGAME_THRESHOLD;
          document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
        }
        if(Number.isFinite(thresholds.compactSteps)){
          COMPACT_MODE_MAX_STEPS = Math.max(0, Math.round(thresholds.compactSteps));
          compactSlider.value = COMPACT_MODE_MAX_STEPS;
          document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
        }
      }
      if(typeof compactProfile === 'string'){
        updateCompactProfile(compactProfile);
      }
      if(Number.isFinite(speed)){
        changeSpeed(Math.max(MIN_SPEED, Math.min(MAX_SPEED, Math.round(speed))));
      }
      if(typeof safetyFlag === 'boolean'){
        setSafetyNet(safetyFlag);
      }
      if(typeof autoFlag === 'boolean' && autoRestartToggle){
        autoRestartEnabled = autoFlag;
        autoRestartToggle.checked = autoFlag;
      }
      if(rlValues && typeof rlValues === 'object'){
        applyRlConfigValues(rlValues);
      }
      if(toggles && typeof toggles === 'object'){
        if(typeof toggles.manualMode === 'boolean'){
          manualMode = toggles.manualMode;
          updateManualUI();
        }
        if(typeof toggles.rlTrainingEnabled === 'boolean'){
          rlTrainingEnabled = toggles.rlTrainingEnabled;
          rlEpisodeActive = false;
          rlHintOverride = null;
          updateRlToggleUI();
        }
      }
      updateSafetyNetUI();
      updateRlStatus();
    }
    function createTrainingSnapshot(){
      const rlSnapshot = rlAgent.exportData();
      return {
        version: 1,
        timestamp: new Date().toISOString(),
        rl: rlSnapshot,
        aiSettings: gatherAiSettings()
      };
    }
    function downloadTrainingSnapshot(snapshot){
      try {
        const serialized = JSON.stringify(snapshot, null, 2);
        const blob = new Blob([serialized], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const filename = `snake-training-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = filename;
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
        URL.revokeObjectURL(url);
      } catch (error){
        console.error('Failed to export training snapshot', error);
        alert('Export failed ‚Äì please try again.');
      }
    }
    async function handleTrainingImport(event){
      const input = event.target;
      const file = input?.files && input.files[0];
      if(!file) return;
      try {
        const text = await file.text();
        const parsed = JSON.parse(text);
        const rlPayload = parsed.rl || parsed.training || parsed;
        const imported = rlAgent.importData(rlPayload);
        if(!imported){
          throw new Error('Invalid RL payload');
        }
        if(parsed.aiSettings){
          applyAiSettings(parsed.aiSettings);
        } else if(parsed.settings){
          applyAiSettings(parsed.settings);
        }
        rlPendingChoice = null;
        rlEpisodeActive = false;
        rlEpisodeLog.length = 0;
        lastObservedReward = 0;
        rlHintOverride = null;
        renderRlEpisodeHistory();
        updateRlLiveMetrics(0);
        updateRlStatus();
        if(rlHint){
          rlHint.textContent = 'RL data loaded ‚Äì ready to continue training.';
        }
        restartGame();
      } catch (error){
        console.error('Failed to import training data', error);
        alert('Import failed ‚Äì please ensure the file was exported from this simulator.');
      } finally {
        if(input){
          input.value = '';
        }
      }
    }
    /* ===== RESTART FUNCTION ===== */
    function spawnFruitForState(state){
      const free=[];
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if(!state.snakeSet.has(`${x},${y}`)) free.push({x,y});
        }
      }
      return free.length ? free[(Math.random()*free.length)|0] : {x:-1,y:-1};
    }
    function createFreshState(){
      const state = {
        snake: [],
        snakeSet: new Set(),
        fruit: {x:-1,y:-1},
        prevFruitDist: Infinity,
        noProgressMoves: 0,
        lastMoves: [],
        windowMoves: [],
        loopDetected: false,
        loopStreak: 0,
        hamMode: false,
        compactMode: false,
        compactModeSteps: 0,
        loopCountAdjust: 0,
        currentStrategy: "Initializing"
      };
      const sx = Math.floor(COLS/2), sy = Math.floor(ROWS/2);
      if (COLS >= 5) {
        state.snake.push({x:sx-2,y:sy},{x:sx-1,y:sy},{x:sx,y:sy});
      } else if (COLS >= 3) {
        state.snake.push({x:sx-1,y:sy},{x:sx,y:sy});
      } else {
        state.snake.push({x:sx,y:sy});
      }
      state.snake.reverse();
      state.snakeSet = new Set(state.snake.map(p => `${p.x},${p.y}`));
      state.fruit = spawnFruitForState(state);
      if(state.fruit && state.fruit.x >= 0){
        state.prevFruitDist = Math.abs(state.snake[0].x - state.fruit.x) + Math.abs(state.snake[0].y - state.fruit.y);
      }
      return state;
    }
    function restartGame() {
      cancelRunTimer();
      const fresh = createFreshState();
      snake = fresh.snake;
      snakeSet = fresh.snakeSet;
      fruit = fresh.fruit;
      prevFruitDist = fresh.prevFruitDist;
      noProgressMoves = fresh.noProgressMoves;
      lastMoves = fresh.lastMoves;
      windowMoves = fresh.windowMoves;
      loopDetected = fresh.loopDetected;
      loopStreak = fresh.loopStreak;
      hamMode = fresh.hamMode;
      compactMode = fresh.compactMode;
      compactModeSteps = fresh.compactModeSteps;
      loopCountAdjust = fresh.loopCountAdjust;
      currentStrategy = fresh.currentStrategy;
      compactModeJustActivated = false;
      endgamePlanThisMove = false;
      persistentLoopCounter = 0;
      if(manualMode){
        setInitialManualDirection();
        currentStrategy = 'Manual control';
      }
      eatParticles = [];
      lastRender = performance.now();
      HAM = buildHamilton();
      if (loopHandle) clearInterval(loopHandle);
      gameRunning = true;
      runTimeoutMs = computeRunTimeout();
      resetRunTimeoutDeadline();
      if(rlTrainingEnabled){
        if(rlEpisodeActive){
          rlAgent.endEpisode();
        }
        resetRewardImpactEpisode();
        rlAgent.startEpisode();
        rlEpisodeActive = true;
        updateRewardImpactUI();
      } else {
        rlEpisodeActive = false;
      }
      rlPendingChoice = null;
      updateRlStatus();
      draw();
      loopHandle = setInterval(update, SPEED);
      startRunTimer();
      updateCompletedRoundsDisplay();
    }
    document.getElementById('restartBtn').addEventListener('click', restartGame);
    /* ===== HAMILTON-SLINGA ===== */
    function buildHamilton(){
      const path=[]; let dir=1;
      for(let y=0; y<ROWS; y++){
        if(dir>0){
          for(let x=0; x<COLS; x++) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        } else {
          for(let x=COLS-1; x>=0; x--) if(!snakeSet.has(`${x},${y}`)) path.push({x,y});
        }
        dir = -dir;
      }
      return path;
    }
    let HAM = buildHamilton();
    const idxOf = p => HAM.findIndex(q=>q.x===p.x&&q.y===p.y);
    const hamNext = p => {const i=idxOf(p); return i<0?null:HAM[(i+1)%HAM.length];};
    /* ===== HELPER FUNCTIONS ===== */
    function spawnFruit(){
      const free=[]; for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)
        if(!snakeSet.has(`${x},${y}`)) free.push({x,y});
      return free.length ? free[(Math.random()*free.length)|0] : {x:-1,y:-1};
    }
    function isFruitAccessible(head){
      if(!fruit || fruit.x<0) return false;
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTail=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTail) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    function bfsWithAlternatives(sx,sy,gx,gy,allowTail,preferRandom=false){
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const prev=Array.from({length:ROWS},()=>Array(COLS).fill(null));
      let Q=[{x:sx,y:sy}]; vis[sy][sx]=true;
      while(Q.length){
        if(preferRandom) Q.sort(()=>Math.random()-0.5);
        const {x,y}=Q.shift();
        if(x===gx&&y===gy) break;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=allowTail&&snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; prev[ny][nx]={x,y}; Q.push({x:nx,y:ny});
        }
      }
      if(!vis[gy][gx]) return null;
      const path=[]; for(let cx=gx,cy=gy;!(cx===sx&&cy===sy);){
        path.unshift({x:cx,y:cy}); const p=prev[cy][cx]; if(!p) return null; cx=p.x; cy=p.y;
      }
      return path;
    }
    function canReachTailFrom(head,body){
      if(!body || body.length<2) return true;
      const tail=body[body.length-1];
      if(head.x===tail.x&&head.y===tail.y) return true;
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const Q=[{x:head.x,y:head.y}]; vis[head.y][head.x]=true;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===tail.x&&y===tail.y) return true;
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          const key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          if(blocked.has(key)&&!(nx===tail.x&&ny===tail.y)) continue;
          vis[ny][nx]=true; Q.push({x:nx,y:ny});
        }
      }
      return false;
    }
    const floodSize=(sx,sy,body)=>{
      const blocked=new Set(body.map(p=>`${p.x},${p.y}`));
      const startKey=`${sx},${sy}`;
      if(sx<0||sx>=COLS||sy<0||sy>=ROWS||blocked.has(startKey)) return 0;
      const vis=new Set([startKey]); const Q=[{x:sx,y:sy}]; let cnt=1;
      while(Q.length){
        const {x,y}=Q.shift();
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy, key=`${nx},${ny}`;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis.has(key)||blocked.has(key)) continue;
          vis.add(key); cnt++; Q.push({x:nx,y:ny});
        }
      }
      return cnt;
    };
    function getDistancesFromTail(){
      const dmap=Array.from({length:ROWS},()=>Array(COLS).fill(-1));
      if(snake.length<2) return dmap;
      const tail=snake[snake.length-1];
      const Q=[{x:tail.x,y:tail.y,dist:0}]; dmap[tail.y][tail.x]=0;
      const blocked=new Set(snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
      let idx=0; while(idx<Q.length){
        const {x,y,dist}=Q[idx++];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          if(dmap[ny][nx]>=0) continue;
          if(blocked.has(`${nx},${ny}`)) continue;
          dmap[ny][nx]=dist+1; Q.push({x:nx,y:ny,dist:dist+1});
        }
      }
      return dmap;
    };
    function detectLoop(){
      if(lastMoves.length<MAX_LOOP_DETECTION) return false;
      const recent=lastMoves.slice(-MAX_LOOP_DETECTION);
      const unique=new Set(recent.map(p=>`${p.x},${p.y}`)).size;
      return unique<=MAX_LOOP_DETECTION/2;
    }
    function calculateZigZagPath(){
      const head=snake[0];
      let lastDx=0,lastDy=0;
      if(lastMoves.length){
        const ph=lastMoves[lastMoves.length-1]; lastDx=head.x-ph.x; lastDy=head.y-ph.y;
      }
      const moves=[];
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`, isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const ate=fruit&&fruit.x>=0&&nx===fruit.x&&ny===fruit.y;
        const sim=ate?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        let prio=0;
        if((d.dx&&lastDy)||(d.dy&&lastDx)) prio=1;
        else if(d.dx===lastDx&&d.dy===lastDy) prio=2;
        else if(d.dx===-lastDx&&d.dy===-lastDy) prio=-1;
        moves.push({x:nx,y:ny,priority:prio});
      }
      if(!moves.length) return null;
      moves.sort((a,b)=>b.priority-a.priority);
      return {x:moves[0].x,y:moves[0].y};
    }
    function getBackToHamilton(head){
      const currentIdx=idxOf(head);
      if(currentIdx!==-1) return null;
      let best=null, minDist=Infinity;
      for(const d of DIRS){
        const nx=head.x+d.dx, ny=head.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const key=`${nx},${ny}`;
        const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
        if(snakeSet.has(key)&&!isTailStep) continue;
        const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
        if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
        const idx=idxOf({x:nx,y:ny});
        if(idx!==-1){
          const dist=Math.min(Math.abs(idx-currentIdx),HAM.length-Math.abs(idx-currentIdx));
          if(dist<minDist){minDist=dist; best={x:nx,y:ny};}
        }
      }
      return best;
    }
    function isFruitInPocket(){
      if(!fruit||fruit.x<0) return false;
      let blocked=0;
      for(const d of DIRS){
        const nx=fruit.x+d.dx, ny=fruit.y+d.dy;
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) blocked++;
        else if(snakeSet.has(`${nx},${ny}`)) blocked++;
      }
      const steps=getMinStepsToFruit();
      return blocked>=3 || (blocked>=2 && steps>(COLS+ROWS)/2);
    }
    function shouldEnterCompactMode(context){
      const profile = COMPACT_MODE_PROFILES[COMPACT_MODE_PROFILE] || COMPACT_MODE_PROFILES.balanced;
      if(context.freeCells <= profile.minFreeCells) return false;
      const loopReady = profile.allowLoop && context.loopDetected && context.loopStreak >= profile.minLoopStreak;
      if(profile.allowPocket && context.inPocket){
        if(profile.requirePocketWithLoop && !loopReady) return false;
        return true;
      }
      if(loopReady && !profile.requirePocketWithLoop){
        return true;
      }
      if(profile.allowCrowding && !context.fruitAcc){
        return true;
      }
      return false;
    }
    function fillSmallestPocket(){
      const head=snake[0];
      const freeCells=[], vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const blocked=new Set(snake.map(p=>`${p.x},${p.y}`));
      for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
        if(vis[y][x]||blocked.has(`${x},${y}`)) continue;
        const pocket=[], Q=[{x,y}]; vis[y][x]=true;
        while(Q.length){
          const {x:cx,y:cy}=Q.shift(); pocket.push({x:cx,y:cy});
          for(const d of DIRS){
            const nx=cx+d.dx, ny=cy+d.dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]||blocked.has(`${nx},${ny}`)) continue;
            vis[ny][nx]=true; Q.push({x:nx,y:ny});
          }
        }
        freeCells.push(pocket);
      }
      freeCells.sort((a,b)=>a.length-b.length);
      for(const pocket of freeCells){
        if(!pocket.length) continue;
        const target=pocket[0];
        const path=bfsWithAlternatives(head.x,head.y,target.x,target.y,true,true);
        if(path&&path.length){
          const nxt=path[0];
          const sim=[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)) return nxt;
        }
      }
      return null;
    }
    function getMinStepsToFruit(){
      if(!fruit||fruit.x<0) return Infinity;
      const head=snake[0];
      const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
      const dist=Array.from({length:ROWS},()=>Array(COLS).fill(Infinity));
      const Q=[{x:head.x,y:head.y}];
      vis[head.y][head.x]=true; dist[head.y][head.x]=0;
      while(Q.length){
        const {x,y}=Q.shift();
        if(x===fruit.x&&y===fruit.y) return dist[y][x];
        for(const d of DIRS){
          const nx=x+d.dx, ny=y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS||vis[ny][nx]) continue;
          const key=`${nx},${ny}`;
          const isTailStep=snake.length>1&&nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(key)&&!isTailStep) continue;
          vis[ny][nx]=true; dist[ny][nx]=dist[y][x]+1; Q.push({x:nx,y:ny});
        }
      }
      return Infinity;
    }
    /* ===== GET NEXT ===== */
    function getNext(){
      HAM = buildHamilton();
      const head=snake[0];
      const rlSafeMoves = rlTrainingEnabled ? getSafeMovesForRL() : null;
      endgamePlanThisMove = false;
      compactModeJustActivated = false;
      windowMoves.push(`${head.x},${head.y}`);
      if(windowMoves.length>WINDOW_SIZE) windowMoves.shift();
      lastMoves.push({x:head.x,y:head.y});
      if(lastMoves.length>MAX_LOOP_DETECTION) lastMoves.shift();
      const freeCells=COLS*ROWS - snake.length;
      const isEndgame = freeCells <= (ENDGAME_THRESHOLD + loopCountAdjust);
      if(safetyNetEnabled){
        if(!hamMode && freeCells > (ENDGAME_THRESHOLD + loopCountAdjust)){
          const uniq=new Set(windowMoves).size;
          if(uniq < WINDOW_SIZE/2){
            hamMode = true; loopStreak = 0; noProgressMoves = 0;
            currentStrategy = "Forcing Hamilton (Stagnation)";
            loopCountAdjust++;
          }
        }
        if(freeCells <= 1){
          const nxt = hamNext(head);
          if(nxt){
            const isTail=snake.length>1 && nxt.x===snake[snake.length-1].x && nxt.y===snake[snake.length-1].y;
            if(!snakeSet.has(`${nxt.x},${nxt.y}`) || isTail){
              currentStrategy = "Final Hamilton";
              endgamePlanThisMove = true;
              return nxt;
            }
          }
        }
        if(isEndgame){
          const back=getBackToHamilton(head);
          if(back){ currentStrategy="Returning to Hamilton"; endgamePlanThisMove = true; return back; }
          const nxt=hamNext(head);
          if(nxt){
            const key=`${nxt.x},${nxt.y}`;
            const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
            const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
            if((!snakeSet.has(key)||isTailStep) && canReachTailFrom(nxt,sim)){
              currentStrategy="Endgame Hamilton"; endgamePlanThisMove = true; return nxt;
            }
          }
        }
        if(fruit && fruit.x >= 0){
          const d = Math.abs(head.x - fruit.x) + Math.abs(head.y - fruit.y);
          if(d < prevFruitDist){ prevFruitDist = d; noProgressMoves = 0; }
          else noProgressMoves++;
        } else {
          prevFruitDist = Infinity; noProgressMoves = 0;
        }
        if(!hamMode && noProgressMoves >= NO_PROGRESS_THRESHOLD){
          hamMode = true; loopStreak = 0; noProgressMoves = 0;
          currentStrategy = "Forcing Hamilton (No progress)";
          loopCountAdjust++;
        }
        if(hamMode){
          const nxt = hamNext(head);
          if(nxt){
            const key=`${nxt.x},${nxt.y}`;
            const isTailStep=snake.length>1&&nxt.x===snake[snake.length-1].x&&nxt.y===snake[snake.length-1].y;
            const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
            if((!snakeSet.has(key)||isTailStep) && canReachTailFrom(nxt,sim)){
              currentStrategy = "Hamilton cycle";
              if(isEndgame) endgamePlanThisMove = true;
              return nxt;
            }
          }
          hamMode = false;
        }
        loopDetected = detectLoop();
        loopStreak = loopDetected ? loopStreak + 1 : 0;
        if(loopDetected && !hamMode){
          hamMode = true;
          loopStreak = 0;
          currentStrategy = "Forcing Hamilton (Immediate Loop)";
          loopCountAdjust++;
        }
        if(loopDetected && snake.length >= 2){
          if(freeCells <= FILL_POCKET_LIMIT){
            const fillMove = fillSmallestPocket();
            if(fillMove){ currentStrategy="Filling smallest pocket"; return fillMove; }
          }
          const dmap = getDistancesFromTail();
          let best=null,bestDist=-1;
          for(const d of DIRS){
            const nx=head.x+d.dx, ny=head.y+d.dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
            const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
            if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
            const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
            if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
            const dist=dmap[ny][nx];
            if(dist>bestDist){bestDist=dist; best={x:nx,y:ny};}
          }
          if(best){ currentStrategy="Loop break (Longest)"; return best; }
        }
        if(rlTrainingEnabled && !hamMode){
          if(!rlEpisodeActive){
            resetRewardImpactEpisode();
            rlAgent.startEpisode();
            rlEpisodeActive = true;
            updateRewardImpactUI();
          }
          if(rlSafeMoves && rlSafeMoves.length){
            const rlState = buildRlObservation(rlSafeMoves);
            const decision = rlAgent.decide(rlState, rlSafeMoves);
            if(decision){
              const selected = rlSafeMoves.find(move => move.dirIndex === decision.actionIdx);
              if(selected){
                rlPendingChoice = { stateKey: decision.stateKey, actionIdx: decision.actionIdx };
                currentStrategy = 'RL policy';
                return {x: selected.x, y: selected.y};
              }
            }
          }
        }
        const fruitAcc = isFruitAccessible(head);
        if(fruitAcc && freeCells>15){
          let choices=[],minD=Infinity;
          for(const d of DIRS){
            const nx=head.x+d.dx, ny=head.y+d.dy;
            if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
            const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
            if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
            const nd=Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y);
            if(nd>minD) continue;
            const sim=(nx===fruit.x&&ny===fruit.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
            if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
            if(nd<minD){minD=nd; choices=[{x:nx,y:ny}];}
            else if(nd===minD){choices.push({x:nx,y:ny});}
          }
          if(choices.length){ currentStrategy="Greedy to fruit"; return choices[(Math.random()*choices.length)|0]; }
        }
        const inPocket = isFruitInPocket();
        if(!compactMode && shouldEnterCompactMode({
          inPocket,
          loopDetected,
          loopStreak,
          fruitAcc,
          freeCells
        })){
          compactMode = true; compactModeSteps = 0; compactModeJustActivated = true;
        }
        if(compactMode){
          if(compactModeSteps >= COMPACT_MODE_MAX_STEPS){
            compactMode = false; compactModeSteps = 0;
          } else {
            const zig = calculateZigZagPath();
            if(zig){ compactModeSteps++; currentStrategy="Compact zig-zag"; return zig; }
            else{ compactMode = false; }
          }
        }
        if(fruitAcc && freeCells>1){
          const path=bfsWithAlternatives(head.x,head.y,fruit.x,fruit.y,false,loopDetected);
          if(path && path.length){
            const nxt=path[0];
            const sim=(nxt.x===fruit.x&&nxt.y===fruit.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
            if(canReachTailFrom(nxt,sim)){ currentStrategy="BFS to fruit"; return nxt; }
          }
        }
        let bestScore=-Infinity,bestMoves=[];
        const tailPos=snake.length>1?snake[snake.length-1]:null;
        const randomFactor=loopDetected?Math.random()*5:0;
        const avoidFactor=loopDetected?0.5:1;
        for(const d of DIRS){
          const nx=head.x+d.dx, ny=head.y+d.dy;
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const isTailStep=nx===snake[snake.length-1].x&&ny===snake[snake.length-1].y;
          if(snakeSet.has(`${nx},${ny}`)&&!isTailStep) continue;
          const sim=(nx===fruit?.x&&ny===fruit?.y)?[{x:nx,y:ny},...snake]:[{x:nx,y:ny},...snake.slice(0,-1)];
          if(!canReachTailFrom({x:nx,y:ny},sim)) continue;
          const freeAfter=floodSize(nx,ny,sim);
          if(freeAfter<COLS*ROWS-sim.length) continue;
          let score=0;
          if(fruit&&fruit.x>=0&&freeCells>Math.max(6, COLS-2)){
            score+=(COLS+ROWS-(Math.abs(nx-fruit.x)+Math.abs(ny-fruit.y)))*2*avoidFactor;
          }
          if(isEndgame && tailPos && nx===tailPos.x && ny===tailPos.y) score+=10000;
          score+=Math.min(nx,ny,COLS-1-nx,ROWS-1-ny);
          score+=randomFactor;
          score+=freeAfter*2;
          const moveData = {
            x: nx,
            y: ny,
            dx: d.dx,
            dy: d.dy,
            baseScore: score,
            willEat: fruit && fruit.x === nx && fruit.y === ny,
            freeAfter
          };
          if(score>bestScore){ bestScore=score; bestMoves=[moveData]; }
          else if(score===bestScore){ bestMoves.push(moveData); }
        }
        if(bestMoves.length){
          currentStrategy="Heuristic";
          const rlChoice = rlAgent.chooseMove(head, bestMoves, {isEndgame});
          return rlChoice || bestMoves[(Math.random()*bestMoves.length)|0];
        }
        const tail=snake.length>1?snake[snake.length-1]:head;
        const path=bfsWithAlternatives(head.x,head.y,tail.x,tail.y,true,loopDetected);
        if(path && path.length){
          const nxt=path[0];
          const sim=(nxt.x===fruit?.x&&nxt.y===fruit?.y)?[{x:nxt.x,y:nxt.y},...snake]:[{x:nxt.x,y:nxt.y},...snake.slice(0,-1)];
          if(canReachTailFrom(nxt,sim)){ currentStrategy="BFS to tail"; return nxt; }
        }
        currentStrategy="No safe move!";
        return null;
      }
      loopDetected = false;
      loopStreak = 0;
      compactMode = false;
      compactModeSteps = 0;
      hamMode = false;
      const rlMoves = rlTrainingEnabled ? getAllMovesForRL() : [];
      if(rlTrainingEnabled){
        if(!rlEpisodeActive){
          resetRewardImpactEpisode();
          rlAgent.startEpisode();
          rlEpisodeActive = true;
          updateRewardImpactUI();
        }
        if(rlMoves && rlMoves.length){
          const rlState = buildRlObservation(rlSafeMoves || []);
          const decision = rlAgent.decide(rlState, rlMoves);
          if(decision){
            const selected = pickViableMove({ dirIndex: decision.actionIdx }, rlMoves);
            if(selected){
              rlPendingChoice = { stateKey: decision.stateKey, actionIdx: selected.dirIndex };
              currentStrategy = 'RL policy';
              return {x: selected.x, y: selected.y};
            }
          }
        }
      }
      const unsafeMove = pickUnsafeMove();
      if(unsafeMove){
        currentStrategy = fruit && fruit.x >= 0 ? 'Unsafe chase' : 'Unsafe roam';
        return unsafeMove;
      }
      if(rlMoves && rlMoves.length){
        const randomPick = pickViableMove(null, rlMoves);
        currentStrategy = 'Unsafe random';
        if(randomPick){
          return {x: randomPick.x, y: randomPick.y};
        }
      }
      currentStrategy = 'No safe move!';
      return null;
    }
    /* ===== RENDER ===== */
    function draw(){
      const now = performance.now();
      updateParticles(now - lastRender);
      lastRender = now;
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#1a1a2e');
      gradient.addColorStop(1, '#0f0f23');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      for(let i = 0; i <= COLS; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL, 0);
        ctx.lineTo(i * CELL, canvas.height);
        ctx.stroke();
      }
      for(let i = 0; i <= ROWS; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * CELL);
        ctx.lineTo(canvas.width, i * CELL);
        ctx.stroke();
      }
      if(fruit && fruit.x >= 0){
        const centerX = fruit.x * CELL + CELL / 2;
        const centerY = fruit.y * CELL + CELL / 2;
        const appleRadius = CELL / 2.6;
        const glowGradient = ctx.createRadialGradient(
          centerX, centerY, 0,
          centerX, centerY, CELL
        );
        glowGradient.addColorStop(0, 'rgba(220, 38, 38, 0.5)');
        glowGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGradient;
        ctx.fillRect(fruit.x * CELL, fruit.y * CELL, CELL, CELL);
        ctx.beginPath();
        ctx.arc(centerX, centerY, appleRadius, 0, 2 * Math.PI);
        ctx.fillStyle = '#d62828';
        ctx.fill();
        ctx.lineWidth = Math.max(2, CELL / 8);
        ctx.strokeStyle = '#111';
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(centerX - appleRadius / 2.2, centerY - appleRadius / 2.2, appleRadius / 4, 0, 2 * Math.PI);
        ctx.fill();
      }
      eatParticles.forEach(p => {
        const alpha = Math.max(0, p.life / p.maxLife);
        const flare = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
        flare.addColorStop(0, `hsla(${p.hue}, 90%, 80%, ${alpha * 0.85})`);
        flare.addColorStop(0.6, `hsla(${p.hue}, 90%, 65%, ${alpha * 0.45})`);
        flare.addColorStop(1, `hsla(${p.hue}, 90%, 40%, 0)`);
        ctx.fillStyle = flare;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      const headColor = hamMode ? '#4ade80' : compactMode ? '#f97316' : loopDetected ? '#fbbf24' : '#667eea';
      snake.forEach((p, i) => {
        const isHead = i === 0;
        const size = CELL * 0.95;
        const offset = (CELL - size) / 2;
        const x = p.x * CELL + offset;
        const y = p.y * CELL + offset;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(x + 2, y + 2, size, size);
        const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
        if(isHead) {
          gradient.addColorStop(0, headColor);
          gradient.addColorStop(1, isHead && hamMode ? '#22c55e' : isHead && compactMode ? '#ea580c' : isHead && loopDetected ? '#f59e0b' : '#764ba2');
        } else {
          const t = i / (snake.length - 1);
          const r = Math.round(102 + (138 - 102) * t);
          const g = Math.round(126 + (75 - 126) * t);
          const b = Math.round(234 + (162 - 234) * t);
          gradient.addColorStop(0, `rgb(${r}, ${g}, ${b})`);
          gradient.addColorStop(1, `rgb(${r - 30}, ${g - 30}, ${b - 30})`);
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, size, size);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(x, y, size, size/3);
        if(isHead) {
          ctx.fillStyle = '#fff';
          let eyeX1, eyeY1, eyeX2, eyeY2;
          if(snake.length > 1){
            const dx = p.x - snake[1].x;
            const dy = p.y - snake[1].y;
            if(dx === 1) {
              eyeX1 = x + size - size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size - size/4;
            } else if(dx === -1) {
              eyeX1 = x + size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size/4;
              eyeY2 = y + size - size/4;
            } else if(dy === 1) {
              eyeX1 = x + size/4;
              eyeY1 = y + size - size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size - size/4;
            } else {
              eyeX1 = x + size/4;
              eyeY1 = y + size/4;
              eyeX2 = x + size - size/4;
              eyeY2 = y + size/4;
            }
            ctx.beginPath(); ctx.arc(eyeX1, eyeY1, size/10, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX2, eyeY2, size/10, 0, 2*Math.PI); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(eyeX1, eyeY1, size/20, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX2, eyeY2, size/20, 0, 2*Math.PI); ctx.fill();
          }
        }
      });
      document.getElementById('strategyStatus').textContent = `Strategy: ${currentStrategy}`;
      document.getElementById('strategyExplanation').textContent = getStrategyExplanation(currentStrategy);
      document.getElementById('hamStatus').textContent = hamMode ? "Following the Hamilton safety cycle." : "";
      document.getElementById('loopStatus').textContent = loopDetected ? `Detected a loop ‚Äì streak ${loopStreak}.` : "";
      document.getElementById('compactStatus').textContent = compactMode ? "Compressing the body to clear space." : "";
      document.getElementById('compactStepStatus').textContent = compactMode ? `Compact path step ${compactModeSteps} of ${COMPACT_MODE_MAX_STEPS}.` : "";
      const freeCellsCount = COLS * ROWS - snake.length;
      document.getElementById('snakeLength').textContent = snake.length;
      document.getElementById('freeCells').textContent = freeCellsCount;
      document.getElementById('progress').textContent = ((snake.length / (COLS * ROWS)) * 100).toFixed(1) + '%';
      updateRlStatus();
    }
    function showOverlay(title, subtitle, color = '#ef4444'){
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = color;
      ctx.font = 'bold 32px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(title, canvas.width / 2, canvas.height / 2);
      if(subtitle){
        ctx.fillStyle = '#fff';
        ctx.font = '20px Inter, sans-serif';
        ctx.fillText(subtitle, canvas.width / 2, canvas.height / 2 + 40);
      }
    }
    function scheduleAutoRestart(delay = 600, force = false){
      if(!rlTrainingEnabled) return;
      if(!force && !autoRestartEnabled) return;
      cancelScheduledAutoRestart();
      autoRestartTimer = setTimeout(() => {
        autoRestartTimer = null;
        if(!gameRunning){
          restartGame();
        }
      }, delay);
    }
    function handleSnakeDeath({ title = 'Crash! üí•', subtitle, color = '#ef4444', penalty = rlConfig.deathPenalty, outcome = 'loss' } = {}){
      if(rlTrainingEnabled){
        rlAgent.registerTerminal(outcome);
      }
      const penaltyValue = Number.isFinite(penalty) ? penalty : rlConfig.deathPenalty;
      const penaltyComponent = (penaltyValue === rlConfig.deadEndPenalty || outcome === 'timeout')
        ? 'deadEndPenalty'
        : 'deathPenalty';
      const penaltyBreakdown = rlTrainingEnabled
        ? [{ id: penaltyComponent, amount: penaltyValue }]
        : null;
      applyRlUpdate(penaltyValue, true, { skipScaling: true, breakdown: penaltyBreakdown });
      clearInterval(loopHandle);
      gameRunning = false;
      finishRun(false);
      draw();
      showOverlay(title, subtitle ?? `Final length: ${snake.length}`, color);
      scheduleAutoRestart();
    }
    /* ===== UPDATE ===== */
    function update(){
      if(!snake.length){ clearInterval(loopHandle); gameRunning = false; finishRun(false); return; }
      if(runTimeoutDeadline !== null && performance.now() > runTimeoutDeadline){
        const timeoutPenalty = Number.isFinite(rlConfig.deadEndPenalty) ? rlConfig.deadEndPenalty : rlConfig.deathPenalty;
        handleSnakeDeath({
          title: 'Timeout ‚è±Ô∏è',
          subtitle: `Restart efter ${formatTime(runTimeoutMs)} utan framsteg.`,
          color: '#38bdf8',
          penalty: timeoutPenalty,
          outcome: 'timeout'
        });
        return;
      }
      let stepReward = rlConfig.stepPenalty;
      let rewardBreakdown = rlTrainingEnabled ? [{ id: 'stepPenalty', amount: rlConfig.stepPenalty }] : null;
      let stepDone = false;
      const nxt = manualMode ? getManualNext() : getNext();
      if(!nxt){
        handleSnakeDeath({ title: 'Trapped! ‚ùå', subtitle: `Final length: ${snake.length}`, color: '#f97316' });
        return;
      }
      if(nxt.x < 0 || nxt.x >= COLS || nxt.y < 0 || nxt.y >= ROWS){
        handleSnakeDeath({ title: 'Wall crash! üß±', subtitle: `Final length: ${snake.length}` });
        return;
      }
      if(loopDetected){
        persistentLoopCounter++;
      } else {
        persistentLoopCounter = 0;
      }
      if(rlTrainingEnabled && persistentLoopCounter >= LOOP_ESCAPE_LIMIT){
        const loopPenalty = typeof rlConfig.loopPenalty === 'number' ? rlConfig.loopPenalty : rlConfig.stepPenalty;
        const loopBreakdown = rlTrainingEnabled ? [{ id: 'loopPenalty', amount: loopPenalty }] : null;
        applyRlUpdate(loopPenalty, true, { breakdown: loopBreakdown });
        rlAgent.registerTerminal('stalled');
        clearInterval(loopHandle);
        gameRunning = false;
        finishRun(false);
        draw();
        showOverlay('Loop limit reached ‚Äì advancing episode', '', '#fbbf24');
        scheduleAutoRestart(450, true);
        persistentLoopCounter = 0;
        return;
      }
      if(rlTrainingEnabled){
        if(endgamePlanThisMove){
          stepReward += rlConfig.endgamePlanReward;
          rewardBreakdown?.push({ id: 'endgamePlanReward', amount: rlConfig.endgamePlanReward });
        }
        if(compactModeJustActivated){
          stepReward += rlConfig.compactModeReward;
          rewardBreakdown?.push({ id: 'compactModeReward', amount: rlConfig.compactModeReward });
        } else if(compactMode && currentStrategy === 'Compact zig-zag'){
          const compactBonus = rlConfig.compactModeReward * 0.5;
          stepReward += compactBonus;
          rewardBreakdown?.push({ id: 'compactModeReward', amount: compactBonus });
        }
      }
      compactModeJustActivated = false;
      const ate = fruit && fruit.x >= 0 && nxt.x === fruit.x && nxt.y === fruit.y;
      const nextKey = `${nxt.x},${nxt.y}`;
      const tail = snake[snake.length - 1];
      const isTailStep = snake.length > 1 && nxt.x === tail.x && nxt.y === tail.y;
      if(snakeSet.has(nextKey) && !(isTailStep && !ate)){
        handleSnakeDeath({ title: 'Crash! üí•', subtitle: `Final length: ${snake.length}` });
        return;
      }
      const atePosition = ate ? {x: fruit.x, y: fruit.y} : null;
      if(!ate){
        const removed = snake.pop();
        snakeSet.delete(`${removed.x},${removed.y}`);
      }
      snake.unshift({x: nxt.x, y: nxt.y});
      snakeSet.add(`${nxt.x},${nxt.y}`);
      if(ate){
        loopCountAdjust = 0;
        stepReward = rlConfig.fruitReward;
        rewardBreakdown = rlTrainingEnabled ? [{ id: 'fruitReward', amount: rlConfig.fruitReward }] : rewardBreakdown;
        if(snake.length === COLS * ROWS){
          if(rlTrainingEnabled){
            rlAgent.registerTerminal('win');
          }
          fruit = {x: -1, y: -1};
          stepReward = rlConfig.winBonus;
          rewardBreakdown = rlTrainingEnabled ? [{ id: 'winBonus', amount: rlConfig.winBonus }] : rewardBreakdown;
          stepDone = true;
          applyRlUpdate(stepReward, stepDone, { breakdown: rewardBreakdown });
          draw();
          clearInterval(loopHandle);
          gameRunning = false;
          finishRun(true);
          completedRounds++;
          updateCompletedRoundsDisplay();
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          gradient.addColorStop(0, '#667eea');
          gradient.addColorStop(0.5, '#f093fb');
          gradient.addColorStop(1, '#764ba2');
          ctx.fillStyle = gradient;
          ctx.font = 'bold 48px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText("PERFECT! üèÜ", canvas.width/2, canvas.height/2);
          ctx.fillStyle = '#fff';
          ctx.font = '24px Inter, sans-serif';
          ctx.fillText("You filled the entire board!", canvas.width/2, canvas.height/2 + 50);
          scheduleAutoRestart();
          return;
        } else {
          fruit = spawnFruit();
          prevFruitDist = (fruit.x >= 0) ? Math.abs(snake[0].x - fruit.x) + Math.abs(snake[0].y - fruit.y) : Infinity;
          noProgressMoves = 0;
        }
        if(atePosition){
          spawnEatEffect(atePosition.x, atePosition.y);
        }
        resetRunTimeoutDeadline();
      }
      if(rlTrainingEnabled && !stepDone){
        const trapPenalty = typeof rlConfig.deadEndPenalty === 'number' ? rlConfig.deadEndPenalty : 0;
        if(trapPenalty){
          const upcomingSafeMoves = getSafeMovesForRL();
          const freeCellsRemaining = COLS * ROWS - snake.length;
          if(Array.isArray(upcomingSafeMoves) && freeCellsRemaining > 0){
            if(upcomingSafeMoves.length === 0){
              stepReward += trapPenalty;
              rewardBreakdown?.push({ id: 'deadEndPenalty', amount: trapPenalty });
            } else if(upcomingSafeMoves.length === 1 && freeCellsRemaining > 2){
              const onlyMove = upcomingSafeMoves[0];
              const upcomingTail = snake.length > 1 ? snake[snake.length - 1] : null;
              const isTailEscape = upcomingTail && !onlyMove.ate && onlyMove.x === upcomingTail.x && onlyMove.y === upcomingTail.y;
              if(!isTailEscape){
                const partialPenalty = trapPenalty * 0.5;
                stepReward += partialPenalty;
                rewardBreakdown?.push({ id: 'deadEndPenalty', amount: partialPenalty });
              }
            }
          }
        }
      }
      applyRlUpdate(stepReward, stepDone, { breakdown: rewardBreakdown });
      draw();
    }
    /* ===== SPEED CONTROLS & STARTUP ===== */
    document.getElementById('slowerBtn').onclick = () => changeSpeed(SPEED + SPEED_STEP);
    document.getElementById('fasterBtn').onclick = () => changeSpeed(SPEED - SPEED_STEP);
    function changeSpeed(v){
      v = Math.max(MIN_SPEED, Math.min(MAX_SPEED, v));
      if(v !== SPEED){
        SPEED = v;
        document.getElementById('speedDisplay').textContent = `Speed: ${SPEED}ms`;
        if(gameRunning) {
          clearInterval(loopHandle);
          loopHandle = setInterval(update, SPEED);
        }
      }
    }
    async function trainSnakeAgent(episodes = 10, options = {}){
      if(typeof episodes !== 'number' || episodes <= 0) throw new Error('Episodes must be a positive number.');
      return rlAgent.startTraining(episodes, options);
    }
    window.trainSnakeAgent = trainSnakeAgent;
    window.rlAgent = rlAgent;
    /* ===== PRESET LOADING ===== */
    const presetButtons = document.querySelectorAll('.load-preset');
    presetButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        // flag to prevent dynamic recalculation when grid size changes
        window.loadingPreset = true;
        if (preset === 'small') {
          colsSlider.value = 10; rowsSlider.value = 10; updateGridSize();
          LOOP_STREAK_THRESHOLD = 1; loopThreshSlider.value = 1; document.getElementById('loopThreshValue').textContent = 1;
          NO_PROGRESS_THRESHOLD = 30; progThreshSlider.value = 30; document.getElementById('progThreshValue').textContent = 30;
          ENDGAME_THRESHOLD = 5; endgameSlider.value = 5; document.getElementById('endgameValue').textContent = 5;
          COMPACT_MODE_MAX_STEPS = 50; compactSlider.value = 50; document.getElementById('compactValue').textContent = 50;
          updateCompactProfile('cautious');
          changeSpeed(120);
        } else if (preset === 'balanced') {
          colsSlider.value = 20; rowsSlider.value = 20; updateGridSize();
          LOOP_STREAK_THRESHOLD = 3; loopThreshSlider.value = 3; document.getElementById('loopThreshValue').textContent = 3;
          NO_PROGRESS_THRESHOLD = 70; progThreshSlider.value = 70; document.getElementById('progThreshValue').textContent = 70;
          ENDGAME_THRESHOLD = 40; endgameSlider.value = 40; document.getElementById('endgameValue').textContent = 40;
          COMPACT_MODE_MAX_STEPS = 200; compactSlider.value = 200; document.getElementById('compactValue').textContent = 200;
          updateCompactProfile('balanced');
          changeSpeed(80);
        } else if (preset === 'ultra') {
          colsSlider.value = 30; rowsSlider.value = 30; updateGridSize();
          LOOP_STREAK_THRESHOLD = 5; loopThreshSlider.value = 5; document.getElementById('loopThreshValue').textContent = 5;
          NO_PROGRESS_THRESHOLD = 150; progThreshSlider.value = 150; document.getElementById('progThreshValue').textContent = 150;
          ENDGAME_THRESHOLD = 80; endgameSlider.value = 80; document.getElementById('endgameValue').textContent = 80;
          COMPACT_MODE_MAX_STEPS = 450; compactSlider.value = 450; document.getElementById('compactValue').textContent = 450;
          updateCompactProfile('risky');
          changeSpeed(40);
        }
        window.loadingPreset = false;
        restartGame();
      });
    });
    // initial start
    restartGame();
    document.getElementById('colsValue').textContent = COLS;
    document.getElementById('rowsValue').textContent = ROWS;
    document.getElementById('loopThreshValue').textContent = LOOP_STREAK_THRESHOLD;
    document.getElementById('progThreshValue').textContent = NO_PROGRESS_THRESHOLD;
    document.getElementById('endgameValue').textContent = ENDGAME_THRESHOLD;
    document.getElementById('compactValue').textContent = COMPACT_MODE_MAX_STEPS;
    updateCompactProfile(COMPACT_MODE_PROFILE);
  </script>
</body>
</html>
