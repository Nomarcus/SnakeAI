<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Simulation - DQN Lab</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --accent: #f093fb;
      --success: #4ade80;
      --danger: #ef4444;
      --warning: #fbbf24;
      --dark: #1a1a2e;
      --darker: #0f0f23;
      --light: #eef2ff;
      --text: #e2e8f0;
      --glass: rgba(255, 255, 255, 0.08);
      --glass-border: rgba(255, 255, 255, 0.2);
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
      min-height: 100vh;
      color: var(--text);
      overflow-x: hidden;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
      opacity: 0.03;
      animation: rotate 60s linear infinite;
      z-index: -1;
    }
    @keyframes rotate {
      to { transform: rotate(360deg); }
    }
    nav {
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--glass-border);
      padding: 1rem 2rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }
    .nav-container {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1.5rem;
    }
    .logo {
      font-size: 1.8rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .logo::before {
      content: 'üß†';
      font-size: 1.9rem;
      -webkit-text-fill-color: initial;
    }
    .nav-links {
      display: flex;
      gap: 2rem;
      list-style: none;
      flex-wrap: wrap;
    }
    .nav-links a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      transition: all 0.3s ease;
      padding: 0.5rem 1rem;
      border-radius: 0.75rem;
    }
    .nav-links a:hover,
    .nav-links a.active {
      color: var(--accent);
      background: rgba(255, 255, 255, 0.08);
    }
    .page {
      display: none;
      animation: fadeIn 0.5s ease-in-out;
    }
    .page.active {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 3rem 2rem 4rem;
    }
    .hero {
      text-align: center;
      margin-bottom: 3rem;
    }
    .hero h1 {
      font-size: 3.4rem;
      font-weight: 900;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, var(--light) 0%, var(--accent) 50%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient 4s ease-in-out infinite;
      background-size: 200%;
    }
    @keyframes gradient {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    .hero p {
      font-size: 1.2rem;
      color: var(--text);
      opacity: 0.85;
      max-width: 650px;
      margin: 0.5rem auto 0;
      line-height: 1.6;
    }
    .lab-wrapper {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(320px, 380px);
      gap: 2.5rem;
      align-items: start;
    }
    .game-container {
      background: var(--glass);
      backdrop-filter: blur(18px);
      border: 1px solid var(--glass-border);
      border-radius: 2rem;
      padding: 2rem;
      position: relative;
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.25);
      overflow: hidden;
    }
    .game-container::before {
      content: '';
      position: absolute;
      inset: -2px;
      background: linear-gradient(135deg, rgba(102,126,234,0.35), rgba(118,75,162,0.35));
      border-radius: 2rem;
      opacity: 0;
      transition: opacity 0.35s ease;
      z-index: -1;
    }
    .game-container:hover::before {
      opacity: 1;
    }
    canvas {
      display: block;
      margin: 0 auto;
      border-radius: 1.5rem;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.35);
      transition: transform 0.4s ease;
    }
    canvas:hover {
      transform: scale(1.01);
    }
    .control-panel {
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 1.75rem;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      gap: 1.75rem;
      box-shadow: 0 14px 35px rgba(0,0,0,0.22);
      max-height: 90vh;
      overflow-y: auto;
    }
    .control-panel::-webkit-scrollbar {
      width: 8px;
    }
    .control-panel::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
    }
    .control-panel::-webkit-scrollbar-thumb {
      background: rgba(102,126,234,0.6);
      border-radius: 4px;
    }
    .panel-section {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .panel-section h3 {
      font-size: 1.2rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.6rem;
      letter-spacing: 0.02em;
    }
    .panel-section h3::before {
      content: '‚öôÔ∏è';
      font-size: 1.4rem;
    }
    .panel-section.training h3::before { content: 'üöÄ'; }
    .panel-section.status h3::before { content: 'üìä'; }
    .panel-section.metrics h3::before { content: 'üßæ'; }
    .panel-section.info h3::before { content: 'üí°'; }
    .button-group {
      display: grid;
      gap: 0.75rem;
    }
    .button {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      border: none;
      padding: 0.85rem 1.4rem;
      border-radius: 0.9rem;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      box-shadow: 0 8px 20px rgba(102,126,234,0.35);
    }
    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 28px rgba(102,126,234,0.45);
    }
    .button:active {
      transform: translateY(0);
    }
    .button.secondary {
      background: linear-gradient(135deg, rgba(102,126,234,0.25), rgba(240,147,251,0.25));
      color: var(--light);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: none;
    }
    .button.danger {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      box-shadow: 0 10px 24px rgba(239,68,68,0.35);
    }
    .toggle-button {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.85rem 1.1rem;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--glass-border);
      border-radius: 0.9rem;
      cursor: pointer;
      transition: border 0.3s ease, box-shadow 0.3s ease;
    }
    .toggle-button.active {
      border-color: var(--success);
      box-shadow: 0 0 0 2px rgba(74,222,128,0.45);
      background: rgba(74,222,128,0.12);
    }
    .toggle-indicator {
      width: 50px;
      height: 28px;
      border-radius: 28px;
      background: rgba(255,255,255,0.12);
      position: relative;
      transition: background 0.3s ease;
    }
    .toggle-indicator::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: white;
      transition: transform 0.3s ease;
    }
    .toggle-button.active .toggle-indicator {
      background: rgba(74,222,128,0.6);
    }
    .toggle-button.active .toggle-indicator::after {
      transform: translateX(22px);
    }
    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.9rem;
    }
    .status-card {
      background: rgba(0,0,0,0.25);
      border-radius: 1rem;
      padding: 1rem 1.1rem;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: inset 0 2px 15px rgba(0,0,0,0.2);
    }
    .status-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      opacity: 0.7;
    }
    .status-value {
      font-size: 1.35rem;
      font-weight: 700;
      margin-top: 0.4rem;
    }
    .status-value.accent { color: var(--accent); }
    .status-value.success { color: var(--success); }
    .status-value.warning { color: var(--warning); }
    .slider-control {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .slider-label {
      display: flex;
      justify-content: space-between;
      font-weight: 500;
      font-size: 0.95rem;
    }
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: rgba(255,255,255,0.08);
      outline: none;
      border: 1px solid rgba(255,255,255,0.12);
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      cursor: pointer;
      box-shadow: 0 0 12px rgba(102,126,234,0.5);
      transition: transform 0.2s ease;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }
    .log-area {
      background: rgba(0,0,0,0.25);
      border-radius: 1rem;
      padding: 1rem;
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 0.9rem;
      line-height: 1.6;
      max-height: 180px;
      overflow-y: auto;
      white-space: pre-line;
    }
    .info-card {
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      box-shadow: 0 12px 32px rgba(0,0,0,0.2);
      margin-bottom: 2rem;
    }
    .info-card h2 {
      color: var(--accent);
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }
    .info-card h3 {
      color: var(--primary);
      margin: 1.4rem 0 0.6rem;
    }
    .info-card p,
    .info-card li {
      line-height: 1.7;
      opacity: 0.9;
    }
    .info-card ul {
      list-style: none;
      padding-left: 0;
    }
    .info-card li {
      position: relative;
      padding-left: 1.6rem;
      margin-bottom: 0.5rem;
    }
    .info-card li::before {
      content: '‚Üí';
      position: absolute;
      left: 0;
      color: var(--accent);
      font-weight: 700;
    }
    @media (max-width: 1100px) {
      .lab-wrapper {
        grid-template-columns: 1fr;
      }
      .control-panel {
        max-height: none;
      }
    }
    @media (max-width: 720px) {
      .hero h1 {
        font-size: 2.4rem;
      }
      .nav-links {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <nav>
    <div class="nav-container">
      <div class="logo">Snake DQN Lab</div>
      <ul class="nav-links">
        <li><a href="#" class="nav-link active" data-page="lab">Tr√§ningslab</a></li>
        <li><a href="#" class="nav-link" data-page="guide">L√§r dig DQN</a></li>
        <li><a href="#" class="nav-link" data-page="presets">Hyperparametrar</a></li>
        <li><a href="#" class="nav-link" data-page="contact">Kontakt</a></li>
      </ul>
    </div>
  </nav>
  <div id="lab-page" class="page active">
    <div class="container">
      <div class="hero">
        <h1>Snake Deep Q-Network Lab</h1>
        <p>Tr√§na en agent i realtid och v√§xla mellan klassisk DQN och Double DQN f√∂r att se skillnaden i stabilitet och precision.</p>
      </div>
      <div class="lab-wrapper">
        <div class="game-container">
          <canvas id="game" width="600" height="600"></canvas>
        </div>
        <aside class="control-panel">
          <section class="panel-section training">
            <h3>Tr√§ningskontroller</h3>
            <div class="button-group">
              <button id="startTraining" class="button">üöÄ Starta tr√§ning</button>
              <button id="pauseTraining" class="button secondary">‚è∏Ô∏è Pausa</button>
              <button id="stepOnce" class="button secondary">üë£ K√∂r ett steg</button>
              <button id="resetAgent" class="button danger">‚ôªÔ∏è Reset milj√∂</button>
            </div>
            <div id="doubleToggle" class="toggle-button">
              <div>
                <strong>Double DQN</strong>
                <p style="font-size:0.85rem; opacity:0.75; margin-top:0.15rem;">Stabilare targetuppskattning via tv√• n√§tverk.</p>
              </div>
              <div class="toggle-indicator"></div>
            </div>
          </section>
          <section class="panel-section">
            <h3>Hastighet &amp; Utforskning</h3>
            <div class="slider-control">
              <div class="slider-label">Simuleringshastighet <span id="speedLabel">50 ms</span></div>
              <input id="speedSlider" type="range" min="10" max="200" value="50">
            </div>
            <div class="slider-control">
              <div class="slider-label">Epsilon-min (slutlig utforskning) <span id="epsilonMinLabel">0.05</span></div>
              <input id="epsilonMinSlider" type="range" min="1" max="40" value="5">
            </div>
            <div class="slider-control">
              <div class="slider-label">Epsilon-decay (√ó10‚Åª¬≥) <span id="epsilonDecayLabel">5</span></div>
              <input id="epsilonDecaySlider" type="range" min="1" max="20" value="5">
            </div>
          </section>
          <section class="panel-section status">
            <h3>Live status</h3>
            <div class="status-grid">
              <div class="status-card">
                <div class="status-label">Avsnitt</div>
                <div id="episodesValue" class="status-value accent">0</div>
              </div>
              <div class="status-card">
                <div class="status-label">B√§sta po√§ng</div>
                <div id="bestScoreValue" class="status-value success">0</div>
              </div>
              <div class="status-card">
                <div class="status-label">Medelbel√∂ning (senaste 50)</div>
                <div id="avgRewardValue" class="status-value">0.00</div>
              </div>
              <div class="status-card">
                <div class="status-label">Aktuell epsilon</div>
                <div id="epsilonValue" class="status-value warning">1.00</div>
              </div>
            </div>
          </section>
          <section class="panel-section metrics">
            <h3>Tr√§ningslogg</h3>
            <div id="logArea" class="log-area">Agent redo. V√§nta p√• f√∂rsta avsnittet...</div>
          </section>
          <section class="panel-section info">
            <h3>DQN-snabbguide</h3>
            <ul>
              <li><strong>Epsilon-greedy:</strong> H√∂g utforskning i b√∂rjan, sjunkande mot v√§rdemaximering.</li>
              <li><strong>Replay-minne:</strong> Blandar erfarenheter f√∂r stabilare gradienter.</li>
              <li><strong>Target-n√§t:</strong> Frysta viktkopior som uppdateras regelbundet.</li>
              <li><strong>Double DQN:</strong> V√§ljer handling med policy-n√§tet men v√§rderar den med target-n√§tet.</li>
            </ul>
          </section>
        </aside>
      </div>
    </div>
  </div>
  <div id="guide-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>L√§r dig Deep Q-Networks</h1>
        <p>F√∂rst√• hur Q-v√§rden uppdateras och varf√∂r stabilitet √§r avg√∂rande i Snake.</p>
      </div>
      <div class="info-card">
        <h2>üåê Fr√•n spelplan till tillst√•nd</h2>
        <p>Vi beskriver Snake-br√§det med 11 signaler: risk rakt fram, √•t h√∂ger och v√§nster, nuvarande riktning samt matens relativa position. Kombinationen ger agenten tillr√§cklig information f√∂r att fatta beslut utan att beh√∂va hela kartan.</p>
        <h3>üèÅ Bel√∂ningsdesign</h3>
        <ul>
          <li>+1 n√§r √§pplet √§ts</li>
          <li>-1 vid krock</li>
          <li>Sm√• incitament f√∂r att r√∂ra sig n√§rmare bortre m√•l och undvika stasis</li>
        </ul>
        <h3>üß† Q-uppdatering</h3>
        <p>Vid varje steg ber√§knas <code>Q(s,a)</code> med Bellman-ekvationen. Double DQN separerar action-valet (<code>argmax</code>) fr√•n v√§rderingen, vilket d√§mpar √∂veroptimistiska uppdateringar.</p>
      </div>
      <div class="info-card">
        <h2>üîÑ Tr√§ningscykeln</h2>
        <ol style="margin-left:1.5rem; line-height:1.8;">
          <li>Agenten v√§ljer handling via epsilon-greedy.</li>
          <li>Milj√∂n svarar med nytt tillst√•nd, bel√∂ning och om episoden √§r slut.</li>
          <li>Erfarenheten l√§ggs i replay-minnet.</li>
          <li>Mini-batcher tr√§nar n√§tverket och target-vikter synkas periodiskt.</li>
        </ol>
        <p>Detta loopas tusentals g√•nger tills agenten l√§rt sig h√•llbara banor.</p>
      </div>
    </div>
  </div>
  <div id="presets-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Hyperparameter-presets</h1>
        <p>Testa f√§rdiga kombinationer f√∂r snabb experimentering.</p>
      </div>
      <div class="info-card" style="border: 1px solid rgba(74,222,128,0.4);">
        <h2>üöÄ Snabbinl√§rning</h2>
        <ul>
          <li>Hastighet: 30 ms</li>
          <li>Epsilon-min: 0.02</li>
          <li>Epsilon-decay: 8 √ó 10‚Åª¬≥</li>
          <li>Target-uppdatering: var 40:e batch</li>
        </ul>
        <button class="button" data-preset="fast">Ladda preset</button>
      </div>
      <div class="info-card" style="border: 1px solid rgba(240,147,251,0.4);">
        <h2>üõ°Ô∏è Stabilitet</h2>
        <ul>
          <li>Hastighet: 80 ms</li>
          <li>Epsilon-min: 0.08</li>
          <li>Epsilon-decay: 4 √ó 10‚Åª¬≥</li>
          <li>Target-uppdatering: var 20:e batch</li>
        </ul>
        <button class="button" data-preset="stable">Ladda preset</button>
      </div>
      <div class="info-card" style="border: 1px solid rgba(251,191,36,0.45);">
        <h2>‚öñÔ∏è Balans</h2>
        <ul>
          <li>Hastighet: 55 ms</li>
          <li>Epsilon-min: 0.05</li>
          <li>Epsilon-decay: 5 √ó 10‚Åª¬≥</li>
          <li>Target-uppdatering: var 30:e batch</li>
        </ul>
        <button class="button" data-preset="balanced">Ladda preset</button>
      </div>
    </div>
  </div>
  <div id="contact-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Kontakta mig</h1>
        <p>Har du resultat eller fr√•gor kring tr√§ningen? H√∂r av dig!</p>
      </div>
      <div class="info-card" style="text-align:center; max-width:600px; margin:0 auto;">
        <h2>üì¨ Kontakt</h2>
        <p style="font-size:1.1rem;">Marcus Petersson</p>
        <a href="mailto:nomarcus@hotmail.com" class="button" style="display:inline-block; margin-top:1rem;">‚úâÔ∏è nomarcus@hotmail.com</a>
        <p style="margin-top:2rem; font-size:0.9rem; opacity:0.7;">Senast uppdaterad av Marcus Petersson ¬∑ 2025-09-08</p>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.19.0/dist/tf.min.js"></script>
  <script>
    const navLinks = document.querySelectorAll('.nav-link');
    const pages = document.querySelectorAll('.page');
    navLinks.forEach(link => {
      link.addEventListener('click', (event) => {
        event.preventDefault();
        const target = link.dataset.page;
        navLinks.forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        pages.forEach(page => page.classList.remove('active'));
        document.getElementById(`${target}-page`).classList.add('active');
      });
    });

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
        if (radius === undefined) {
          radius = 5;
        }
        if (typeof radius === 'number') {
          radius = { tl: radius, tr: radius, br: radius, bl: radius };
        } else {
          const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
          for (const side in defaultRadius) {
            radius[side] = radius[side] || defaultRadius[side];
          }
        }
        this.beginPath();
        this.moveTo(x + radius.tl, y);
        this.lineTo(x + width - radius.tr, y);
        this.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
        this.lineTo(x + width, y + height - radius.br);
        this.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
        this.lineTo(x + radius.bl, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
        this.lineTo(x, y + radius.tl);
        this.quadraticCurveTo(x, y, x + radius.tl, y);
        this.closePath();
        return this;
      };
    }

    const config = {
      cols: 15,
      rows: 15,
      cellSize: canvas.width / 15,
      maxMemory: 4000,
      batchSize: 64,
      gamma: 0.95,
      epsilon: 1,
      epsilonMin: 0.05,
      epsilonDecay: 0.005,
      learningRate: 0.001,
      targetSync: 30,
      doubleDQN: false,
      speed: 50
    };

    class SnakeGame {
      constructor(cols, rows) {
        this.cols = cols;
        this.rows = rows;
        this.reset();
      }

      reset() {
        this.direction = { x: 1, y: 0 };
        const startX = Math.floor(this.cols / 2);
        const startY = Math.floor(this.rows / 2);
        this.snake = [
          { x: startX, y: startY },
          { x: startX - 1, y: startY },
          { x: startX - 2, y: startY }
        ];
        this.score = 0;
        this.stepsSinceFood = 0;
        this.done = false;
        this.spawnFood();
        return this.getState();
      }

      spawnFood() {
        const free = [];
        const occupied = new Set(this.snake.map(p => `${p.x},${p.y}`));
        for (let y = 0; y < this.rows; y++) {
          for (let x = 0; x < this.cols; x++) {
            if (!occupied.has(`${x},${y}`)) free.push({ x, y });
          }
        }
        this.food = free.length ? free[Math.floor(Math.random() * free.length)] : { x: -1, y: -1 };
      }

      step(actionIndex) {
        if (this.done) return { state: this.getState(), reward: 0, done: true };

        this.direction = this.applyAction(actionIndex);
        const newHead = {
          x: this.snake[0].x + this.direction.x,
          y: this.snake[0].y + this.direction.y
        };

        let reward = -0.01;
        this.stepsSinceFood++;

        if (this.isCollision(newHead)) {
          this.done = true;
          reward = -1;
          return { state: this.getState(), reward, done: true };
        }

        this.snake.unshift(newHead);

        if (newHead.x === this.food.x && newHead.y === this.food.y) {
          reward = 1;
          this.score += 1;
          this.stepsSinceFood = 0;
          this.spawnFood();
        } else {
          this.snake.pop();
        }

        if (this.stepsSinceFood > this.cols * this.rows * 2) {
          this.done = true;
          reward = -0.5;
        }

        const state = this.getState();
        reward += this.foodHeuristicReward(newHead);
        return { state, reward, done: this.done };
      }

      foodHeuristicReward(head) {
        if (this.done || this.food.x === -1) return 0;
        const prev = this.snake[1];
        const prevDistance = Math.abs(prev.x - this.food.x) + Math.abs(prev.y - this.food.y);
        const newDistance = Math.abs(head.x - this.food.x) + Math.abs(head.y - this.food.y);
        if (newDistance < prevDistance) return 0.05;
        if (newDistance > prevDistance) return -0.02;
        return 0;
      }

      applyAction(actionIndex) {
        const directions = [
          { x: this.direction.x, y: this.direction.y },
          this.turnRight(this.direction),
          this.turnLeft(this.direction)
        ];
        return directions[actionIndex] || directions[0];
      }

      turnRight(dir) {
        return { x: -dir.y, y: dir.x };
      }

      turnLeft(dir) {
        return { x: dir.y, y: -dir.x };
      }

      isCollision(point) {
        if (point.x < 0 || point.x >= this.cols || point.y < 0 || point.y >= this.rows) return true;
        return this.snake.some(segment => segment.x === point.x && segment.y === point.y);
      }

      getState() {
        const head = this.snake[0];
        const pointLeft = { x: head.x - 1, y: head.y };
        const pointRight = { x: head.x + 1, y: head.y };
        const pointUp = { x: head.x, y: head.y - 1 };
        const pointDown = { x: head.x, y: head.y + 1 };

        const dirLeft = this.direction.x === -1;
        const dirRight = this.direction.x === 1;
        const dirUp = this.direction.y === -1;
        const dirDown = this.direction.y === 1;

        const dangerStraight = this.isCollision({ x: head.x + this.direction.x, y: head.y + this.direction.y }) ? 1 : 0;
        const dangerRight = this.isCollision(this.turnRightPoint(head)) ? 1 : 0;
        const dangerLeft = this.isCollision(this.turnLeftPoint(head)) ? 1 : 0;

        const foodLeft = this.food.x < head.x ? 1 : 0;
        const foodRight = this.food.x > head.x ? 1 : 0;
        const foodUp = this.food.y < head.y ? 1 : 0;
        const foodDown = this.food.y > head.y ? 1 : 0;

        return new Float32Array([
          dangerStraight,
          dangerRight,
          dangerLeft,
          dirLeft ? 1 : 0,
          dirRight ? 1 : 0,
          dirUp ? 1 : 0,
          dirDown ? 1 : 0,
          foodLeft,
          foodRight,
          foodUp,
          foodDown
        ]);
      }

      turnRightPoint(head) {
        const dir = this.turnRight(this.direction);
        return { x: head.x + dir.x, y: head.y + dir.y };
      }

      turnLeftPoint(head) {
        const dir = this.turnLeft(this.direction);
        return { x: head.x + dir.x, y: head.y + dir.y };
      }

      render(context, cellSize) {
        context.clearRect(0, 0, canvas.width, canvas.height);
        const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#0f0f23');
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);

        const gridColor = 'rgba(255,255,255,0.04)';
        context.strokeStyle = gridColor;
        context.lineWidth = 1;
        for (let x = 0; x <= this.cols; x++) {
          context.beginPath();
          context.moveTo(x * cellSize, 0);
          context.lineTo(x * cellSize, canvas.height);
          context.stroke();
        }
        for (let y = 0; y <= this.rows; y++) {
          context.beginPath();
          context.moveTo(0, y * cellSize);
          context.lineTo(canvas.width, y * cellSize);
          context.stroke();
        }

        if (this.food && this.food.x >= 0) {
          const fx = this.food.x * cellSize;
          const fy = this.food.y * cellSize;
          const size = cellSize * 0.8;
          const offset = (cellSize - size) / 2;
          context.fillStyle = '#ef4444';
          context.beginPath();
          context.roundRect(fx + offset, fy + offset, size, size, cellSize * 0.3);
          context.fill();
          context.fillStyle = '#fff';
          context.globalAlpha = 0.25;
          context.fillRect(fx + offset, fy + offset, size, size / 3);
          context.globalAlpha = 1;
        }

        this.snake.forEach((segment, index) => {
          const size = cellSize * 0.85;
          const offset = (cellSize - size) / 2;
          const x = segment.x * cellSize + offset;
          const y = segment.y * cellSize + offset;
          const gradient = context.createLinearGradient(x, y, x + size, y + size);
          if (index === 0) {
            gradient.addColorStop(0, config.doubleDQN ? '#22c55e' : '#60a5fa');
            gradient.addColorStop(1, config.doubleDQN ? '#16a34a' : '#2563eb');
          } else {
            gradient.addColorStop(0, '#7c3aed');
            gradient.addColorStop(1, '#5b21b6');
          }
          context.fillStyle = gradient;
          context.beginPath();
          context.roundRect(x, y, size, size, cellSize * 0.3);
          context.fill();
        });
      }
    }

    class ReplayMemory {
      constructor(maxSize) {
        this.maxSize = maxSize;
        this.buffer = [];
      }
      push(experience) {
        if (this.buffer.length >= this.maxSize) {
          this.buffer.shift();
        }
        this.buffer.push(experience);
      }
      sample(batchSize) {
        const sample = [];
        const bufferLength = this.buffer.length;
        for (let i = 0; i < batchSize; i++) {
          const index = Math.floor(Math.random() * bufferLength);
          sample.push(this.buffer[index]);
        }
        return sample;
      }
      size() {
        return this.buffer.length;
      }
      clear() {
        this.buffer = [];
      }
    }

    class DQNAgent {
      constructor(stateSize, actionSize, options) {
        this.stateSize = stateSize;
        this.actionSize = actionSize;
        this.memory = new ReplayMemory(options.maxMemory);
        this.gamma = options.gamma;
        this.epsilon = options.epsilon;
        this.epsilonMin = options.epsilonMin;
        this.epsilonDecay = options.epsilonDecay;
        this.learningRate = options.learningRate;
        this.batchSize = options.batchSize;
        this.targetSync = options.targetSync;
        this.useDouble = options.doubleDQN;
        this.trainSteps = 0;
        this.model = this.buildModel();
        this.targetModel = this.buildModel();
        this.updateTargetModel();
      }

      buildModel() {
        const model = tf.sequential();
        model.add(tf.layers.dense({ inputShape: [this.stateSize], units: 128, activation: 'relu' }));
        model.add(tf.layers.dense({ units: 128, activation: 'relu' }));
        model.add(tf.layers.dense({ units: this.actionSize, activation: 'linear' }));
        model.compile({ optimizer: tf.train.adam(this.learningRate), loss: 'meanSquaredError' });
        return model;
      }

      updateTargetModel() {
        const weights = this.model.getWeights();
        this.targetModel.setWeights(weights.map(w => w.clone()));
        weights.forEach(w => w.dispose());
      }

      act(state) {
        if (Math.random() < this.epsilon) {
          return Math.floor(Math.random() * this.actionSize);
        }
        return tf.tidy(() => {
          const stateTensor = tf.tensor2d([Array.from(state)]);
          const prediction = this.model.predict(stateTensor);
          const action = prediction.argMax(1).dataSync()[0];
          stateTensor.dispose();
          prediction.dispose();
          return action;
        });
      }

      remember(state, action, reward, nextState, done) {
        this.memory.push({ state: Array.from(state), action, reward, nextState: Array.from(nextState), done });
      }

      setDoubleDQN(enabled) {
        this.useDouble = enabled;
      }

      setEpsilonMin(value) {
        this.epsilonMin = value;
      }

      setEpsilonDecay(value) {
        this.epsilonDecay = value;
      }

      async replay() {
        if (this.memory.size() < this.batchSize) return;
        const minibatch = this.memory.sample(this.batchSize);
        const states = [];
        const targets = [];

        for (const experience of minibatch) {
          const { state, action, reward, nextState, done } = experience;
          const stateTensor = tf.tensor2d([state]);
          const targetTensor = this.model.predict(stateTensor);
          const targetData = targetTensor.dataSync();
          let qUpdate = reward;

          if (!done) {
            const nextTensor = tf.tensor2d([nextState]);
            if (this.useDouble) {
              const actionTensor = this.model.predict(nextTensor);
              const bestActionTensor = actionTensor.argMax(1);
              const bestAction = bestActionTensor.dataSync()[0];
              const targetNext = this.targetModel.predict(nextTensor);
              const targetValues = targetNext.dataSync();
              qUpdate += this.gamma * targetValues[bestAction];
              actionTensor.dispose();
              bestActionTensor.dispose();
              targetNext.dispose();
            } else {
              const targetNext = this.targetModel.predict(nextTensor);
              const maxTensor = targetNext.max(1);
              const targetValue = maxTensor.dataSync()[0];
              qUpdate += this.gamma * targetValue;
              maxTensor.dispose();
              targetNext.dispose();
            }
            nextTensor.dispose();
          }

          targetData[action] = qUpdate;
          states.push(state);
          targets.push(Array.from(targetData));
          stateTensor.dispose();
          targetTensor.dispose();
        }

        const statesTensor = tf.tensor2d(states);
        const targetsTensor = tf.tensor2d(targets);
        await this.model.fit(statesTensor, targetsTensor, { epochs: 1, verbose: 0 });
        statesTensor.dispose();
        targetsTensor.dispose();

        if (this.epsilon > this.epsilonMin) {
          this.epsilon = Math.max(this.epsilonMin, this.epsilon * (1 - this.epsilonDecay));
        }

        this.trainSteps++;
        if (this.trainSteps % this.targetSync === 0) {
          this.updateTargetModel();
        }
      }

      dispose() {
        this.model.dispose();
        this.targetModel.dispose();
      }
    }

    const game = new SnakeGame(config.cols, config.rows);
    let agent = new DQNAgent(game.getState().length, 3, config);

    let isTraining = false;
    let episodeCount = 0;
    let bestScore = 0;
    const rewardHistory = [];
    let currentEpisodeReward = 0;
    let trainingHandle = null;

    const episodesValue = document.getElementById('episodesValue');
    const bestScoreValue = document.getElementById('bestScoreValue');
    const avgRewardValue = document.getElementById('avgRewardValue');
    const epsilonValue = document.getElementById('epsilonValue');
    const logArea = document.getElementById('logArea');
    const speedSlider = document.getElementById('speedSlider');
    const speedLabel = document.getElementById('speedLabel');
    const epsilonMinSlider = document.getElementById('epsilonMinSlider');
    const epsilonMinLabel = document.getElementById('epsilonMinLabel');
    const epsilonDecaySlider = document.getElementById('epsilonDecaySlider');
    const epsilonDecayLabel = document.getElementById('epsilonDecayLabel');
    const toggleDouble = document.getElementById('doubleToggle');

    function updateUI() {
      episodesValue.textContent = episodeCount;
      bestScoreValue.textContent = bestScore;
      epsilonValue.textContent = agent.epsilon.toFixed(2);
      const recent = rewardHistory.slice(-50);
      const avg = recent.length ? recent.reduce((a, b) => a + b, 0) / recent.length : 0;
      avgRewardValue.textContent = avg.toFixed(2);
    }

    function log(message) {
      const timestamp = new Date().toLocaleTimeString();
      logArea.textContent = `[${timestamp}] ${message}\n` + logArea.textContent;
    }

    async function runStep() {
      const currentState = game.getState();
      const action = agent.act(currentState);
      const { state: nextState, reward, done } = game.step(action);
      currentEpisodeReward += reward;
      agent.remember(currentState, action, reward, nextState, done);
      await agent.replay();
      game.render(ctx, config.cellSize);
      updateUI();

      if (done) {
        episodeCount++;
        rewardHistory.push(currentEpisodeReward);
        if (rewardHistory.length > 200) rewardHistory.shift();
        bestScore = Math.max(bestScore, game.score);
        log(`Avsnitt ${episodeCount}: po√§ng ${game.score}, total bel√∂ning ${currentEpisodeReward.toFixed(2)}`);
        currentEpisodeReward = 0;
        game.reset();
      }
    }

    async function trainingLoop() {
      if (!isTraining) return;
      await runStep();
      trainingHandle = setTimeout(trainingLoop, config.speed);
    }

    document.getElementById('startTraining').addEventListener('click', () => {
      if (isTraining) return;
      isTraining = true;
      log('Tr√§ning startad.');
      trainingLoop();
    });

    document.getElementById('pauseTraining').addEventListener('click', () => {
      if (!isTraining) return;
      isTraining = false;
      if (trainingHandle) clearTimeout(trainingHandle);
      log('Tr√§ning pausad.');
    });

    document.getElementById('stepOnce').addEventListener('click', async () => {
      if (isTraining) return;
      await runStep();
    });

    document.getElementById('resetAgent').addEventListener('click', () => {
      isTraining = false;
      if (trainingHandle) clearTimeout(trainingHandle);
      agent.dispose();
      agent = new DQNAgent(game.getState().length, 3, config);
      game.reset();
      currentEpisodeReward = 0;
      episodeCount = 0;
      bestScore = 0;
      rewardHistory.length = 0;
      agent.epsilon = 1;
      updateUI();
      game.render(ctx, config.cellSize);
      log('Agent och milj√∂ √•terst√§llda.');
    });

    speedSlider.addEventListener('input', (event) => {
      const value = Number(event.target.value);
      config.speed = value;
      speedLabel.textContent = `${value} ms`;
    });

    epsilonMinSlider.addEventListener('input', (event) => {
      const value = (Number(event.target.value) / 100).toFixed(2);
      config.epsilonMin = Number(value);
      agent.setEpsilonMin(Number(value));
      epsilonMinLabel.textContent = value;
    });

    epsilonDecaySlider.addEventListener('input', (event) => {
      const value = Number(event.target.value);
      const decay = value / 1000;
      config.epsilonDecay = decay;
      agent.setEpsilonDecay(decay);
      epsilonDecayLabel.textContent = value;
    });

    toggleDouble.addEventListener('click', () => {
      config.doubleDQN = !config.doubleDQN;
      toggleDouble.classList.toggle('active', config.doubleDQN);
      agent.setDoubleDQN(config.doubleDQN);
      log(config.doubleDQN ? 'Double DQN aktiverad.' : 'Double DQN avst√§ngd.');
      game.render(ctx, config.cellSize);
    });

    document.querySelectorAll('[data-preset]').forEach(button => {
      button.addEventListener('click', () => {
        const preset = button.dataset.preset;
        if (preset === 'fast') {
          speedSlider.value = 30; speedSlider.dispatchEvent(new Event('input'));
          epsilonMinSlider.value = 2; epsilonMinSlider.dispatchEvent(new Event('input'));
          epsilonDecaySlider.value = 8; epsilonDecaySlider.dispatchEvent(new Event('input'));
          agent.targetSync = 40;
          log('Preset "Snabbinl√§rning" laddad.');
        } else if (preset === 'stable') {
          speedSlider.value = 80; speedSlider.dispatchEvent(new Event('input'));
          epsilonMinSlider.value = 8; epsilonMinSlider.dispatchEvent(new Event('input'));
          epsilonDecaySlider.value = 4; epsilonDecaySlider.dispatchEvent(new Event('input'));
          agent.targetSync = 20;
          log('Preset "Stabilitet" laddad.');
        } else if (preset === 'balanced') {
          speedSlider.value = 55; speedSlider.dispatchEvent(new Event('input'));
          epsilonMinSlider.value = 5; epsilonMinSlider.dispatchEvent(new Event('input'));
          epsilonDecaySlider.value = 5; epsilonDecaySlider.dispatchEvent(new Event('input'));
          agent.targetSync = 30;
          log('Preset "Balans" laddad.');
        }
      });
    });

    function init() {
      toggleDouble.classList.toggle('active', config.doubleDQN);
      speedLabel.textContent = `${config.speed} ms`;
      epsilonMinLabel.textContent = config.epsilonMin.toFixed(2);
      epsilonDecayLabel.textContent = Math.round(config.epsilonDecay * 1000);
      game.render(ctx, config.cellSize);
      updateUI();
    }

    init();
  </script>
</body>
</html>
