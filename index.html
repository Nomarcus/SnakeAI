<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake AI - Singularity Edition</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Syncopate:wght@400;700&family=JetBrains+Mono:wght@400;700&display=swap');

    :root {
      --primary: #00f2ff;
      --secondary: #7000ff;
      --accent: #39ff14;
      --bg-dark: #050505;
    }

    body {
      background-color: var(--bg-dark);
      color: #fff;
      font-family: 'JetBrains Mono', monospace;
      overflow: hidden;
      height: 100vh;
    }

    .syncopate {
      font-family: 'Syncopate', sans-serif;
    }

    .bg-glow {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 800px;
      height: 800px;
      background: radial-gradient(circle, rgba(112, 0, 255, 0.15) 0%, rgba(5, 5, 5, 0) 70%);
      z-index: -1;
      filter: blur(80px);
      animation: pulse-bg 10s infinite alternate;
    }

    @keyframes pulse-bg {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
      100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.8; }
    }

    .canvas-frame {
      position: relative;
      padding: 10px;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      border-radius: 12px;
      box-shadow: 0 0 50px rgba(112, 0, 255, 0.4);
    }

    canvas {
      background: #000;
      border-radius: 8px;
      display: block;
    }

    .glass-panel {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
    }

    .neon-text {
      text-shadow: 0 0 10px var(--primary);
    }

    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-thumb { background: var(--secondary); border-radius: 10px; }
  </style>
</head>
<body class="flex items-center justify-center">
  <div class="bg-glow"></div>

  <div class="w-full max-w-7xl h-[90vh] grid grid-cols-12 gap-6 p-6">

    <div class="col-span-3 flex flex-col gap-6">
      <div class="glass-panel p-6 flex flex-col justify-between">
        <div>
          <h2 class="syncopate text-[10px] tracking-[0.4em] text-slate-500 mb-6 uppercase">System_Identifier</h2>
          <h1 class="text-3xl font-bold syncopate italic leading-none mb-2 tracking-tighter neon-text">SNAKE_ML<br>PRO_X</h1>
          <div class="text-[9px] text-cyan-400 font-bold tracking-widest opacity-80 uppercase">Hamiltonian Singularity Engine</div>
        </div>

        <div class="mt-8 space-y-4">
          <div class="flex justify-between items-end border-b border-white/5 pb-2">
            <span class="text-[10px] text-slate-500 uppercase">Efficiency</span>
            <span id="coverageVal" class="text-xl font-bold syncopate text-accent">0%</span>
          </div>
          <div class="flex justify-between items-end border-b border-white/5 pb-2">
            <span class="text-[10px] text-slate-500 uppercase">Grid_Mode</span>
            <span id="gridDisplay" class="text-xl font-bold syncopate text-white">12x12</span>
          </div>
        </div>
      </div>

      <div class="glass-panel p-6 flex-1 overflow-hidden flex flex-col">
        <h3 class="text-[10px] font-bold syncopate text-slate-500 uppercase mb-4 flex items-center gap-2">
          <span class="w-1.5 h-1.5 bg-accent rounded-full animate-pulse"></span> Telemetry_Log
        </h3>
        <div id="log" class="flex-1 overflow-y-auto space-y-2 text-[10px]"></div>
      </div>
    </div>

    <div class="col-span-6 flex flex-col items-center justify-center gap-8">
      <div class="canvas-frame">
        <canvas id="gameCanvas" width="500" height="500"></canvas>
        <div id="winOverlay" class="hidden absolute inset-0 bg-black/90 z-20 flex items-center justify-center text-center">
          <div class="p-8">
            <div class="text-6xl font-black syncopate italic text-accent mb-4 tracking-tighter">SUCCESS</div>
            <p class="text-slate-400 text-xs mb-8 tracking-widest uppercase">100% Convergence Reached</p>
            <button type="button" onclick="resetGame()" class="px-10 py-4 border border-accent text-accent syncopate text-xs hover:bg-accent hover:text-black transition">REBOOT_CORE</button>
          </div>
        </div>
      </div>

      <div class="w-full max-w-[520px] grid grid-cols-4 gap-4">
        <div class="glass-panel p-4 text-center border-b-2 border-b-cyan-500">
          <div class="text-[8px] text-slate-500 uppercase mb-1">Score</div>
          <div id="scoreVal" class="text-xl font-bold syncopate">1</div>
        </div>
        <div class="glass-panel p-4 text-center border-b-2 border-b-purple-500">
          <div class="text-[8px] text-slate-500 uppercase mb-1">Total_Size</div>
          <div id="totalSizeVal" class="text-xl font-bold syncopate">144</div>
        </div>
        <div class="glass-panel p-4 text-center border-b-2 border-b-emerald-500">
          <div class="text-[8px] text-slate-500 uppercase mb-1">Step</div>
          <div id="stepVal" class="text-xl font-bold syncopate">0</div>
        </div>
        <div class="glass-panel p-4 text-center border-b-2 border-b-amber-500">
          <div class="text-[8px] text-slate-500 uppercase mb-1">Speed</div>
          <div id="speedValDisplay" class="text-xl font-bold syncopate">Max</div>
        </div>
      </div>
    </div>

    <div class="col-span-3 flex flex-col gap-6">
      <div class="glass-panel p-6 flex flex-col">
        <h3 class="text-[10px] font-bold syncopate text-slate-500 uppercase mb-4">Singularity_Core</h3>
        <div class="text-[11px] text-slate-200 leading-relaxed font-serif italic flex-1 overflow-y-auto pr-2">
          Autopiloten följer en säker Hamiltonisk cykel med kontrollerade genvägar. Ingen manuell kalibrering behövs.
        </div>
        <div class="mt-4 pt-4 border-t border-white/5">
          <canvas id="statsChart" height="80"></canvas>
        </div>
        <button type="button" onclick="resetGame()" class="mt-6 w-full py-3 border border-cyan-500/30 text-[9px] syncopate hover:bg-cyan-500/20 transition uppercase">Restart_Core</button>
      </div>
    </div>
  </div>

  <script>
    const GRID_SIZE = 12;
    const CELL_SIZE = 500 / GRID_SIZE;
    const SPEED = 160;

    let snake = [{x: 0, y: 0}];
    let food = {x: 5, y: 5};
    let score = 1;
    let steps = 0;
    let running = true;
    let hamiltonPath = [];
    let gameLoopTimeout;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function initEnvironment() {
      document.getElementById('gridDisplay').innerText = `${GRID_SIZE}x${GRID_SIZE}`;
      document.getElementById('totalSizeVal').innerText = GRID_SIZE * GRID_SIZE;
      hamiltonPath = generateHamiltonianCycle();
    }

    function generateHamiltonianCycle() {
      const path = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        if (x % 2 === 0) {
          for (let y = 1; y < GRID_SIZE; y++) path.push({x, y});
        } else {
          for (let y = GRID_SIZE - 1; y >= 1; y--) path.push({x, y});
        }
      }
      for (let x = GRID_SIZE - 1; x >= 0; x--) path.push({x, y: 0});
      return path;
    }

    function spawnFood() {
      const occupied = new Set();
      for (const segment of snake) {
        occupied.add(`${segment.x},${segment.y}`);
      }

      const freeCells = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          if (!occupied.has(`${x},${y}`)) {
            freeCells.push({x, y});
          }
        }
      }

      if (freeCells.length > 0) {
        const randomIndex = Math.floor(Math.random() * freeCells.length);
        food = freeCells[randomIndex];
        addLog(`TARGET_ACQUIRED: [${food.x},${food.y}]`, "text-amber-400");
      } else {
        food = {x: -1, y: -1};
      }
    }

    function getNextMove() {
      const head = snake[0];
      const currIdx = hamiltonPath.findIndex(p => p.x === head.x && p.y === head.y);
      let nextIdx = (currIdx + 1) % hamiltonPath.length;
      let finalMove = hamiltonPath[nextIdx];

      const foodIdx = hamiltonPath.findIndex(p => p.x === food.x && p.y === food.y);
      const tailIdx = hamiltonPath.findIndex(p => p.x === snake[snake.length - 1].x && p.y === snake[snake.length - 1].y);
      const totalCells = GRID_SIZE * GRID_SIZE;
      const fillRatio = score / totalCells;

      const neighbors = [
        {x: head.x + 1, y: head.y},
        {x: head.x - 1, y: head.y},
        {x: head.x, y: head.y + 1},
        {x: head.x, y: head.y - 1}
      ];

      let bestShortcutIdx = nextIdx;

      for (const n of neighbors) {
        if (n.x < 0 || n.x >= GRID_SIZE || n.y < 0 || n.y >= GRID_SIZE) continue;
        if (snake.some(s => s.x === n.x && s.y === n.y)) continue;

        const nIdx = hamiltonPath.findIndex(p => p.x === n.x && p.y === n.y);
        let isSafe = false;

        if (currIdx < tailIdx) {
          if (nIdx > currIdx && nIdx < tailIdx) isSafe = true;
        } else {
          if (nIdx > currIdx || nIdx < tailIdx) isSafe = true;
        }

        if (isSafe) {
          const distToFood = (foodIdx - nIdx + hamiltonPath.length) % hamiltonPath.length;
          const currentBestDist = (foodIdx - bestShortcutIdx + hamiltonPath.length) % hamiltonPath.length;

          if (fillRatio > 0.75) {
            if (distToFood < currentBestDist) {
              bestShortcutIdx = nIdx;
              finalMove = n;
            }
          } else {
            if (distToFood < currentBestDist) {
              bestShortcutIdx = nIdx;
              finalMove = n;
            }
          }
        }
      }

      return finalMove;
    }

    function update() {
      if (!running) return;

      const next = getNextMove();

      if (score === GRID_SIZE * GRID_SIZE) {
        document.getElementById('winOverlay').classList.remove('hidden');
        addLog("SINGULARITY_REACHED", "text-accent");
        running = false;
        return;
      }

      if (next.x === food.x && next.y === food.y) {
        score++;
        spawnFood();
        addLog(`LINK_STABLE_${score}`, "text-cyan-400");
      } else {
        snake.pop();
      }

      snake.unshift(next);
      steps++;

      updateUI();
      draw();
      gameLoopTimeout = setTimeout(update, SPEED);
    }

    function updateUI() {
      document.getElementById('scoreVal').innerText = score;
      document.getElementById('stepVal').innerText = steps;
      document.getElementById('coverageVal').innerText = ((score / (GRID_SIZE * GRID_SIZE)) * 100).toFixed(0) + "%";
      document.getElementById('speedValDisplay').innerText = SPEED <= 160 ? "Max" : "Hög";
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "rgba(255,255,255,0.03)";
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          ctx.strokeRect(i * CELL_SIZE, j * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }

      if (food.x !== -1) {
        ctx.shadowBlur = 20;
        ctx.shadowColor = "#ff3131";
        ctx.fillStyle = "#ff3131";
        ctx.beginPath();
        ctx.arc(food.x * CELL_SIZE + CELL_SIZE / 2, food.y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 4, 0, Math.PI * 2);
        ctx.fill();
      }

      snake.forEach((p, i) => {
        const isHead = i === 0;
        const ratio = i / snake.length;
        ctx.shadowBlur = isHead ? 20 : 0;
        ctx.shadowColor = "var(--primary)";
        const r = 0 + (ratio * 112);
        const g = 242 - (ratio * 242);
        const b = 255;
        ctx.fillStyle = isHead ? "#fff" : `rgba(${r}, ${g}, ${b}, ${1 - (ratio * 0.7)})`;
        const margin = isHead ? CELL_SIZE * 0.1 : CELL_SIZE * 0.15;
        ctx.beginPath();
        ctx.roundRect(
          p.x * CELL_SIZE + margin,
          p.y * CELL_SIZE + margin,
          CELL_SIZE - (margin * 2),
          CELL_SIZE - (margin * 2),
          isHead ? 6 : 3
        );
        ctx.fill();
      });
      ctx.shadowBlur = 0;
    }

    function addLog(msg, color) {
      const l = document.getElementById('log');
      const d = document.createElement('div');
      d.className = `border-b border-white/5 pb-1 ${color}`;
      d.innerHTML = `<span class="opacity-30">HEX_${steps.toString(16).toUpperCase()}</span> > ${msg}`;
      l.prepend(d);
      if (l.childNodes.length > 20) l.lastChild.remove();
    }

    function resetGame() {
      clearTimeout(gameLoopTimeout);
      snake = [{x: 0, y: 0}];
      score = 1;
      steps = 0;
      running = true;
      document.getElementById('winOverlay').classList.add('hidden');
      document.getElementById('log').innerHTML = '';
      initEnvironment();
      spawnFood();
      update();
      addLog("SYSTEM_REBOOTED", "text-accent");
    }

    const statsChart = new Chart(document.getElementById('statsChart'), {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            data: [],
            borderColor: '#7000ff',
            borderWidth: 1,
            pointRadius: 0,
            fill: true,
            backgroundColor: 'rgba(112, 0, 255, 0.05)'
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: { x: { display: false }, y: { display: false } },
        plugins: { legend: { display: false } },
        animation: false
      }
    });

    setInterval(() => {
      if (!running) return;
      statsChart.data.labels.push("");
      statsChart.data.datasets[0].data.push(score);
      if (statsChart.data.labels.length > 30) {
        statsChart.data.labels.shift();
        statsChart.data.datasets[0].data.shift();
      }
      statsChart.update();
    }, 1000);

    window.onload = resetGame;
  </script>
</body>
</html>
